"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImportUtil = void 0;
class ImportUtil {
    constructor(t, program) {
        this.t = t;
        this.program = program;
    }
    // remove one imported binding. If this is the last thing imported from the
    // given moduleSpecifier, the whole statement will also be removed.
    removeImport(moduleSpecifier, exportedName) {
        for (let topLevelPath of this.program.get('body')) {
            if (!matchModule(topLevelPath, moduleSpecifier)) {
                continue;
            }
            let importSpecifierPath = topLevelPath
                .get('specifiers')
                .find((specifierPath) => matchSpecifier(specifierPath, exportedName));
            if (importSpecifierPath) {
                if (topLevelPath.node.specifiers.length === 1) {
                    topLevelPath.remove();
                }
                else {
                    importSpecifierPath.remove();
                }
            }
        }
    }
    // remove all imports from the given moduleSpecifier
    removeAllImports(moduleSpecifier) {
        for (let topLevelPath of this.program.get('body')) {
            if (matchModule(topLevelPath, moduleSpecifier)) {
                topLevelPath.remove();
            }
        }
    }
    // Import the given value (if needed) and return an Identifier representing
    // it.
    import(
    // the spot at which you will insert the Identifier we return to you
    target, 
    // the path to the module you're importing from
    moduleSpecifier, 
    // the name you're importing from that module. Use "default" for the default
    // export. Use "*" for the namespace.
    exportedName, 
    // Optional hint for helping us pick a name for the imported binding
    nameHint) {
        var _a;
        let declaration = this.findImportFrom(moduleSpecifier);
        if (declaration) {
            let specifier = declaration
                .get('specifiers')
                .find((spec) => matchSpecifier(spec, exportedName));
            if (specifier && ((_a = target.scope.getBinding(specifier.node.local.name)) === null || _a === void 0 ? void 0 : _a.kind) === 'module') {
                return this.t.identifier(specifier.node.local.name);
            }
            else {
                return this.addSpecifier(target, declaration, exportedName, nameHint);
            }
        }
        else {
            let declaration = this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
            return this.addSpecifier(target, declaration, exportedName, nameHint);
        }
    }
    importForSideEffect(moduleSpecifier) {
        let declaration = this.findImportFrom(moduleSpecifier);
        if (!declaration) {
            this.insertAfterExistingImports(this.t.importDeclaration([], this.t.stringLiteral(moduleSpecifier)));
        }
    }
    addSpecifier(target, declaration, exportedName, nameHint) {
        let local = this.t.identifier(unusedNameLike(target, desiredName(nameHint, exportedName, target)));
        let specifier = this.buildSpecifier(exportedName, local);
        if (specifier.type === 'ImportDefaultSpecifier') {
            declaration.node.specifiers.unshift(specifier);
        }
        else {
            declaration.node.specifiers.push(specifier);
        }
        declaration.scope.registerBinding('module', declaration.get(`specifiers.${declaration.node.specifiers.length - 1}`));
        return local;
    }
    buildSpecifier(exportedName, localName) {
        switch (exportedName) {
            case 'default':
                return this.t.importDefaultSpecifier(localName);
            case '*':
                return this.t.importNamespaceSpecifier(localName);
            default:
                return this.t.importSpecifier(localName, this.t.identifier(exportedName));
        }
    }
    findImportFrom(moduleSpecifier) {
        for (let path of this.program.get('body')) {
            if (path.isImportDeclaration() && path.node.source.value === moduleSpecifier) {
                return path;
            }
        }
        return undefined;
    }
    insertAfterExistingImports(statement) {
        let lastIndex;
        for (let [index, node] of this.program.node.body.entries()) {
            if (node.type === 'ImportDeclaration') {
                lastIndex = index;
            }
        }
        if (lastIndex == null) {
            // we are intentionally not using babel's container-aware methods, because
            // while in theory it's nice that they schedule other plugins to run on
            // our nodes, in practice those nodes might get mutated or removed by some
            // other plugin in the intervening time causing failures.
            this.program.node.body.unshift(statement);
            return this.program.get('body.0');
        }
        else {
            this.program.node.body.splice(lastIndex + 1, 0, statement);
            return this.program.get(`body.${lastIndex + 1}`);
        }
    }
}
exports.ImportUtil = ImportUtil;
function unusedNameLike(path, name) {
    let candidate = name;
    let counter = 0;
    while (path.scope.hasBinding(candidate)) {
        candidate = `${name}${counter++}`;
    }
    return candidate;
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
function desiredName(nameHint, exportedName, target) {
    if (nameHint) {
        // first we opportunistically do camelization when an illegal character is
        // followed by a lowercase letter, in an effort to aid readability of the
        // output.
        let cleaned = nameHint.replace(/[^a-zA-Z_]([a-z])/g, (_m, letter) => letter.toUpperCase());
        // then we unliterally strip all remaining illegal characters.
        cleaned = cleaned.replace(/[^a-zA-Z_]/g, '');
        return cleaned;
    }
    if (exportedName === 'default' || exportedName === '*') {
        if (target.isIdentifier()) {
            return target.node.name;
        }
        else {
            return target.scope.generateUidIdentifierBasedOnNode(target.node).name;
        }
    }
    else {
        return exportedName;
    }
}
function matchSpecifier(spec, exportedName) {
    switch (exportedName) {
        case 'default':
            return spec.isImportDefaultSpecifier();
        case '*':
            return spec.isImportNamespaceSpecifier();
        default:
            return spec.isImportSpecifier() && name(spec.node.imported) === exportedName;
    }
}
function matchModule(path, moduleSpecifier) {
    return path.isImportDeclaration() && path.get('source').node.value === moduleSpecifier;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFLQSxNQUFhLFVBQVU7SUFDckIsWUFBb0IsQ0FBYSxFQUFVLE9BQTRCO1FBQW5ELE1BQUMsR0FBRCxDQUFDLENBQVk7UUFBVSxZQUFPLEdBQVAsT0FBTyxDQUFxQjtJQUFHLENBQUM7SUFFM0UsMkVBQTJFO0lBQzNFLG1FQUFtRTtJQUNuRSxZQUFZLENBQUMsZUFBdUIsRUFBRSxZQUFvQjtRQUN4RCxLQUFLLElBQUksWUFBWSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLGVBQWUsQ0FBQyxFQUFFO2dCQUMvQyxTQUFTO2FBQ1Y7WUFFRCxJQUFJLG1CQUFtQixHQUFHLFlBQVk7aUJBQ25DLEdBQUcsQ0FBQyxZQUFZLENBQUM7aUJBQ2pCLElBQUksQ0FBQyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsY0FBYyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQ3hFLElBQUksbUJBQW1CLEVBQUU7Z0JBQ3ZCLElBQUksWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDN0MsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDO2lCQUN2QjtxQkFBTTtvQkFDTCxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQztpQkFDOUI7YUFDRjtTQUNGO0lBQ0gsQ0FBQztJQUVELG9EQUFvRDtJQUNwRCxnQkFBZ0IsQ0FBQyxlQUF1QjtRQUN0QyxLQUFLLElBQUksWUFBWSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pELElBQUksV0FBVyxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsRUFBRTtnQkFDOUMsWUFBWSxDQUFDLE1BQU0s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QUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUMzRiw4REFBOEQ7UUFDOUQsT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdDLE9BQU8sT0FBTyxDQUFDO0tBQ2hCO0lBQ0QsSUFBSSxZQUFZLEtBQUssU0FBUyxJQUFJLFlBQVksS0FBSyxHQUFHLEVBQUU7UUFDdEQsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLEVBQUU7WUFDekIsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztTQUN6QjthQUFNO1lBQ0wsT0FBTyxNQUFNLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUM7U0FDeEU7S0FDRjtTQUFNO1FBQ0wsT0FBTyxZQUFZLENBQUM7S0FDckI7QUFDSCxDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsSUFBbUIsRUFBRSxZQUFvQjtJQUMvRCxRQUFRLFlBQVksRUFBRTtRQUNwQixLQUFLLFNBQVM7WUFDWixPQUFPLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1FBQ3pDLEtBQUssR0FBRztZQUNOLE9BQU8sSUFBSSxDQUFDLDBCQUEwQixFQUFFLENBQUM7UUFDM0M7WUFDRSxPQUFPLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLFlBQVksQ0FBQztLQUNoRjtBQUNILENBQUM7QUFFRCxTQUFTLFdBQVcsQ0FDbEIsSUFBbUIsRUFDbkIsZUFBdUI7SUFFdkIsT0FBTyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLEtBQUssZUFBZSxDQUFDO0FBQ3pGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgdCBmcm9tICdAYmFiZWwvdHlwZXMnO1xuXG50eXBlIEJhYmVsVHlwZXMgPSB0eXBlb2YgdDtcblxuZXhwb3J0IGNsYXNzIEltcG9ydFV0aWwge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHQ6IEJhYmVsVHlwZXMsIHByaXZhdGUgcHJvZ3JhbTogTm9kZVBhdGg8dC5Qcm9ncmFtPikge31cblxuICAvLyByZW1vdmUgb25lIGltcG9ydGVkIGJpbmRpbmcuIElmIHRoaXMgaXMgdGhlIGxhc3QgdGhpbmcgaW1wb3J0ZWQgZnJvbSB0aGVcbiAgLy8gZ2l2ZW4gbW9kdWxlU3BlY2lmaWVyLCB0aGUgd2hvbGUgc3RhdGVtZW50IHdpbGwgYWxzbyBiZSByZW1vdmVkLlxuICByZW1vdmVJbXBvcnQobW9kdWxlU3BlY2lmaWVyOiBzdHJpbmcsIGV4cG9ydGVkTmFtZTogc3RyaW5nKTogdm9pZCB7XG4gICAgZm9yIChsZXQgdG9wTGV2ZWxQYXRoIG9mIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgaWYgKCFtYXRjaE1vZHVsZSh0b3BMZXZlbFBhdGgsIG1vZHVsZVNwZWNpZmllcikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBpbXBvcnRTcGVjaWZpZXJQYXRoID0gdG9wTGV2ZWxQYXRoXG4gICAgICAgIC5nZXQoJ3NwZWNpZmllcnMnKVxuICAgICAgICAuZmluZCgoc3BlY2lmaWVyUGF0aCkgPT4gbWF0Y2hTcGVjaWZpZXIoc3BlY2lmaWVyUGF0aCwgZXhwb3J0ZWROYW1lKSk7XG4gICAgICBpZiAoaW1wb3J0U3BlY2lmaWVyUGF0aCkge1xuICAgICAgICBpZiAodG9wTGV2ZWxQYXRoLm5vZGUuc3BlY2lmaWVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0b3BMZXZlbFBhdGgucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1wb3J0U3BlY2lmaWVyUGF0aC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHJlbW92ZSBhbGwgaW1wb3J0cyBmcm9tIHRoZSBnaXZlbiBtb2R1bGVTcGVjaWZpZXJcbiAgcmVtb3ZlQWxsSW1wb3J0cyhtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IHZvaWQge1xuICAgIGZvciAobGV0IHRvcExldmVsUGF0aCBvZiB0aGlzLnByb2dyYW0uZ2V0KCdib2R5JykpIHtcbiAgICAgIGlmIChtYXRjaE1vZHVsZSh0b3BMZXZlbFBhdGgsIG1vZHVsZVNwZWNpZmllcikpIHtcbiAgICAgICAgdG9wTGV2ZWxQYXRoLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEltcG9ydCB0aGUgZ2l2ZW4gdmFsdWUgKGlmIG5lZWRlZCkgYW5kIHJldHVybiBhbiBJZGVudGlmaWVyIHJlcHJlc2VudGluZ1xuICAvLyBpdC5cbiAgaW1wb3J0KFxuICAgIC8vIHRoZSBzcG90IGF0IHdoaWNoIHlvdSB3aWxsIGluc2VydCB0aGUgSWRlbnRpZmllciB3ZSByZXR1cm4gdG8geW91XG4gICAgdGFyZ2V0OiBOb2RlUGF0aDx0Lk5vZGU+LFxuXG4gICAgLy8gdGhlIHBhdGggdG8gdGhlIG1vZHVsZSB5b3UncmUgaW1wb3J0aW5nIGZyb21cbiAgICBtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyxcblxuICAgIC8vIHRoZSBuYW1lIHlvdSdyZSBpbXBvcnRpbmcgZnJvbSB0aGF0IG1vZHVsZS4gVXNlIFwiZGVmYXVsdFwiIGZvciB0aGUgZGVmYXVsdFxuICAgIC8vIGV4cG9ydC4gVXNlIFwiKlwiIGZvciB0aGUgbmFtZXNwYWNlLlxuICAgIGV4cG9ydGVkTmFtZTogc3RyaW5nLFxuXG4gICAgLy8gT3B0aW9uYWwgaGludCBmb3IgaGVscGluZyB1cyBwaWNrIGEgbmFtZSBmb3IgdGhlIGltcG9ydGVkIGJpbmRpbmdcbiAgICBuYW1lSGludD86IHN0cmluZ1xuICApOiB0LklkZW50aWZpZXIge1xuICAgIGxldCBkZWNsYXJhdGlvbiA9IHRoaXMuZmluZEltcG9ydEZyb20obW9kdWxlU3BlY2lmaWVyKTtcbiAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgIGxldCBzcGVjaWZpZXIgPSBkZWNsYXJhdGlvblxuICAgICAgICAuZ2V0KCdzcGVjaWZpZXJzJylcbiAgICAgICAgLmZpbmQoKHNwZWMpID0+IG1hdGNoU3BlY2lmaWVyKHNwZWMsIGV4cG9ydGVkTmFtZSkpO1xuICAgICAgaWYgKHNwZWNpZmllciAmJiB0YXJnZXQuc2NvcGUuZ2V0QmluZGluZyhzcGVjaWZpZXIubm9kZS5sb2NhbC5uYW1lKT8ua2luZCA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pZGVudGlmaWVyKHNwZWNpZmllci5ub2RlLmxvY2FsLm5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU3BlY2lmaWVyKHRhcmdldCwgZGVjbGFyYXRpb24sIGV4cG9ydGVkTmFtZSwgbmFtZUhpbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmluc2VydEFmdGVyRXhpc3RpbmdJbXBvcnRzKFxuICAgICAgICB0aGlzLnQuaW1wb3J0RGVjbGFyYXRpb24oW10sIHRoaXMudC5zdHJpbmdMaXRlcmFsKG1vZHVsZVNwZWNpZmllcikpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuYWRkU3BlY2lmaWVyKHRhcmdldCwgZGVjbGFyYXRpb24sIGV4cG9ydGVkTmFtZSwgbmFtZUhpbnQpO1xuICAgIH1cbiAgfVxuXG4gIGltcG9ydEZvclNpZGVFZmZlY3QobW9kdWxlU3BlY2lmaWVyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgZGVjbGFyYXRpb24gPSB0aGlzLmZpbmRJbXBvcnRGcm9tKG1vZHVsZVNwZWNpZmllcik7XG4gICAgaWYgKCFkZWNsYXJhdGlvbikge1xuICAgICAgdGhpcy5pbnNlcnRBZnRlckV4aXN0aW5nSW1wb3J0cyhcbiAgICAgICAgdGhpcy50LmltcG9ydERlY2xhcmF0aW9uKFtdLCB0aGlzLnQuc3RyaW5nTGl0ZXJhbChtb2R1bGVTcGVjaWZpZXIpKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZFNwZWNpZmllcihcbiAgICB0YXJnZXQ6IE5vZGVQYXRoPHQuTm9kZT4sXG4gICAgZGVjbGFyYXRpb246IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+LFxuICAgIGV4cG9ydGVkTmFtZTogc3RyaW5nLFxuICAgIG5hbWVIaW50OiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogdC5JZGVudGlmaWVyIHtcbiAgICBsZXQgbG9jYWwgPSB0aGlzLnQuaWRlbnRpZmllcihcbiAgICAgIHVudXNlZE5hbWVMaWtlKHRhcmdldCwgZGVzaXJlZE5hbWUobmFtZUhpbnQsIGV4cG9ydGVkTmFtZSwgdGFyZ2V0KSlcbiAgICApO1xuICAgIGxldCBzcGVjaWZpZXIgPSB0aGlzLmJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZSwgbG9jYWwpO1xuICAgIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gJ0ltcG9ydERlZmF1bHRTcGVjaWZpZXInKSB7XG4gICAgICBkZWNsYXJhdGlvbi5ub2RlLnNwZWNpZmllcnMudW5zaGlmdChzcGVjaWZpZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWNsYXJhdGlvbi5ub2RlLnNwZWNpZmllcnMucHVzaChzcGVjaWZpZXIpO1xuICAgIH1cbiAgICBkZWNsYXJhdGlvbi5zY29wZS5yZWdpc3RlckJpbmRpbmcoXG4gICAgICAnbW9kdWxlJyxcbiAgICAgIGRlY2xhcmF0aW9uLmdldChgc3BlY2lmaWVycy4ke2RlY2xhcmF0aW9uLm5vZGUuc3BlY2lmaWVycy5sZW5ndGggLSAxfWApIGFzIE5vZGVQYXRoXG4gICAgKTtcbiAgICByZXR1cm4gbG9jYWw7XG4gIH1cblxuICBwcml2YXRlIGJ1aWxkU3BlY2lmaWVyKGV4cG9ydGVkTmFtZTogc3RyaW5nLCBsb2NhbE5hbWU6IHQuSWRlbnRpZmllcikge1xuICAgIHN3aXRjaCAoZXhwb3J0ZWROYW1lKSB7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsTmFtZSk7XG4gICAgICBjYXNlICcqJzpcbiAgICAgICAgcmV0dXJuIHRoaXMudC5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobG9jYWxOYW1lKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnQuaW1wb3J0U3BlY2lmaWVyKGxvY2FsTmFtZSwgdGhpcy50LmlkZW50aWZpZXIoZXhwb3J0ZWROYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmaW5kSW1wb3J0RnJvbShtb2R1bGVTcGVjaWZpZXI6IHN0cmluZyk6IE5vZGVQYXRoPHQuSW1wb3J0RGVjbGFyYXRpb24+IHwgdW5kZWZpbmVkIHtcbiAgICBmb3IgKGxldCBwYXRoIG9mIHRoaXMucHJvZ3JhbS5nZXQoJ2JvZHknKSkge1xuICAgICAgaWYgKHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpICYmIHBhdGgubm9kZS5zb3VyY2UudmFsdWUgPT09IG1vZHVsZVNwZWNpZmllcikge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByaXZhdGUgaW5zZXJ0QWZ0ZXJFeGlzdGluZ0ltcG9ydHM8UyBleHRlbmRzIHQuU3RhdGVtZW50PihzdGF0ZW1lbnQ6IFMpOiBOb2RlUGF0aDxTPiB7XG4gICAgbGV0IGxhc3RJbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGZvciAobGV0IFtpbmRleCwgbm9kZV0gb2YgdGhpcy5wcm9ncmFtLm5vZGUuYm9keS5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJbXBvcnREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgbGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0SW5kZXggPT0gbnVsbCkge1xuICAgICAgLy8gd2UgYXJlIGludGVudGlvbmFsbHkgbm90IHVzaW5nIGJhYmVsJ3MgY29udGFpbmVyLWF3YXJlIG1ldGhvZHMsIGJlY2F1c2VcbiAgICAgIC8vIHdoaWxlIGluIHRoZW9yeSBpdCdzIG5pY2UgdGhhdCB0aGV5IHNjaGVkdWxlIG90aGVyIHBsdWdpbnMgdG8gcnVuIG9uXG4gICAgICAvLyBvdXIgbm9kZXMsIGluIHByYWN0aWNlIHRob3NlIG5vZGVzIG1pZ2h0IGdldCBtdXRhdGVkIG9yIHJlbW92ZWQgYnkgc29tZVxuICAgICAgLy8gb3RoZXIgcGx1Z2luIGluIHRoZSBpbnRlcnZlbmluZyB0aW1lIGNhdXNpbmcgZmFpbHVyZXMuXG4gICAgICB0aGlzLnByb2dyYW0ubm9kZS5ib2R5LnVuc2hpZnQoc3RhdGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW0uZ2V0KCdib2R5LjAnKSBhcyBOb2RlUGF0aDxTPjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm9ncmFtLm5vZGUuYm9keS5zcGxpY2UobGFzdEluZGV4ICsgMSwgMCwgc3RhdGVtZW50KTtcbiAgICAgIHJldHVybiB0aGlzLnByb2dyYW0uZ2V0KGBib2R5LiR7bGFzdEluZGV4ICsgMX1gKSBhcyBOb2RlUGF0aDxTPjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW51c2VkTmFtZUxpa2UocGF0aDogTm9kZVBhdGg8dC5Ob2RlPiwgbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IGNhbmRpZGF0ZSA9IG5hbWU7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgd2hpbGUgKHBhdGguc2NvcGUuaGFzQmluZGluZyhjYW5kaWRhdGUpKSB7XG4gICAgY2FuZGlkYXRlID0gYCR7bmFtZX0ke2NvdW50ZXIrK31gO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGU7XG59XG5cbmZ1bmN0aW9uIG5hbWUobm9kZTogdC5TdHJpbmdMaXRlcmFsIHwgdC5JZGVudGlmaWVyKTogc3RyaW5nIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNpcmVkTmFtZShuYW1lSGludDogc3RyaW5nIHwgdW5kZWZpbmVkLCBleHBvcnRlZE5hbWU6IHN0cmluZywgdGFyZ2V0OiBOb2RlUGF0aDx0Lk5vZGU+KSB7XG4gIGlmIChuYW1lSGludCkge1xuICAgIC8vIGZpcnN0IHdlIG9wcG9ydHVuaXN0aWNhbGx5IGRvIGNhbWVsaXphdGlvbiB3aGVuIGFuIGlsbGVnYWwgY2hhcmFjdGVyIGlzXG4gICAgLy8gZm9sbG93ZWQgYnkgYSBsb3dlcmNhc2UgbGV0dGVyLCBpbiBhbiBlZmZvcnQgdG8gYWlkIHJlYWRhYmlsaXR5IG9mIHRoZVxuICAgIC8vIG91dHB1dC5cbiAgICBsZXQgY2xlYW5lZCA9IG5hbWVIaW50LnJlcGxhY2UoL1teYS16QS1aX10oW2Etel0pL2csIChfbSwgbGV0dGVyKSA9PiBsZXR0ZXIudG9VcHBlckNhc2UoKSk7XG4gICAgLy8gdGhlbiB3ZSB1bmxpdGVyYWxseSBzdHJpcCBhbGwgcmVtYWluaW5nIGlsbGVnYWwgY2hhcmFjdGVycy5cbiAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKC9bXmEtekEtWl9dL2csICcnKTtcbiAgICByZXR1cm4gY2xlYW5lZDtcbiAgfVxuICBpZiAoZXhwb3J0ZWROYW1lID09PSAnZGVmYXVsdCcgfHwgZXhwb3J0ZWROYW1lID09PSAnKicpIHtcbiAgICBpZiAodGFyZ2V0LmlzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Lm5vZGUubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRhcmdldC5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZSh0YXJnZXQubm9kZSkubmFtZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGV4cG9ydGVkTmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFNwZWNpZmllcihzcGVjOiBOb2RlUGF0aDxhbnk+LCBleHBvcnRlZE5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBzd2l0Y2ggKGV4cG9ydGVkTmFtZSkge1xuICAgIGNhc2UgJ2RlZmF1bHQnOlxuICAgICAgcmV0dXJuIHNwZWMuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gICAgY2FzZSAnKic6XG4gICAgICByZXR1cm4gc3BlYy5pc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3BlYy5pc0ltcG9ydFNwZWNpZmllcigpICYmIG5hbWUoc3BlYy5ub2RlLmltcG9ydGVkKSA9PT0gZXhwb3J0ZWROYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoTW9kdWxlKFxuICBwYXRoOiBOb2RlUGF0aDxhbnk+LFxuICBtb2R1bGVTcGVjaWZpZXI6IHN0cmluZ1xuKTogcGF0aCBpcyBOb2RlUGF0aDx0LkltcG9ydERlY2xhcmF0aW9uPiB7XG4gIHJldHVybiBwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSAmJiBwYXRoLmdldCgnc291cmNlJykubm9kZS52YWx1ZSA9PT0gbW9kdWxlU3BlY2lmaWVyO1xufVxuIl19