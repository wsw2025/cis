{"version":3,"file":"index.js","sources":["../../lib/generation/util.ts","../../lib/generation/printer.ts","../../lib/generation/print.ts","../../lib/keywords.ts","../../lib/source/location.ts","../../lib/source/loc/kinds.ts","../../lib/source/loc/match.ts","../../../local-debug-flags/index.ts","../../lib/source/slice.ts","../../lib/source/loc/span.ts","../../lib/source/loc/offset.ts","../../lib/source/source.ts","../../lib/source/span-list.ts","../../lib/syntax-error.ts","../../lib/v1/visitor-keys.ts","../../lib/traversal/errors.ts","../../lib/traversal/path.ts","../../lib/traversal/traverse.ts","../../lib/traversal/walker.ts","../../lib/utils.ts","../../lib/v1/public-builders.ts","../../lib/v1/legacy-interop.ts","../../lib/v1/parser-builders.ts","../../lib/parser.ts","../../lib/parser/handlebars-node-visitors.ts","../../lib/parser/tokenizer-event-handlers.ts","../../lib/get-template-locals.ts","../../lib/v2/objects/node.ts","../../lib/v2/objects/args.ts","../../lib/v2/objects/attr-block.ts","../../lib/v2/objects/content.ts","../../lib/v2/objects/expr.ts","../../lib/v2/objects/internal-node.ts","../../lib/v2/objects/refs.ts","../../lib/v2/objects/resolution.ts","../../lib/symbol-table.ts","../../lib/v2/builders.ts","../../lib/v2/loose-resolution.ts","../../lib/v2/normalize.ts"],"sourcesContent":["import type * as ASTv1 from '../v1/api';\n\nconst enum Char {\n  NBSP = 0xa0,\n  QUOT = 0x22,\n  LT = 0x3c,\n  GT = 0x3e,\n  AMP = 0x26,\n}\n\nconst ATTR_VALUE_REGEX_TEST = /[\"&\\xA0]/u;\nconst ATTR_VALUE_REGEX_REPLACE = new RegExp(ATTR_VALUE_REGEX_TEST.source, 'gu');\n\nconst TEXT_REGEX_TEST = /[&<>\\xA0]/u;\nconst TEXT_REGEX_REPLACE = new RegExp(TEXT_REGEX_TEST.source, 'gu');\n\nfunction attrValueReplacer(char: string): string {\n  switch (char.charCodeAt(0)) {\n    case Char.NBSP:\n      return '&nbsp;';\n    case Char.QUOT:\n      return '&quot;';\n    case Char.AMP:\n      return '&amp;';\n    default:\n      return char;\n  }\n}\n\nfunction textReplacer(char: string): string {\n  switch (char.charCodeAt(0)) {\n    case Char.NBSP:\n      return '&nbsp;';\n    case Char.AMP:\n      return '&amp;';\n    case Char.LT:\n      return '&lt;';\n    case Char.GT:\n      return '&gt;';\n    default:\n      return char;\n  }\n}\n\nexport function escapeAttrValue(attrValue: string): string {\n  if (ATTR_VALUE_REGEX_TEST.test(attrValue)) {\n    return attrValue.replace(ATTR_VALUE_REGEX_REPLACE, attrValueReplacer);\n  }\n  return attrValue;\n}\n\nexport function escapeText(text: string): string {\n  if (TEXT_REGEX_TEST.test(text)) {\n    return text.replace(TEXT_REGEX_REPLACE, textReplacer);\n  }\n  return text;\n}\n\nexport function sortByLoc(a: ASTv1.Node, b: ASTv1.Node): -1 | 0 | 1 {\n  // If either is invisible, don't try to order them\n  if (a.loc.isInvisible || b.loc.isInvisible) {\n    return 0;\n  }\n\n  if (a.loc.startPosition.line < b.loc.startPosition.line) {\n    return -1;\n  }\n\n  if (\n    a.loc.startPosition.line === b.loc.startPosition.line &&\n    a.loc.startPosition.column < b.loc.startPosition.column\n  ) {\n    return -1;\n  }\n\n  if (\n    a.loc.startPosition.line === b.loc.startPosition.line &&\n    a.loc.startPosition.column === b.loc.startPosition.column\n  ) {\n    return 0;\n  }\n\n  return 1;\n}\n","import type * as ASTv1 from '../v1/api';\n\nimport { escapeAttrValue, escapeText, sortByLoc } from './util';\n\nexport const voidMap = new Set([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr',\n]);\n\nexport function getVoidTags() {\n  return [...voidMap];\n}\n\nconst NON_WHITESPACE = /^\\S/u;\n\nexport interface PrinterOptions {\n  entityEncoding: 'transformed' | 'raw';\n\n  /**\n   * Used to override the mechanism of printing a given AST.Node.\n   *\n   * This will generally only be useful to source -> source codemods\n   * where you would like to specialize/override the way a given node is\n   * printed (e.g. you would like to preserve as much of the original\n   * formatting as possible).\n   *\n   * When the provided override returns undefined, the default built in printing\n   * will be done for the AST.Node.\n   *\n   * @param ast the ast node to be printed\n   * @param options the options specified during the print() invocation\n   */\n  override?(ast: ASTv1.Node, options: PrinterOptions): void | string;\n}\n\n/**\n * Examples when true:\n *  - link\n *  - liNK\n *\n * Examples when false:\n *  - Link (component)\n */\nexport function isVoidTag(tag: string): boolean {\n  return voidMap.has(tag.toLowerCase()) && tag[0]?.toLowerCase() === tag[0];\n}\n\nexport default class Printer {\n  private buffer = '';\n  private options: PrinterOptions;\n\n  constructor(options: PrinterOptions) {\n    this.options = options;\n  }\n\n  /*\n    This is used by _all_ methods on this Printer class that add to `this.buffer`,\n    it allows consumers of the printer to use alternate string representations for\n    a given node.\n\n    The primary use case for this are things like source -> source codemod utilities.\n    For example, ember-template-recast attempts to always preserve the original string\n    formatting in each AST node if no modifications are made to it.\n  */\n  handledByOverride(node: ASTv1.Node, ensureLeadingWhitespace = false): boolean {\n    if (this.options.override !== undefined) {\n      let result = this.options.override(node, this.options);\n      if (typeof result === 'string') {\n        if (ensureLeadingWhitespace && NON_WHITESPACE.test(result)) {\n          result = ` ${result}`;\n        }\n\n        this.buffer += result;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  Node(node: ASTv1.Node): void {\n    switch (node.type) {\n      case 'MustacheStatement':\n      case 'BlockStatement':\n      case 'PartialStatement':\n      case 'MustacheCommentStatement':\n      case 'CommentStatement':\n      case 'TextNode':\n      case 'ElementNode':\n      case 'AttrNode':\n      case 'Block':\n      case 'Template':\n        return this.TopLevelStatement(node);\n      case 'StringLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'UndefinedLiteral':\n      case 'NullLiteral':\n      case 'PathExpression':\n      case 'SubExpression':\n        return this.Expression(node);\n      case 'Program':\n        return this.Block(node);\n      case 'ConcatStatement':\n        // should have an AttrNode parent\n        return this.ConcatStatement(node);\n      case 'Hash':\n        return this.Hash(node);\n      case 'HashPair':\n        return this.HashPair(node);\n      case 'ElementModifierStatement':\n        return this.ElementModifierStatement(node);\n    }\n  }\n\n  Expression(expression: ASTv1.Expression): void {\n    switch (expression.type) {\n      case 'StringLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'UndefinedLiteral':\n      case 'NullLiteral':\n        return this.Literal(expression);\n      case 'PathExpression':\n        return this.PathExpression(expression);\n      case 'SubExpression':\n        return this.SubExpression(expression);\n    }\n  }\n\n  Literal(literal: ASTv1.Literal): void {\n    switch (literal.type) {\n      case 'StringLiteral':\n        return this.StringLiteral(literal);\n      case 'BooleanLiteral':\n        return this.BooleanLiteral(literal);\n      case 'NumberLiteral':\n        return this.NumberLiteral(literal);\n      case 'UndefinedLiteral':\n        return this.UndefinedLiteral(literal);\n      case 'NullLiteral':\n        return this.NullLiteral(literal);\n    }\n  }\n\n  TopLevelStatement(statement: ASTv1.TopLevelStatement | ASTv1.Template | ASTv1.AttrNode): void {\n    switch (statement.type) {\n      case 'MustacheStatement':\n        return this.MustacheStatement(statement);\n      case 'BlockStatement':\n        return this.BlockStatement(statement);\n      case 'PartialStatement':\n        return this.PartialStatement(statement);\n      case 'MustacheCommentStatement':\n        return this.MustacheCommentStatement(statement);\n      case 'CommentStatement':\n        return this.CommentStatement(statement);\n      case 'TextNode':\n        return this.TextNode(statement);\n      case 'ElementNode':\n        return this.ElementNode(statement);\n      case 'Block':\n      case 'Template':\n        return this.Block(statement);\n      case 'AttrNode':\n        // should have element\n        return this.AttrNode(statement);\n    }\n  }\n\n  Block(block: ASTv1.Block | ASTv1.Program | ASTv1.Template): void {\n    /*\n      When processing a template like:\n\n      ```hbs\n      {{#if whatever}}\n        whatever\n      {{else if somethingElse}}\n        something else\n      {{else}}\n        fallback\n      {{/if}}\n      ```\n\n      The AST still _effectively_ looks like:\n\n      ```hbs\n      {{#if whatever}}\n        whatever\n      {{else}}{{#if somethingElse}}\n        something else\n      {{else}}\n        fallback\n      {{/if}}{{/if}}\n      ```\n\n      The only way we can tell if that is the case is by checking for\n      `block.chained`, but unfortunately when the actual statements are\n      processed the `block.body[0]` node (which will always be a\n      `BlockStatement`) has no clue that its ancestor `Block` node was\n      chained.\n\n      This \"forwards\" the `chained` setting so that we can check\n      it later when processing the `BlockStatement`.\n    */\n    if (block.chained) {\n      let firstChild = block.body[0] as ASTv1.BlockStatement;\n      firstChild.chained = true;\n    }\n\n    if (this.handledByOverride(block)) {\n      return;\n    }\n\n    this.TopLevelStatements(block.body);\n  }\n\n  TopLevelStatements(statements: ASTv1.TopLevelStatement[]): void {\n    statements.forEach((statement) => this.TopLevelStatement(statement));\n  }\n\n  ElementNode(el: ASTv1.ElementNode): void {\n    if (this.handledByOverride(el)) {\n      return;\n    }\n\n    this.OpenElementNode(el);\n    this.TopLevelStatements(el.children);\n    this.CloseElementNode(el);\n  }\n\n  OpenElementNode(el: ASTv1.ElementNode): void {\n    this.buffer += `<${el.tag}`;\n    const parts = [...el.attributes, ...el.modifiers, ...el.comments].sort(sortByLoc);\n\n    for (const part of parts) {\n      this.buffer += ' ';\n      switch (part.type) {\n        case 'AttrNode':\n          this.AttrNode(part);\n          break;\n        case 'ElementModifierStatement':\n          this.ElementModifierStatement(part);\n          break;\n        case 'MustacheCommentStatement':\n          this.MustacheCommentStatement(part);\n          break;\n      }\n    }\n    if (el.blockParams.length) {\n      this.BlockParams(el.blockParams);\n    }\n    if (el.selfClosing) {\n      this.buffer += ' /';\n    }\n    this.buffer += '>';\n  }\n\n  CloseElementNode(el: ASTv1.ElementNode): void {\n    if (el.selfClosing || isVoidTag(el.tag)) {\n      return;\n    }\n    this.buffer += `</${el.tag}>`;\n  }\n\n  AttrNode(attr: ASTv1.AttrNode): void {\n    if (this.handledByOverride(attr)) {\n      return;\n    }\n\n    let { name, value } = attr;\n\n    this.buffer += name;\n    if (value.type !== 'TextNode' || value.chars.length > 0) {\n      this.buffer += '=';\n      this.AttrNodeValue(value);\n    }\n  }\n\n  AttrNodeValue(value: ASTv1.AttrNode['value']): void {\n    if (value.type === 'TextNode') {\n      this.buffer += '\"';\n      this.TextNode(value, true);\n      this.buffer += '\"';\n    } else {\n      this.Node(value);\n    }\n  }\n\n  TextNode(text: ASTv1.TextNode, isAttr?: boolean): void {\n    if (this.handledByOverride(text)) {\n      return;\n    }\n\n    if (this.options.entityEncoding === 'raw') {\n      this.buffer += text.chars;\n    } else if (isAttr) {\n      this.buffer += escapeAttrValue(text.chars);\n    } else {\n      this.buffer += escapeText(text.chars);\n    }\n  }\n\n  MustacheStatement(mustache: ASTv1.MustacheStatement): void {\n    if (this.handledByOverride(mustache)) {\n      return;\n    }\n\n    this.buffer += mustache.escaped ? '{{' : '{{{';\n\n    if (mustache.strip.open) {\n      this.buffer += '~';\n    }\n\n    this.Expression(mustache.path);\n    this.Params(mustache.params);\n    this.Hash(mustache.hash);\n\n    if (mustache.strip.close) {\n      this.buffer += '~';\n    }\n\n    this.buffer += mustache.escaped ? '}}' : '}}}';\n  }\n\n  BlockStatement(block: ASTv1.BlockStatement): void {\n    if (this.handledByOverride(block)) {\n      return;\n    }\n\n    if (block.chained) {\n      this.buffer += block.inverseStrip.open ? '{{~' : '{{';\n      this.buffer += 'else ';\n    } else {\n      this.buffer += block.openStrip.open ? '{{~#' : '{{#';\n    }\n\n    this.Expression(block.path);\n    this.Params(block.params);\n    this.Hash(block.hash);\n    if (block.program.blockParams.length) {\n      this.BlockParams(block.program.blockParams);\n    }\n\n    if (block.chained) {\n      this.buffer += block.inverseStrip.close ? '~}}' : '}}';\n    } else {\n      this.buffer += block.openStrip.close ? '~}}' : '}}';\n    }\n\n    this.Block(block.program);\n\n    if (block.inverse) {\n      if (!block.inverse.chained) {\n        this.buffer += block.inverseStrip.open ? '{{~' : '{{';\n        this.buffer += 'else';\n        this.buffer += block.inverseStrip.close ? '~}}' : '}}';\n      }\n\n      this.Block(block.inverse);\n    }\n\n    if (!block.chained) {\n      this.buffer += block.closeStrip.open ? '{{~/' : '{{/';\n      this.Expression(block.path);\n      this.buffer += block.closeStrip.close ? '~}}' : '}}';\n    }\n  }\n\n  BlockParams(blockParams: string[]): void {\n    this.buffer += ` as |${blockParams.join(' ')}|`;\n  }\n\n  PartialStatement(partial: ASTv1.PartialStatement): void {\n    if (this.handledByOverride(partial)) {\n      return;\n    }\n\n    this.buffer += '{{>';\n    this.Expression(partial.name);\n    this.Params(partial.params);\n    this.Hash(partial.hash);\n    this.buffer += '}}';\n  }\n\n  ConcatStatement(concat: ASTv1.ConcatStatement): void {\n    if (this.handledByOverride(concat)) {\n      return;\n    }\n\n    this.buffer += '\"';\n    concat.parts.forEach((part) => {\n      if (part.type === 'TextNode') {\n        this.TextNode(part, true);\n      } else {\n        this.Node(part);\n      }\n    });\n    this.buffer += '\"';\n  }\n\n  MustacheCommentStatement(comment: ASTv1.MustacheCommentStatement): void {\n    if (this.handledByOverride(comment)) {\n      return;\n    }\n\n    this.buffer += `{{!--${comment.value}--}}`;\n  }\n\n  ElementModifierStatement(mod: ASTv1.ElementModifierStatement): void {\n    if (this.handledByOverride(mod)) {\n      return;\n    }\n\n    this.buffer += '{{';\n    this.Expression(mod.path);\n    this.Params(mod.params);\n    this.Hash(mod.hash);\n    this.buffer += '}}';\n  }\n\n  CommentStatement(comment: ASTv1.CommentStatement): void {\n    if (this.handledByOverride(comment)) {\n      return;\n    }\n\n    this.buffer += `<!--${comment.value}-->`;\n  }\n\n  PathExpression(path: ASTv1.PathExpression): void {\n    if (this.handledByOverride(path)) {\n      return;\n    }\n\n    this.buffer += path.original;\n  }\n\n  SubExpression(sexp: ASTv1.SubExpression): void {\n    if (this.handledByOverride(sexp)) {\n      return;\n    }\n\n    this.buffer += '(';\n    this.Expression(sexp.path);\n    this.Params(sexp.params);\n    this.Hash(sexp.hash);\n    this.buffer += ')';\n  }\n\n  Params(params: ASTv1.Expression[]): void {\n    // TODO: implement a top level Params AST node (just like the Hash object)\n    // so that this can also be overridden\n    if (params.length) {\n      params.forEach((param) => {\n        this.buffer += ' ';\n        this.Expression(param);\n      });\n    }\n  }\n\n  Hash(hash: ASTv1.Hash): void {\n    if (this.handledByOverride(hash, true)) {\n      return;\n    }\n\n    hash.pairs.forEach((pair) => {\n      this.buffer += ' ';\n      this.HashPair(pair);\n    });\n  }\n\n  HashPair(pair: ASTv1.HashPair): void {\n    if (this.handledByOverride(pair)) {\n      return;\n    }\n\n    this.buffer += pair.key;\n    this.buffer += '=';\n    this.Node(pair.value);\n  }\n\n  StringLiteral(str: ASTv1.StringLiteral): void {\n    if (this.handledByOverride(str)) {\n      return;\n    }\n\n    this.buffer += JSON.stringify(str.value);\n  }\n\n  BooleanLiteral(bool: ASTv1.BooleanLiteral): void {\n    if (this.handledByOverride(bool)) {\n      return;\n    }\n\n    this.buffer += bool.value;\n  }\n\n  NumberLiteral(number: ASTv1.NumberLiteral): void {\n    if (this.handledByOverride(number)) {\n      return;\n    }\n\n    this.buffer += number.value;\n  }\n\n  UndefinedLiteral(node: ASTv1.UndefinedLiteral): void {\n    if (this.handledByOverride(node)) {\n      return;\n    }\n\n    this.buffer += 'undefined';\n  }\n\n  NullLiteral(node: ASTv1.NullLiteral): void {\n    if (this.handledByOverride(node)) {\n      return;\n    }\n\n    this.buffer += 'null';\n  }\n\n  print(node: ASTv1.Node): string {\n    let { options } = this;\n\n    if (options.override) {\n      let result = options.override(node, options);\n\n      if (result !== undefined) {\n        return result;\n      }\n    }\n\n    this.buffer = '';\n    this.Node(node);\n    return this.buffer;\n  }\n}\n","import type * as ASTv1 from '../v1/api';\nimport type { PrinterOptions } from './printer';\n\nimport Printer from './printer';\n\nexport default function build(\n  ast: ASTv1.Node,\n  options: PrinterOptions = { entityEncoding: 'transformed' }\n): string {\n  if (!ast) {\n    return '';\n  }\n\n  let printer = new Printer(options);\n  return printer.print(ast);\n}\n","export type KeywordType = 'Call' | 'Modifier' | 'Append' | 'Block';\n\nexport function isKeyword(word: string): boolean {\n  return word in KEYWORDS_TYPES;\n}\n\n/**\n * This includes the full list of keywords currently in use in the template\n * language, and where their valid usages are.\n */\nexport const KEYWORDS_TYPES = {\n  component: ['Call', 'Append', 'Block'],\n  debugger: ['Append'],\n  'each-in': ['Block'],\n  each: ['Block'],\n  'has-block-params': ['Call', 'Append'],\n  'has-block': ['Call', 'Append'],\n  helper: ['Call', 'Append'],\n  if: ['Call', 'Append', 'Block'],\n  'in-element': ['Block'],\n  let: ['Block'],\n  'link-to': ['Append', 'Block'],\n  log: ['Call', 'Append'],\n  modifier: ['Call'],\n  mount: ['Append'],\n  mut: ['Call', 'Append'],\n  outlet: ['Append'],\n  'query-params': ['Call'],\n  readonly: ['Call', 'Append'],\n  unbound: ['Call', 'Append'],\n  unless: ['Call', 'Append', 'Block'],\n  with: ['Block'],\n  yield: ['Append'],\n} satisfies Record<string, readonly KeywordType[]>;\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { isPresentArray } from '@glimmer/util';\n\nimport type { SourceSpan } from './span';\n\nexport interface SourceLocation {\n  start: SourcePosition;\n  end: SourcePosition;\n}\n\nexport interface SourcePosition {\n  /** >= 1 */\n  line: number;\n  /** >= 0 */\n  column: number;\n}\n\nexport const UNKNOWN_POSITION = Object.freeze({\n  line: 1,\n  column: 0,\n} as const);\n\nexport const SYNTHETIC_LOCATION = Object.freeze({\n  source: '(synthetic)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\n/** @deprecated */\nexport const SYNTHETIC = SYNTHETIC_LOCATION;\n\nexport const TEMPORARY_LOCATION = Object.freeze({\n  source: '(temporary)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport const NON_EXISTENT_LOCATION = Object.freeze({\n  source: '(nonexistent)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport const BROKEN_LOCATION = Object.freeze({\n  source: '(broken)',\n  start: UNKNOWN_POSITION,\n  end: UNKNOWN_POSITION,\n} as const);\n\nexport type LocatedWithSpan = { offsets: SourceSpan };\nexport type LocatedWithOptionalSpan = { offsets: SourceSpan | null };\n\nexport type LocatedWithPositions = { loc: SourceLocation };\nexport type LocatedWithOptionalPositions = { loc?: SourceLocation };\n\nexport function isLocatedWithPositionsArray(\n  location: LocatedWithOptionalPositions[]\n): location is PresentArray<LocatedWithPositions> {\n  return isPresentArray(location) && location.every(isLocatedWithPositions);\n}\n\nexport function isLocatedWithPositions(\n  location: LocatedWithOptionalPositions\n): location is LocatedWithPositions {\n  return location.loc !== undefined;\n}\n\nexport type HasSourceLocation =\n  | SourceLocation\n  | LocatedWithPositions\n  | PresentArray<LocatedWithPositions>;\n\nexport type MaybeHasSourceLocation =\n  | null\n  | LocatedWithOptionalPositions\n  | LocatedWithOptionalPositions[];\n","export enum OffsetKind {\n  /**\n   * We have already computed the character position of this offset or span.\n   */\n  CharPosition = 'CharPosition',\n\n  /**\n   * This offset or span was instantiated with a Handlebars SourcePosition or SourceLocation. Its\n   * character position will be computed on demand.\n   */\n  HbsPosition = 'HbsPosition',\n\n  /**\n   * for (rare) situations where a node is created but there was no source location (e.g. the name\n   * \"default\" in default blocks when the word \"default\" never appeared in source). This is used\n   * by the internals when there is a legitimate reason for the internals to synthesize a node\n   * with no location.\n   */\n  InternalsSynthetic = 'InternalsSynthetic',\n  /**\n   * For situations where a node represents zero parts of the source (for example, empty arguments).\n   * In general, we attempt to assign these nodes *some* position (empty arguments can be\n   * positioned immediately after the callee), but it's not always possible\n   */\n  NonExistent = 'NonExistent',\n  /**\n   * For situations where a source location was expected, but it didn't correspond to the node in\n   * the source. This happens if a plugin creates broken locations.\n   */\n  Broken = 'Broken',\n}\n","import { assert, isPresentArray } from '@glimmer/util';\n\nimport type { CharPosition, HbsPosition, InvisiblePosition, PositionData } from './offset';\n\nimport { OffsetKind } from './kinds';\n\n/**\n * This file implements the DSL used by span and offset in places where they need to exhaustively\n * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken\n * offsets).\n *\n * It's probably overkill, but it makes the code that uses it clear. It could be refactored or\n * removed.\n */\n\nexport const MatchAny = 'MATCH_ANY';\nexport type MatchAny = 'MATCH_ANY';\n\ntype Matches =\n  | 'Char,Hbs'\n  | 'Hbs,Char'\n  | 'Hbs,Hbs'\n  | 'Char,Char'\n  | 'Invisible,Any'\n  | 'Any,Invisible';\n\nexport const IsInvisible = 'IS_INVISIBLE';\nexport type IsInvisible = 'IS_INVISIBLE';\n\ntype Pattern = OffsetKind | IsInvisible | MatchAny;\n\nclass WhenList<Out> {\n  _whens: When<Out>[];\n\n  constructor(whens: When<Out>[]) {\n    this._whens = whens;\n  }\n\n  first(kind: OffsetKind): Out | null {\n    for (const when of this._whens) {\n      const value = when.match(kind);\n      if (isPresentArray(value)) {\n        return value[0];\n      }\n    }\n\n    return null;\n  }\n}\n\nclass When<Out> {\n  _map: Map<Pattern, Out> = new Map();\n\n  get(pattern: Pattern, or: () => Out): Out {\n    let value = this._map.get(pattern);\n\n    if (value) {\n      return value;\n    }\n\n    value = or();\n\n    this._map.set(pattern, value);\n\n    return value;\n  }\n\n  add(pattern: Pattern, out: Out): void {\n    this._map.set(pattern, out);\n  }\n\n  match(kind: OffsetKind): Out[] {\n    const pattern = patternFor(kind);\n\n    const out: Out[] = [];\n\n    const exact = this._map.get(pattern);\n    const fallback = this._map.get(MatchAny);\n\n    if (exact) {\n      out.push(exact);\n    }\n\n    if (fallback) {\n      out.push(fallback);\n    }\n\n    return out;\n  }\n}\n\ntype ExhaustiveCheck<Out, In extends Matches, Removed extends Matches> = Exclude<\n  In,\n  Removed\n> extends never\n  ? ExhaustiveMatcher<Out>\n  : Matcher<Out, Exclude<In, Removed>>;\n\nexport type MatchFn<Out> = (left: PositionData, right: PositionData) => Out;\n\ninterface ExhaustiveMatcher<Out> {\n  check(): MatchFn<Out>;\n}\n\nexport function match<Out>(callback: (m: Matcher<Out>) => ExhaustiveMatcher<Out>): MatchFn<Out> {\n  return callback(new Matcher()).check();\n}\n\nclass Matcher<Out, M extends Matches = Matches> {\n  _whens: When<When<(left: PositionData, right: PositionData) => Out>> = new When();\n\n  /**\n   * You didn't exhaustively match all possibilities.\n   */\n  protected check(): MatchFn<Out> {\n    return (left, right) => this.matchFor(left.kind, right.kind)(left, right);\n  }\n\n  private matchFor(\n    left: OffsetKind,\n    right: OffsetKind\n  ): (left: PositionData, right: PositionData) => Out {\n    const nesteds = this._whens.match(left);\n\n    assert(\n      isPresentArray(nesteds),\n      `no match defined for (${left}, ${right}) and no AnyMatch defined either`\n    );\n\n    const callback = new WhenList(nesteds).first(right);\n\n    assert(\n      callback !== null,\n      `no match defined for (${left}, ${right}) and no AnyMatch defined either`\n    );\n\n    return callback;\n  }\n\n  // This big block is the bulk of the heavy lifting in this file. It facilitates exhaustiveness\n  // checking so that matchers can ensure they've actually covered all the cases (and TypeScript\n  // will treat it as an exhaustive match).\n  when(\n    left: OffsetKind.CharPosition,\n    right: OffsetKind.HbsPosition,\n    callback: (left: CharPosition, right: HbsPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Char,Hbs'>;\n  when(\n    left: OffsetKind.HbsPosition,\n    right: OffsetKind.CharPosition,\n    callback: (left: HbsPosition, right: CharPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Hbs,Char'>;\n  when(\n    left: OffsetKind.HbsPosition,\n    right: OffsetKind.HbsPosition,\n    callback: (left: HbsPosition, right: HbsPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Hbs,Hbs'>;\n  when(\n    left: OffsetKind.CharPosition,\n    right: OffsetKind.CharPosition,\n    callback: (left: CharPosition, right: CharPosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Char,Char'>;\n  when(\n    left: IsInvisible,\n    right: MatchAny,\n    callback: (left: InvisiblePosition, right: PositionData) => Out\n  ): Matcher<Out, Exclude<M, 'Invisible,Any'>>;\n  when(\n    left: MatchAny,\n    right: IsInvisible,\n    callback: (left: PositionData, right: InvisiblePosition) => Out\n  ): ExhaustiveCheck<Out, M, 'Any,Invisible'>;\n  when(\n    left: MatchAny,\n    right: MatchAny,\n    callback: (left: PositionData, right: PositionData) => Out\n  ): ExhaustiveMatcher<Out>;\n  when(\n    left: Pattern,\n    right: Pattern,\n\n    callback: (left: any, right: any) => Out\n  ): Matcher<Out, Matches> | ExhaustiveMatcher<Out> {\n    this._whens.get(left, () => new When()).add(right, callback);\n\n    return this;\n  }\n}\n\nfunction patternFor(kind: OffsetKind): Pattern {\n  switch (kind) {\n    case OffsetKind.Broken:\n    case OffsetKind.InternalsSynthetic:\n    case OffsetKind.NonExistent:\n      return IsInvisible;\n    default:\n      return kind;\n  }\n}\n","export const LOCAL_DEBUG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]disable_local_debug/u.test(window.location.search)) {\n      return false;\n    }\n    return true;\n  })();\n\nexport const LOCAL_SHOULD_LOG: true | false =\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import.meta.env.VM_LOCAL_DEV &&\n  (() => {\n    let location = typeof window !== 'undefined' && window.location;\n    if (location && /[&?]enable_local_should_log/u.test(window.location.search)) {\n      return true;\n    }\n    return false;\n  })();\n","import * as src from './api';\n\nexport type SerializedSourceSlice<Chars extends string = string> = [\n  chars: Chars,\n  span: src.SerializedSourceSpan,\n];\n\nexport class SourceSlice<Chars extends string = string> {\n  static synthetic<S extends string>(chars: S): SourceSlice<S> {\n    let offsets = src.SourceSpan.synthetic(chars);\n    return new SourceSlice({ loc: offsets, chars: chars });\n  }\n\n  static load(source: src.Source, slice: SerializedSourceSlice): SourceSlice {\n    return new SourceSlice({\n      loc: src.SourceSpan.load(source, slice[1]),\n      chars: slice[0],\n    });\n  }\n\n  readonly chars: Chars;\n  readonly loc: src.SourceSpan;\n\n  constructor(options: { loc: src.SourceSpan; chars: Chars }) {\n    this.loc = options.loc;\n    this.chars = options.chars;\n  }\n\n  getString(): string {\n    return this.chars;\n  }\n\n  serialize(): SerializedSourceSlice<Chars> {\n    return [this.chars, this.loc.serialize()];\n  }\n}\n","import { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { assertNever } from '@glimmer/util';\n\nimport type { SourceLocation, SourcePosition } from '../location';\nimport type { Source } from '../source';\nimport type { MatchFn } from './match';\nimport type { AnyPosition, SourceOffset } from './offset';\n\nimport { BROKEN_LOCATION, NON_EXISTENT_LOCATION } from '../location';\nimport { SourceSlice } from '../slice';\nimport { OffsetKind } from './kinds';\nimport { IsInvisible, match, MatchAny } from './match';\nimport { BROKEN, CharPosition, HbsPosition, InvisiblePosition } from './offset';\n\n/**\n * All spans have these details in common.\n */\ninterface SpanData {\n  readonly kind: OffsetKind;\n\n  /**\n   * Convert this span into a string. If the span is broken, return `''`.\n   */\n  asString(): string;\n\n  /**\n   * Gets the module the span was located in.\n   */\n  getModule(): string;\n\n  /**\n   * Get the starting position for this span. Try to avoid creating new position objects, as they\n   * cache computations.\n   */\n  getStart(): AnyPosition;\n\n  /**\n   * Get the ending position for this span. Try to avoid creating new position objects, as they\n   * cache computations.\n   */\n  getEnd(): AnyPosition;\n\n  /**\n   * Compute the `SourceLocation` for this span, returned as an instance of `HbsSpan`.\n   */\n  toHbsSpan(): HbsSpan | null;\n\n  /**\n   * For compatibility, whenever the `start` or `end` of a {@see SourceOffset} changes, spans are\n   * notified of the change so they can update themselves. This shouldn't happen outside of AST\n   * plugins.\n   */\n  locDidUpdate(changes: { start?: SourcePosition; end?: SourcePosition }): void;\n\n  /**\n   * Serialize into a {@see SerializedSourceSpan}, which is compact and designed for readability in\n   * context like AST Explorer. If you need a {@see SourceLocation}, use {@see toJSON}.\n   */\n  serialize(): SerializedSourceSpan;\n}\n\n/**\n * A `SourceSpan` object represents a span of characters inside of a template source.\n *\n * There are three kinds of `SourceSpan` objects:\n *\n * - `ConcreteSourceSpan`, which contains byte offsets\n * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be\n *   converted to byte offsets on demand.\n * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,\n *   because:\n *     - they were created synthetically\n *     - their location is nonsensical (the span is broken)\n *     - they represent nothing in the source (this currently happens only when a bug in the\n *       upstream Handlebars parser fails to assign a location to empty blocks)\n *\n * At a high level, all `SourceSpan` objects provide:\n *\n * - byte offsets\n * - source in column and line format\n *\n * And you can do these operations on `SourceSpan`s:\n *\n * - collapse it to a `SourceSpan` representing its starting or ending position\n * - slice out some characters, optionally skipping some characters at the beginning or end\n * - create a new `SourceSpan` with a different starting or ending offset\n *\n * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan\n * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.\n *\n * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which\n * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.\n *\n * The goal is to avoid creating any problems for use-cases like AST Explorer.\n */\nexport class SourceSpan implements SourceLocation {\n  static get NON_EXISTENT(): SourceSpan {\n    return new InvisibleSpan(OffsetKind.NonExistent, NON_EXISTENT_LOCATION).wrap();\n  }\n\n  static load(source: Source, serialized: SerializedSourceSpan): SourceSpan {\n    if (typeof serialized === 'number') {\n      return SourceSpan.forCharPositions(source, serialized, serialized);\n    } else if (typeof serialized === 'string') {\n      return SourceSpan.synthetic(serialized);\n    } else if (Array.isArray(serialized)) {\n      return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);\n    } else if (serialized === OffsetKind.NonExistent) {\n      return SourceSpan.NON_EXISTENT;\n    } else if (serialized === OffsetKind.Broken) {\n      return SourceSpan.broken(BROKEN_LOCATION);\n    }\n\n    assertNever(serialized);\n  }\n\n  static forHbsLoc(source: Source, loc: SourceLocation): SourceSpan {\n    const start = new HbsPosition(source, loc.start);\n    const end = new HbsPosition(source, loc.end);\n    return new HbsSpan(source, { start, end }, loc).wrap();\n  }\n\n  static forCharPositions(source: Source, startPos: number, endPos: number): SourceSpan {\n    const start = new CharPosition(source, startPos);\n    const end = new CharPosition(source, endPos);\n\n    return new CharPositionSpan(source, { start, end }).wrap();\n  }\n\n  static synthetic(chars: string): SourceSpan {\n    return new InvisibleSpan(OffsetKind.InternalsSynthetic, NON_EXISTENT_LOCATION, chars).wrap();\n  }\n\n  static broken(pos: SourceLocation = BROKEN_LOCATION): SourceSpan {\n    return new InvisibleSpan(OffsetKind.Broken, pos).wrap();\n  }\n\n  readonly isInvisible: boolean;\n\n  constructor(private data: SpanData & AnySpan) {\n    this.isInvisible =\n      data.kind !== OffsetKind.CharPosition && data.kind !== OffsetKind.HbsPosition;\n  }\n\n  getStart(): SourceOffset {\n    return this.data.getStart().wrap();\n  }\n\n  getEnd(): SourceOffset {\n    return this.data.getEnd().wrap();\n  }\n\n  get loc(): SourceLocation {\n    const span = this.data.toHbsSpan();\n    return span === null ? BROKEN_LOCATION : span.toHbsLoc();\n  }\n\n  get module(): string {\n    return this.data.getModule();\n  }\n\n  /**\n   * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.\n   */\n  get startPosition(): SourcePosition {\n    return this.loc.start;\n  }\n\n  /**\n   * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.\n   */\n  get endPosition(): SourcePosition {\n    return this.loc.end;\n  }\n\n  /**\n   * Support converting ASTv1 nodes into a serialized format using JSON.stringify.\n   */\n  toJSON(): SourceLocation {\n    return this.loc;\n  }\n\n  /**\n   * Create a new span with the current span's end and a new beginning.\n   */\n  withStart(other: SourceOffset): SourceSpan {\n    return span(other.data, this.data.getEnd());\n  }\n\n  /**\n   * Create a new span with the current span's beginning and a new ending.\n   */\n  withEnd(this: SourceSpan, other: SourceOffset): SourceSpan {\n    return span(this.data.getStart(), other.data);\n  }\n\n  asString(): string {\n    return this.data.asString();\n  }\n\n  /**\n   * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks\n   * that the byte offsets represented by this `SourceSpan` actually correspond to the expected\n   * string.\n   */\n  toSlice(expected?: string): SourceSlice {\n    const chars = this.data.asString();\n\n    if (import.meta.env.DEV) {\n      if (expected !== undefined && chars !== expected) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `unexpectedly found ${JSON.stringify(\n            chars\n          )} when slicing source, but expected ${JSON.stringify(expected)}`\n        );\n      }\n    }\n\n    return new SourceSlice({\n      loc: this,\n      chars: expected || chars,\n    });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use startPosition instead\n   */\n  get start(): SourcePosition {\n    return this.loc.start;\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use withStart instead\n   */\n  set start(position: SourcePosition) {\n    this.data.locDidUpdate({ start: position });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use endPosition instead\n   */\n  get end(): SourcePosition {\n    return this.loc.end;\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use withEnd instead\n   */\n  set end(position: SourcePosition) {\n    this.data.locDidUpdate({ end: position });\n  }\n\n  /**\n   * For compatibility with SourceLocation in AST plugins\n   *\n   * @deprecated use module instead\n   */\n  get source(): string {\n    return this.module;\n  }\n\n  collapse(where: 'start' | 'end'): SourceSpan {\n    switch (where) {\n      case 'start':\n        return this.getStart().collapsed();\n      case 'end':\n        return this.getEnd().collapsed();\n    }\n  }\n\n  extend(other: SourceSpan): SourceSpan {\n    return span(this.data.getStart(), other.data.getEnd());\n  }\n\n  serialize(): SerializedSourceSpan {\n    return this.data.serialize();\n  }\n\n  slice({ skipStart = 0, skipEnd = 0 }: { skipStart?: number; skipEnd?: number }): SourceSpan {\n    return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);\n  }\n\n  sliceStartChars({ skipStart = 0, chars }: { skipStart?: number; chars: number }): SourceSpan {\n    return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);\n  }\n\n  sliceEndChars({ skipEnd = 0, chars }: { skipEnd?: number; chars: number }): SourceSpan {\n    return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);\n  }\n}\n\ntype AnySpan = HbsSpan | CharPositionSpan | InvisibleSpan;\n\nclass CharPositionSpan implements SpanData {\n  readonly kind = OffsetKind.CharPosition;\n\n  _locPosSpan: HbsSpan | BROKEN | null = null;\n\n  constructor(\n    readonly source: Source,\n    readonly charPositions: { start: CharPosition; end: CharPosition }\n  ) {}\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  asString(): string {\n    return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);\n  }\n\n  getModule(): string {\n    return this.source.module;\n  }\n\n  getStart(): AnyPosition {\n    return this.charPositions.start;\n  }\n\n  getEnd(): AnyPosition {\n    return this.charPositions.end;\n  }\n\n  locDidUpdate() {\n    if (LOCAL_DEBUG) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase`\n      );\n    }\n  }\n\n  toHbsSpan(): HbsSpan | null {\n    let locPosSpan = this._locPosSpan;\n\n    if (locPosSpan === null) {\n      const start = this.charPositions.start.toHbsPos();\n      const end = this.charPositions.end.toHbsPos();\n\n      if (start === null || end === null) {\n        locPosSpan = this._locPosSpan = BROKEN;\n      } else {\n        locPosSpan = this._locPosSpan = new HbsSpan(this.source, {\n          start,\n          end,\n        });\n      }\n    }\n\n    return locPosSpan === BROKEN ? null : locPosSpan;\n  }\n\n  serialize(): SerializedSourceSpan {\n    const {\n      start: { charPos: start },\n      end: { charPos: end },\n    } = this.charPositions;\n\n    if (start === end) {\n      return start;\n    } else {\n      return [start, end];\n    }\n  }\n\n  toCharPosSpan(): CharPositionSpan {\n    return this;\n  }\n}\n\nexport class HbsSpan implements SpanData {\n  readonly kind = OffsetKind.HbsPosition;\n\n  _charPosSpan: CharPositionSpan | BROKEN | null = null;\n\n  // the source location from Handlebars + AST Plugins -- could be wrong\n  _providedHbsLoc: SourceLocation | null;\n\n  constructor(\n    readonly source: Source,\n    readonly hbsPositions: { start: HbsPosition; end: HbsPosition },\n    providedHbsLoc: SourceLocation | null = null\n  ) {\n    this._providedHbsLoc = providedHbsLoc;\n  }\n\n  serialize(): SerializedConcreteSourceSpan {\n    const charPos = this.toCharPosSpan();\n    return charPos === null ? OffsetKind.Broken : charPos.wrap().serialize();\n  }\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  private updateProvided(pos: SourcePosition, edge: 'start' | 'end') {\n    if (this._providedHbsLoc) {\n      this._providedHbsLoc[edge] = pos;\n    }\n\n    // invalidate computed character offsets\n    this._charPosSpan = null;\n    this._providedHbsLoc = {\n      start: pos,\n      end: pos,\n    };\n  }\n\n  locDidUpdate({ start, end }: { start?: SourcePosition; end?: SourcePosition }): void {\n    if (start !== undefined) {\n      this.updateProvided(start, 'start');\n      this.hbsPositions.start = new HbsPosition(this.source, start, null);\n    }\n\n    if (end !== undefined) {\n      this.updateProvided(end, 'end');\n      this.hbsPositions.end = new HbsPosition(this.source, end, null);\n    }\n  }\n\n  asString(): string {\n    const span = this.toCharPosSpan();\n    return span === null ? '' : span.asString();\n  }\n\n  getModule(): string {\n    return this.source.module;\n  }\n\n  getStart(): AnyPosition {\n    return this.hbsPositions.start;\n  }\n\n  getEnd(): AnyPosition {\n    return this.hbsPositions.end;\n  }\n\n  toHbsLoc(): SourceLocation {\n    return {\n      start: this.hbsPositions.start.hbsPos,\n      end: this.hbsPositions.end.hbsPos,\n    };\n  }\n\n  toHbsSpan(): HbsSpan {\n    return this;\n  }\n\n  toCharPosSpan(): CharPositionSpan | null {\n    let charPosSpan = this._charPosSpan;\n\n    if (charPosSpan === null) {\n      const start = this.hbsPositions.start.toCharPos();\n      const end = this.hbsPositions.end.toCharPos();\n\n      if (start && end) {\n        charPosSpan = this._charPosSpan = new CharPositionSpan(this.source, {\n          start,\n          end,\n        });\n      } else {\n        charPosSpan = this._charPosSpan = BROKEN;\n        return null;\n      }\n    }\n\n    return charPosSpan === BROKEN ? null : charPosSpan;\n  }\n}\n\nclass InvisibleSpan implements SpanData {\n  constructor(\n    readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent,\n    // whatever was provided, possibly broken\n    readonly loc: SourceLocation,\n    // if the span represents a synthetic string\n    readonly string: string | null = null\n  ) {}\n\n  serialize(): SerializedConcreteSourceSpan {\n    switch (this.kind) {\n      case OffsetKind.Broken:\n      case OffsetKind.NonExistent:\n        return this.kind;\n      case OffsetKind.InternalsSynthetic:\n        return this.string || '';\n    }\n  }\n\n  wrap(): SourceSpan {\n    return new SourceSpan(this);\n  }\n\n  asString(): string {\n    return this.string || '';\n  }\n\n  locDidUpdate({ start, end }: { start?: SourcePosition; end?: SourcePosition }) {\n    if (start !== undefined) {\n      this.loc.start = start;\n    }\n\n    if (end !== undefined) {\n      this.loc.end = end;\n    }\n  }\n\n  getModule(): string {\n    // TODO: Make this reflect the actual module this span originated from\n    return 'an unknown module';\n  }\n\n  getStart(): AnyPosition {\n    return new InvisiblePosition(this.kind, this.loc.start);\n  }\n\n  getEnd(): AnyPosition {\n    return new InvisiblePosition(this.kind, this.loc.end);\n  }\n\n  toCharPosSpan(): InvisibleSpan {\n    return this;\n  }\n\n  toHbsSpan(): null {\n    return null;\n  }\n\n  toHbsLoc(): SourceLocation {\n    return BROKEN_LOCATION;\n  }\n}\n\nexport const span: MatchFn<SourceSpan> = match((m) =>\n  m\n    .when(OffsetKind.HbsPosition, OffsetKind.HbsPosition, (left, right) =>\n      new HbsSpan(left.source, {\n        start: left,\n        end: right,\n      }).wrap()\n    )\n    .when(OffsetKind.CharPosition, OffsetKind.CharPosition, (left, right) =>\n      new CharPositionSpan(left.source, {\n        start: left,\n        end: right,\n      }).wrap()\n    )\n    .when(OffsetKind.CharPosition, OffsetKind.HbsPosition, (left, right) => {\n      const rightCharPos = right.toCharPos();\n\n      if (rightCharPos === null) {\n        return new InvisibleSpan(OffsetKind.Broken, BROKEN_LOCATION).wrap();\n      } else {\n        return span(left, rightCharPos);\n      }\n    })\n    .when(OffsetKind.HbsPosition, OffsetKind.CharPosition, (left, right) => {\n      const leftCharPos = left.toCharPos();\n\n      if (leftCharPos === null) {\n        return new InvisibleSpan(OffsetKind.Broken, BROKEN_LOCATION).wrap();\n      } else {\n        return span(leftCharPos, right);\n      }\n    })\n    .when(IsInvisible, MatchAny, (left) => new InvisibleSpan(left.kind, BROKEN_LOCATION).wrap())\n    .when(MatchAny, IsInvisible, (_, right) =>\n      new InvisibleSpan(right.kind, BROKEN_LOCATION).wrap()\n    )\n);\n\nexport type SerializedConcreteSourceSpan =\n  | /** collapsed */ number\n  | /** normal */ [start: number, size: number]\n  | /** synthetic */ string;\n\nexport type SerializedSourceSpan =\n  | SerializedConcreteSourceSpan\n  | OffsetKind.NonExistent\n  | OffsetKind.Broken;\n","import type { SourcePosition } from '../location';\nimport type { Source } from '../source';\nimport type { SourceSpan } from './span';\n\nimport { UNKNOWN_POSITION } from '../location';\nimport { OffsetKind } from './kinds';\nimport { match, MatchAny } from './match';\nimport { span } from './span';\n\n/**\n * All positions have these details in common. Most notably, all three kinds of positions can\n * must be able to attempt to convert themselves into {@see CharPosition}.\n */\nexport interface PositionData {\n  readonly kind: OffsetKind;\n  toCharPos(): CharPosition | null;\n  toJSON(): SourcePosition;\n}\n\n/**\n * Used to indicate that an attempt to convert a `SourcePosition` to a character offset failed. It\n * is separate from `null` so that `null` can be used to indicate that the computation wasn't yet\n * attempted (and therefore to cache the failure)\n */\nexport const BROKEN = 'BROKEN';\nexport type BROKEN = 'BROKEN';\n\nexport type AnyPosition = HbsPosition | CharPosition | InvisiblePosition;\n\n/**\n * A `SourceOffset` represents a single position in the source.\n *\n * There are three kinds of backing data for `SourceOffset` objects:\n *\n * - `CharPosition`, which contains a character offset into the raw source string\n * - `HbsPosition`, which contains a `SourcePosition` from the Handlebars AST, which can be\n *   converted to a `CharPosition` on demand.\n * - `InvisiblePosition`, which represents a position not in source (@see {InvisiblePosition})\n */\nexport class SourceOffset {\n  /**\n   * Create a `SourceOffset` from a Handlebars `SourcePosition`. It's stored as-is, and converted\n   * into a character offset on demand, which avoids unnecessarily computing the offset of every\n   * `SourceLocation`, but also means that broken `SourcePosition`s are not always detected.\n   */\n  static forHbsPos(source: Source, pos: SourcePosition): SourceOffset {\n    return new HbsPosition(source, pos, null).wrap();\n  }\n\n  /**\n   * Create a `SourceOffset` that corresponds to a broken `SourcePosition`. This means that the\n   * calling code determined (or knows) that the `SourceLocation` doesn't correspond correctly to\n   * any part of the source.\n   */\n  static broken(pos: SourcePosition = UNKNOWN_POSITION): SourceOffset {\n    return new InvisiblePosition(OffsetKind.Broken, pos).wrap();\n  }\n\n  constructor(readonly data: PositionData & AnyPosition) {}\n\n  /**\n   * Get the character offset for this `SourceOffset`, if possible.\n   */\n  get offset(): number | null {\n    const charPos = this.data.toCharPos();\n    return charPos === null ? null : charPos.offset;\n  }\n\n  /**\n   * Compare this offset with another one.\n   *\n   * If both offsets are `HbsPosition`s, they're equivalent as long as their lines and columns are\n   * the same. This avoids computing offsets unnecessarily.\n   *\n   * Otherwise, two `SourceOffset`s are equivalent if their successfully computed character offsets\n   * are the same.\n   */\n  eql(right: SourceOffset): boolean {\n    return eql(this.data, right.data);\n  }\n\n  /**\n   * Create a span that starts from this source offset and ends with another source offset. Avoid\n   * computing character offsets if both `SourceOffset`s are still lazy.\n   */\n  until(other: SourceOffset): SourceSpan {\n    return span(this.data, other.data);\n  }\n\n  /**\n   * Create a `SourceOffset` by moving the character position represented by this source offset\n   * forward or backward (if `by` is negative), if possible.\n   *\n   * If this `SourceOffset` can't compute a valid character offset, `move` returns a broken offset.\n   *\n   * If the resulting character offset is less than 0 or greater than the size of the source, `move`\n   * returns a broken offset.\n   */\n  move(by: number): SourceOffset {\n    const charPos = this.data.toCharPos();\n\n    if (charPos === null) {\n      return SourceOffset.broken();\n    } else {\n      const result = charPos.offset + by;\n\n      if (charPos.source.check(result)) {\n        return new CharPosition(charPos.source, result).wrap();\n      } else {\n        return SourceOffset.broken();\n      }\n    }\n  }\n\n  /**\n   * Create a new `SourceSpan` that represents a collapsed range at this source offset. Avoid\n   * computing the character offset if it has not already been computed.\n   */\n  collapsed(): SourceSpan {\n    return span(this.data, this.data);\n  }\n\n  /**\n   * Convert this `SourceOffset` into a Handlebars {@see SourcePosition} for compatibility with\n   * existing plugins.\n   */\n  toJSON(): SourcePosition {\n    return this.data.toJSON();\n  }\n}\n\nexport class CharPosition implements PositionData {\n  readonly kind = OffsetKind.CharPosition;\n\n  /** Computed from char offset */\n  _locPos: HbsPosition | BROKEN | null = null;\n\n  constructor(\n    readonly source: Source,\n    readonly charPos: number\n  ) {}\n\n  /**\n   * This is already a `CharPosition`.\n   *\n   * {@see HbsPosition} for the alternative.\n   */\n  toCharPos(): CharPosition {\n    return this;\n  }\n\n  /**\n   * Produce a Handlebars {@see SourcePosition} for this `CharPosition`. If this `CharPosition` was\n   * computed using {@see SourceOffset#move}, this will compute the `SourcePosition` for the offset.\n   */\n  toJSON(): SourcePosition {\n    const hbs = this.toHbsPos();\n    return hbs === null ? UNKNOWN_POSITION : hbs.toJSON();\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  /**\n   * A `CharPosition` always has an offset it can produce without any additional computation.\n   */\n  get offset(): number {\n    return this.charPos;\n  }\n\n  /**\n   * Convert the current character offset to an `HbsPosition`, if it was not already computed. Once\n   * a `CharPosition` has computed its `HbsPosition`, it will not need to do compute it again, and\n   * the same `CharPosition` is retained when used as one of the ends of a `SourceSpan`, so\n   * computing the `HbsPosition` should be a one-time operation.\n   */\n  toHbsPos(): HbsPosition | null {\n    let locPos = this._locPos;\n\n    if (locPos === null) {\n      const hbsPos = this.source.hbsPosFor(this.charPos);\n\n      if (hbsPos === null) {\n        this._locPos = locPos = BROKEN;\n      } else {\n        this._locPos = locPos = new HbsPosition(this.source, hbsPos, this.charPos);\n      }\n    }\n\n    return locPos === BROKEN ? null : locPos;\n  }\n}\n\nexport class HbsPosition implements PositionData {\n  readonly kind = OffsetKind.HbsPosition;\n\n  _charPos: CharPosition | BROKEN | null;\n\n  constructor(\n    readonly source: Source,\n    readonly hbsPos: SourcePosition,\n    charPos: number | null = null\n  ) {\n    this._charPos = charPos === null ? null : new CharPosition(source, charPos);\n  }\n\n  /**\n   * Lazily compute the character offset from the {@see SourcePosition}. Once an `HbsPosition` has\n   * computed its `CharPosition`, it will not need to do compute it again, and the same\n   * `HbsPosition` is retained when used as one of the ends of a `SourceSpan`, so computing the\n   * `CharPosition` should be a one-time operation.\n   */\n  toCharPos(): CharPosition | null {\n    let charPos = this._charPos;\n\n    if (charPos === null) {\n      const charPosNumber = this.source.charPosFor(this.hbsPos);\n\n      if (charPosNumber === null) {\n        this._charPos = charPos = BROKEN;\n      } else {\n        this._charPos = charPos = new CharPosition(this.source, charPosNumber);\n      }\n    }\n\n    return charPos === BROKEN ? null : charPos;\n  }\n\n  /**\n   * Return the {@see SourcePosition} that this `HbsPosition` was instantiated with. This operation\n   * does not need to compute anything.\n   */\n  toJSON(): SourcePosition {\n    return this.hbsPos;\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  /**\n   * This is already an `HbsPosition`.\n   *\n   * {@see CharPosition} for the alternative.\n   */\n  toHbsPos(): HbsPosition {\n    return this;\n  }\n}\n\nexport class InvisiblePosition implements PositionData {\n  constructor(\n    readonly kind: OffsetKind.Broken | OffsetKind.InternalsSynthetic | OffsetKind.NonExistent,\n    // whatever was provided, possibly broken\n    readonly pos: SourcePosition\n  ) {}\n\n  /**\n   * A broken position cannot be turned into a {@see CharacterPosition}.\n   */\n  toCharPos(): null {\n    return null;\n  }\n\n  /**\n   * The serialization of an `InvisiblePosition is whatever Handlebars {@see SourcePosition} was\n   * originally identified as broken, non-existent or synthetic.\n   *\n   * If an `InvisiblePosition` never had an source offset at all, this method returns\n   * {@see UNKNOWN_POSITION} for compatibility.\n   */\n  toJSON(): SourcePosition {\n    return this.pos;\n  }\n\n  wrap(): SourceOffset {\n    return new SourceOffset(this);\n  }\n\n  get offset(): null {\n    return null;\n  }\n}\n\n/**\n * Compare two {@see AnyPosition} and determine whether they are equal.\n *\n * @see {SourceOffset#eql}\n */\nconst eql = match<boolean>((m) =>\n  m\n    .when(\n      OffsetKind.HbsPosition,\n      OffsetKind.HbsPosition,\n      ({ hbsPos: left }, { hbsPos: right }) =>\n        left.column === right.column && left.line === right.line\n    )\n    .when(\n      OffsetKind.CharPosition,\n      OffsetKind.CharPosition,\n      ({ charPos: left }, { charPos: right }) => left === right\n    )\n    .when(\n      OffsetKind.CharPosition,\n      OffsetKind.HbsPosition,\n      ({ offset: left }, right) => left === right.toCharPos()?.offset\n    )\n    .when(\n      OffsetKind.HbsPosition,\n      OffsetKind.CharPosition,\n      (left, { offset: right }) => left.toCharPos()?.offset === right\n    )\n    .when(MatchAny, MatchAny, () => false)\n);\n","import type { Nullable } from '@glimmer/interfaces';\nimport { assert } from '@glimmer/util';\n\nimport type { PrecompileOptions } from '../parser/tokenizer-event-handlers';\nimport type { SourceLocation, SourcePosition } from './location';\n\nimport { SourceOffset, SourceSpan } from './span';\n\nexport class Source {\n  static from(source: string, options: PrecompileOptions = {}): Source {\n    return new Source(source, options.meta?.moduleName);\n  }\n\n  constructor(\n    readonly source: string,\n    readonly module = 'an unknown module'\n  ) {}\n\n  /**\n   * Validate that the character offset represents a position in the source string.\n   */\n  check(offset: number): boolean {\n    return offset >= 0 && offset <= this.source.length;\n  }\n\n  slice(start: number, end: number): string {\n    return this.source.slice(start, end);\n  }\n\n  offsetFor(line: number, column: number): SourceOffset {\n    return SourceOffset.forHbsPos(this, { line, column });\n  }\n\n  spanFor({ start, end }: Readonly<SourceLocation>): SourceSpan {\n    return SourceSpan.forHbsLoc(this, {\n      start: { line: start.line, column: start.column },\n      end: { line: end.line, column: end.column },\n    });\n  }\n\n  hbsPosFor(offset: number): Nullable<SourcePosition> {\n    let seenLines = 0;\n    let seenChars = 0;\n\n    if (offset > this.source.length) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let nextLine = this.source.indexOf('\\n', seenChars);\n\n      if (offset <= nextLine || nextLine === -1) {\n        return {\n          line: seenLines + 1,\n          column: offset - seenChars,\n        };\n      } else {\n        seenLines += 1;\n        seenChars = nextLine + 1;\n      }\n    }\n  }\n\n  charPosFor(position: SourcePosition): number | null {\n    let { line, column } = position;\n    let sourceString = this.source;\n    let sourceLength = sourceString.length;\n    let seenLines = 0;\n    let seenChars = 0;\n\n    while (seenChars < sourceLength) {\n      let nextLine = this.source.indexOf('\\n', seenChars);\n      if (nextLine === -1) nextLine = this.source.length;\n\n      if (seenLines === line - 1) {\n        if (seenChars + column > nextLine) return nextLine;\n\n        if (import.meta.env.DEV) {\n          let roundTrip = this.hbsPosFor(seenChars + column);\n          assert(roundTrip !== null, `the returned offset failed to round-trip`);\n          assert(roundTrip.line === line, `the round-tripped line didn't match the original line`);\n          assert(\n            roundTrip.column === column,\n            `the round-tripped column didn't match the original column`\n          );\n        }\n\n        return seenChars + column;\n      } else if (nextLine === -1) {\n        return 0;\n      } else {\n        seenLines += 1;\n        seenChars = nextLine + 1;\n      }\n    }\n\n    return sourceLength;\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { getFirst, getLast, isPresentArray } from '@glimmer/util';\n\nimport type { LocatedWithOptionalSpan, LocatedWithSpan } from './location';\nimport type { SourceOffset } from './span';\n\nimport { SourceSpan } from './span';\n\nexport type HasSpan = SourceSpan | LocatedWithSpan | PresentArray<LocatedWithSpan>;\nexport type MaybeHasSpan = SourceSpan | LocatedWithOptionalSpan | LocatedWithOptionalSpan[] | null;\n\nexport type ToSourceOffset = number | SourceOffset;\n\nexport class SpanList {\n  static range(span: PresentArray<HasSourceSpan>): SourceSpan;\n  static range(span: HasSourceSpan[], fallback: SourceSpan): SourceSpan;\n  static range(span: HasSourceSpan[], fallback: SourceSpan = SourceSpan.NON_EXISTENT): SourceSpan {\n    return new SpanList(span.map(loc)).getRangeOffset(fallback);\n  }\n\n  _span: SourceSpan[];\n\n  constructor(span: SourceSpan[] = []) {\n    this._span = span;\n  }\n\n  add(offset: SourceSpan): void {\n    this._span.push(offset);\n  }\n\n  getRangeOffset(fallback: SourceSpan): SourceSpan {\n    if (isPresentArray(this._span)) {\n      let first = getFirst(this._span);\n      let last = getLast(this._span);\n      return first.extend(last);\n    } else {\n      return fallback;\n    }\n  }\n}\n\nexport type HasSourceSpan = { loc: SourceSpan } | SourceSpan | [HasSourceSpan, ...HasSourceSpan[]];\n\nexport function loc(span: HasSourceSpan): SourceSpan {\n  if (Array.isArray(span)) {\n    let first = getFirst(span);\n    let last = getLast(span);\n    return loc(first).extend(loc(last));\n  } else if (span instanceof SourceSpan) {\n    return span;\n  } else {\n    return span.loc;\n  }\n}\n\nexport type MaybeHasSourceSpan = { loc: SourceSpan } | SourceSpan | MaybeHasSourceSpan[];\n\nexport function hasSpan(span: MaybeHasSourceSpan): span is HasSourceSpan {\n  if (Array.isArray(span) && span.length === 0) {\n    return false;\n  }\n\n  return true;\n}\n\nexport function maybeLoc(location: MaybeHasSourceSpan, fallback: SourceSpan): SourceSpan {\n  if (hasSpan(location)) {\n    return loc(location);\n  } else {\n    return fallback;\n  }\n}\n","import type * as src from './source/api';\n\nexport interface GlimmerSyntaxError extends Error {\n  location: src.SourceSpan | null;\n  code: string | null;\n}\n\nexport function generateSyntaxError(message: string, location: src.SourceSpan): GlimmerSyntaxError {\n  let { module, loc } = location;\n  let { line, column } = loc.start;\n\n  let code = location.asString();\n  let quotedCode = code ? `\\n\\n|\\n|  ${code.split('\\n').join('\\n|  ')}\\n|\\n\\n` : '';\n\n  let error = new Error(\n    `${message}: ${quotedCode}(error occurred in '${module}' @ line ${line} : column ${column})`\n  ) as GlimmerSyntaxError;\n\n  error.name = 'SyntaxError';\n  error.location = location;\n  error.code = code;\n\n  return error;\n}\n","import type * as ASTv1 from './api';\n\n// ensure stays in sync with typing\n// ParentNode and ChildKey types are derived from VisitorKeysMap\nconst visitorKeys = {\n  Program: ['body'],\n  Template: ['body'],\n  Block: ['body'],\n\n  MustacheStatement: ['path', 'params', 'hash'],\n  BlockStatement: ['path', 'params', 'hash', 'program', 'inverse'],\n  ElementModifierStatement: ['path', 'params', 'hash'],\n  PartialStatement: ['name', 'params', 'hash'],\n  CommentStatement: [],\n  MustacheCommentStatement: [],\n  ElementNode: ['attributes', 'modifiers', 'children', 'comments'],\n  ElementStartNode: [],\n  ElementPartNode: [],\n  ElementEndNode: [],\n  ElementNameNode: [],\n  AttrNode: ['value'],\n  TextNode: [],\n\n  ConcatStatement: ['parts'],\n  SubExpression: ['path', 'params', 'hash'],\n  PathExpression: [],\n  PathHead: [],\n\n  StringLiteral: [],\n  BooleanLiteral: [],\n  NumberLiteral: [],\n  NullLiteral: [],\n  UndefinedLiteral: [],\n\n  Hash: ['pairs'],\n  HashPair: ['value'],\n  BlockParam: [],\n\n  // v2 new nodes\n  NamedBlock: ['attributes', 'modifiers', 'children', 'comments'],\n  SimpleElement: ['attributes', 'modifiers', 'children', 'comments'],\n  Component: ['head', 'attributes', 'modifiers', 'children', 'comments'],\n} as const;\n\ntype VisitorKeysMap = typeof visitorKeys;\n\nexport type VisitorKeys = { [P in keyof VisitorKeysMap]: VisitorKeysMap[P][number] };\nexport type VisitorKey<N extends ASTv1.Node> = VisitorKeys[N['type']] & keyof N;\n\nexport default visitorKeys;\n","import type { Nullable } from '@glimmer/interfaces';\n\nimport type * as ASTv1 from '../v1/api';\n\nexport interface TraversalError extends Error {\n  constructor: TraversalErrorConstructor;\n  key: string;\n  node: ASTv1.Node;\n  parent: Nullable<ASTv1.Node>;\n  stack?: string;\n}\n\nexport interface TraversalErrorConstructor {\n  new (\n    message: string,\n    node: ASTv1.Node,\n    parent: Nullable<ASTv1.Node>,\n    key: string\n  ): TraversalError;\n  readonly prototype: TraversalError;\n}\n\nconst TraversalError: TraversalErrorConstructor = (function () {\n  TraversalError.prototype = Object.create(Error.prototype);\n  TraversalError.prototype.constructor = TraversalError;\n\n  function TraversalError(\n    this: TraversalError,\n    message: string,\n    node: ASTv1.Node,\n    parent: Nullable<ASTv1.Node>,\n    key: string\n  ) {\n    let error = Error.call(this, message);\n\n    this.key = key;\n    this.message = message;\n    this.node = node;\n    this.parent = parent;\n\n    if (error.stack) {\n      this.stack = error.stack;\n    }\n  }\n\n  return TraversalError as unknown as TraversalErrorConstructor;\n})();\n\nexport default TraversalError;\n\nexport function cannotRemoveNode(\n  node: ASTv1.Node,\n  parent: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Cannot remove a node unless it is part of an array',\n    node,\n    parent,\n    key\n  );\n}\n\nexport function cannotReplaceNode(\n  node: ASTv1.Node,\n  parent: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Cannot replace a node with multiple nodes unless it is part of an array',\n    node,\n    parent,\n    key\n  );\n}\n\nexport function cannotReplaceOrRemoveInKeyHandlerYet(\n  node: ASTv1.Node,\n  key: string\n): TraversalError {\n  return new TraversalError(\n    'Replacing and removing in key handlers is not yet supported.',\n    node,\n    null,\n    key\n  );\n}\n","import type * as ASTv1 from '../v1/api';\n\nexport default class WalkerPath<N extends ASTv1.Node> {\n  node: N;\n  parent: WalkerPath<ASTv1.Node> | null;\n  parentKey: string | null;\n\n  constructor(\n    node: N,\n    parent: WalkerPath<ASTv1.Node> | null = null,\n    parentKey: string | null = null\n  ) {\n    this.node = node;\n    this.parent = parent;\n    this.parentKey = parentKey;\n  }\n\n  get parentNode(): ASTv1.Node | null {\n    return this.parent ? this.parent.node : null;\n  }\n\n  parents(): Iterable<WalkerPath<ASTv1.Node> | null> {\n    return {\n      [Symbol.iterator]: () => {\n        return new PathParentsIterator(this);\n      },\n    };\n  }\n}\n\nclass PathParentsIterator implements Iterator<WalkerPath<ASTv1.Node> | null> {\n  path: WalkerPath<ASTv1.Node>;\n\n  constructor(path: WalkerPath<ASTv1.Node>) {\n    this.path = path;\n  }\n\n  next() {\n    if (this.path.parent) {\n      this.path = this.path.parent;\n      return { done: false, value: this.path };\n    } else {\n      return { done: true, value: null };\n    }\n  }\n}\n","import { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { deprecate, unwrap } from '@glimmer/util';\n\nimport type * as ASTv1 from '../v1/api';\nimport type { VisitorKey, VisitorKeys } from '../v1/visitor-keys';\nimport type { KeyHandler, KeyTraversal, NodeHandler, NodeTraversal, NodeVisitor } from './visitor';\n\nimport visitorKeys from '../v1/visitor-keys';\nimport {\n  cannotRemoveNode,\n  cannotReplaceNode,\n  cannotReplaceOrRemoveInKeyHandlerYet,\n} from './errors';\nimport WalkerPath from './path';\n\nfunction getEnterFunction<N extends ASTv1.Node>(\n  handler: NodeTraversal<N>\n): NodeHandler<N> | undefined;\nfunction getEnterFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: KeyTraversal<N, K>\n): KeyHandler<N, K> | undefined;\nfunction getEnterFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N> | KeyTraversal<N, K>\n): NodeHandler<N> | KeyHandler<N, K> | undefined {\n  if (typeof handler === 'function') {\n    return handler;\n  } else {\n    return handler.enter as NodeHandler<N> | KeyHandler<N, K>;\n  }\n}\n\nfunction getExitFunction<N extends ASTv1.Node>(\n  handler: NodeTraversal<N>\n): NodeHandler<N> | undefined;\nfunction getExitFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: KeyTraversal<N, K>\n): KeyHandler<N, K> | undefined;\nfunction getExitFunction<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N> | KeyTraversal<N, K>\n): NodeHandler<N> | KeyHandler<N, K> | undefined {\n  if (typeof handler === 'function') {\n    return undefined;\n  } else {\n    return handler.exit as NodeHandler<N> | KeyHandler<N, K>;\n  }\n}\n\nfunction getKeyHandler<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  handler: NodeTraversal<N>,\n  key: K\n): KeyTraversal<N, K> | KeyTraversal<N, VisitorKey<N>> | undefined {\n  let keyVisitor = typeof handler !== 'function' ? handler.keys : undefined;\n  if (keyVisitor === undefined) return;\n\n  let keyHandler = keyVisitor[key];\n  if (keyHandler !== undefined) {\n    return keyHandler as KeyTraversal<N, K>;\n  }\n  return keyVisitor.All;\n}\n\nfunction getNodeHandler<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  nodeType: N['type']\n): NodeTraversal<N>;\nfunction getNodeHandler(visitor: NodeVisitor, nodeType: 'All'): NodeTraversal<ASTv1.Node>;\nfunction getNodeHandler<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  nodeType: N['type']\n): NodeTraversal<ASTv1.Node> | undefined {\n  if (nodeType === 'Template' || nodeType === 'Block') {\n    if (visitor.Program) {\n      if (LOCAL_DEBUG) {\n        deprecate(\n          `The 'Program' visitor node is deprecated. Use 'Template' or 'Block' instead (node was '${nodeType}') `\n        );\n      }\n\n      return visitor.Program as NodeTraversal<ASTv1.Node>;\n    }\n  }\n\n  let handler = visitor[nodeType];\n  if (handler !== undefined) {\n    return handler as unknown as NodeTraversal<ASTv1.Node>;\n  }\n  return visitor.All;\n}\n\nfunction visitNode<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  path: WalkerPath<N>\n): ASTv1.Node | ASTv1.Node[] | undefined | null | void {\n  let { node, parent, parentKey } = path;\n\n  let handler: NodeTraversal<N> = getNodeHandler(visitor, node.type);\n  let enter;\n  let exit;\n\n  if (handler !== undefined) {\n    enter = getEnterFunction(handler);\n    exit = getExitFunction(handler);\n  }\n\n  let result: ASTv1.Node | ASTv1.Node[] | undefined | null | void;\n  if (enter !== undefined) {\n    result = enter(node, path);\n  }\n\n  if (result !== undefined && result !== null) {\n    if (JSON.stringify(node) === JSON.stringify(result)) {\n      result = undefined;\n    } else if (Array.isArray(result)) {\n      visitArray(visitor, result, parent, parentKey);\n      return result;\n    } else {\n      let path = new WalkerPath(result, parent, parentKey);\n      return visitNode(visitor, path) || result;\n    }\n  }\n\n  if (result === undefined) {\n    let keys = visitorKeys[node.type];\n\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i] as VisitorKeys[N['type']] & keyof N;\n      // we know if it has child keys we can widen to a ParentNode\n      visitKey(visitor, handler, path, key);\n    }\n\n    if (exit !== undefined) {\n      result = exit(node, path);\n    }\n  }\n\n  return result;\n}\n\nfunction get<N extends ASTv1.Node>(\n  node: N,\n  key: VisitorKeys[N['type']] & keyof N\n): ASTv1.Node | ASTv1.Node[] {\n  return node[key] as unknown as ASTv1.Node | ASTv1.Node[];\n}\n\nfunction set<N extends ASTv1.Node, K extends keyof N>(node: N, key: K, value: N[K]): void {\n  node[key] = value;\n}\n\nfunction visitKey<N extends ASTv1.Node>(\n  visitor: NodeVisitor,\n  handler: NodeTraversal<N>,\n  path: WalkerPath<N>,\n  key: VisitorKeys[N['type']] & keyof N\n) {\n  let { node } = path;\n\n  let value = get(node, key);\n  if (!value) {\n    return;\n  }\n\n  let keyEnter;\n  let keyExit;\n\n  if (handler !== undefined) {\n    let keyHandler = getKeyHandler(handler, key);\n    if (keyHandler !== undefined) {\n      keyEnter = getEnterFunction(keyHandler);\n      keyExit = getExitFunction(keyHandler);\n    }\n  }\n\n  if (keyEnter !== undefined) {\n    if (keyEnter(node, key) !== undefined) {\n      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);\n    }\n  }\n\n  if (Array.isArray(value)) {\n    visitArray(visitor, value, path, key);\n  } else {\n    let keyPath = new WalkerPath(value, path, key);\n    let result = visitNode(visitor, keyPath);\n    if (result !== undefined) {\n      // TODO: dynamically check the results by having a table of\n      // expected node types in value space, not just type space\n\n      assignKey(node, key, value, result as any);\n    }\n  }\n\n  if (keyExit !== undefined) {\n    if (keyExit(node, key) !== undefined) {\n      throw cannotReplaceOrRemoveInKeyHandlerYet(node, key);\n    }\n  }\n}\n\nfunction visitArray(\n  visitor: NodeVisitor,\n  array: ASTv1.Node[],\n  parent: WalkerPath<ASTv1.Node> | null,\n  parentKey: string | null\n) {\n  for (let i = 0; i < array.length; i++) {\n    let node = unwrap(array[i]);\n    let path = new WalkerPath(node, parent, parentKey);\n    let result = visitNode(visitor, path);\n    if (result !== undefined) {\n      i += spliceArray(array, i, result) - 1;\n    }\n  }\n}\n\nfunction assignKey<N extends ASTv1.Node, K extends VisitorKey<N>>(\n  node: N,\n  key: K,\n  value: ASTv1.Node,\n  result: N[K] | [N[K]] | null\n) {\n  if (result === null) {\n    throw cannotRemoveNode(value, node, key);\n  } else if (Array.isArray(result)) {\n    if (result.length === 1) {\n      set(node, key, result[0]);\n    } else {\n      if (result.length === 0) {\n        throw cannotRemoveNode(value, node, key);\n      } else {\n        throw cannotReplaceNode(value, node, key);\n      }\n    }\n  } else {\n    set(node, key, result);\n  }\n}\n\nfunction spliceArray(array: ASTv1.Node[], index: number, result: ASTv1.Node | ASTv1.Node[] | null) {\n  if (result === null) {\n    array.splice(index, 1);\n    return 0;\n  } else if (Array.isArray(result)) {\n    array.splice(index, 1, ...result);\n    return result.length;\n  } else {\n    array.splice(index, 1, result);\n    return 1;\n  }\n}\n\nexport default function traverse(node: ASTv1.Node, visitor: NodeVisitor): void {\n  let path = new WalkerPath(node);\n  visitNode(visitor, path);\n}\n","import type { Nullable } from '@glimmer/interfaces';\n\nimport type * as ASTv1 from '../v1/api';\n\nexport type NodeCallback<N extends ASTv1.Node> = (node: N, walker: Walker) => void;\n\nexport default class Walker {\n  public stack: unknown[] = [];\n  constructor(public order?: unknown) {}\n\n  visit<N extends ASTv1.Node>(node: Nullable<N>, visitor: NodeCallback<N>): void {\n    if (!node) {\n      return;\n    }\n\n    this.stack.push(node);\n\n    if (this.order === 'post') {\n      this.children(node, visitor);\n      visitor(node, this);\n    } else {\n      visitor(node, this);\n      this.children(node, visitor);\n    }\n\n    this.stack.pop();\n  }\n\n  children<N extends ASTv1.Node>(\n    node: N & ASTv1.Node,\n    callback: NodeCallback<N & ASTv1.Node>\n  ): void {\n    switch (node.type) {\n      case 'Block':\n      case 'Template':\n        return visitors.Program(this, node as unknown as ASTv1.Program, callback);\n      case 'ElementNode':\n        return visitors.ElementNode(this, node, callback);\n      case 'BlockStatement':\n        return visitors.BlockStatement(this, node, callback);\n      default:\n        return;\n    }\n  }\n}\n\nconst visitors = {\n  Program(walker: Walker, node: ASTv1.Program, callback: NodeCallback<ASTv1.Statement>) {\n    walkBody(walker, node.body, callback);\n  },\n\n  Template(walker: Walker, node: ASTv1.Template, callback: NodeCallback<ASTv1.Node>) {\n    walkBody(walker, node.body, callback);\n  },\n\n  Block(walker: Walker, node: ASTv1.Block, callback: NodeCallback<ASTv1.Node>) {\n    walkBody(walker, node.body, callback);\n  },\n\n  ElementNode(walker: Walker, node: ASTv1.ElementNode, callback: NodeCallback<ASTv1.Node>) {\n    walkBody(walker, node.children, callback);\n  },\n\n  BlockStatement(walker: Walker, node: ASTv1.BlockStatement, callback: NodeCallback<ASTv1.Block>) {\n    walker.visit(node.program, callback);\n    walker.visit(node.inverse || null, callback);\n  },\n} as const;\n\nfunction walkBody(\n  walker: Walker,\n  body: ASTv1.Statement[],\n  callback: NodeCallback<ASTv1.Statement>\n) {\n  for (const child of body) {\n    walker.visit(child, callback);\n  }\n}\n","import type { Nullable } from '@glimmer/interfaces';\nimport { expect, unwrap } from '@glimmer/util';\n\nimport type * as src from './source/api';\nimport type * as ASTv1 from './v1/api';\nimport type * as HBS from './v1/handlebars-ast';\n\nimport { generateSyntaxError } from './syntax-error';\n\n// Regex to validate the identifier for block parameters.\n// Based on the ID validation regex in Handlebars.\n\nlet ID_INVERSE_PATTERN = /[!\"#%&'()*+./;<=>@[\\\\\\]^`{|}~]/u;\n\n// Checks the element's attributes to see if it uses block params.\n// If it does, registers the block params with the program and\n// removes the corresponding attributes from the element.\n\nexport function parseElementBlockParams(element: ASTv1.ElementNode): void {\n  let params = parseBlockParams(element);\n  if (params) {\n    element.blockParamNodes = params;\n    element.blockParams = params.map((p) => p.value);\n  }\n}\n\nexport function parseProgramBlockParamsLocs(code: src.Source, block: ASTv1.BlockStatement) {\n  const blockRange = [block.loc.getStart().offset!, block.loc.getEnd().offset!] as [number, number];\n  let part = code.slice(...blockRange);\n  let start = blockRange[0];\n  let idx = part.indexOf('|') + 1;\n  start += idx;\n  part = part.slice(idx, -1);\n  idx = part.indexOf('|');\n  part = part.slice(0, idx);\n  for (const param of block.program.blockParamNodes) {\n    const regex = new RegExp(`\\\\b${param.value}\\\\b`);\n    const match = regex.exec(part)!;\n    const range = [start + match.index, 0] as [number, number];\n    range[1] = range[0] + param.value.length;\n    param.loc = code.spanFor({\n      start: code.hbsPosFor(range[0])!,\n      end: code.hbsPosFor(range[1])!,\n    });\n  }\n}\n\nexport function parseElementPartLocs(code: src.Source, element: ASTv1.ElementNode) {\n  const elementRange = [element.loc.getStart().offset!, element.loc.getEnd().offset!] as [\n    number,\n    number,\n  ];\n  let start = elementRange[0];\n  let codeSlice = code.slice(...elementRange);\n  for (const part of element.parts) {\n    const idx = codeSlice.indexOf(part.value);\n    const range = [start + idx, 0] as [number, number];\n    range[1] = range[0] + part.value.length;\n    codeSlice = code.slice(range[1], elementRange[1]);\n    start = range[1];\n    part.loc = code.spanFor({\n      start: code.hbsPosFor(range[0])!,\n      end: code.hbsPosFor(range[1])!,\n    });\n  }\n}\n\nfunction parseBlockParams(element: ASTv1.ElementNode): Nullable<ASTv1.BlockParam[]> {\n  let l = element.attributes.length;\n  let attrNames = [];\n\n  for (let i = 0; i < l; i++) {\n    attrNames.push(unwrap(element.attributes[i]).name);\n  }\n\n  let asIndex = attrNames.indexOf('as');\n\n  if (\n    asIndex === -1 &&\n    attrNames.length > 0 &&\n    unwrap(attrNames[attrNames.length - 1]).charAt(0) === '|'\n  ) {\n    throw generateSyntaxError(\n      'Block parameters must be preceded by the `as` keyword, detected block parameters without `as`',\n      element.loc\n    );\n  }\n\n  if (asIndex !== -1 && l > asIndex && unwrap(attrNames[asIndex + 1]).charAt(0) === '|') {\n    // Some basic validation, since we're doing the parsing ourselves\n    let paramsString = attrNames.slice(asIndex).join(' ');\n    if (\n      paramsString.charAt(paramsString.length - 1) !== '|' ||\n      expect(paramsString.match(/\\|/gu), `block params must exist here`).length !== 2\n    ) {\n      throw generateSyntaxError(\n        \"Invalid block parameters syntax, '\" + paramsString + \"'\",\n        element.loc\n      );\n    }\n\n    let params: ASTv1.BlockParam[] = [];\n    for (let i = asIndex + 1; i < l; i++) {\n      let param = unwrap(attrNames[i]).replace(/\\|/gu, '');\n      if (param !== '') {\n        if (ID_INVERSE_PATTERN.test(param)) {\n          throw generateSyntaxError(\n            \"Invalid identifier for block parameters, '\" + param + \"'\",\n            element.loc\n          );\n        }\n        let loc = element.attributes[i]!.loc;\n        if (attrNames[i]!.startsWith('|')) {\n          loc = loc.slice({ skipStart: 1 });\n        }\n        if (attrNames[i]!.endsWith('|')) {\n          loc = loc.slice({ skipEnd: 1 });\n        }\n\n        // fix hbs parser bug, the range contains the whitespace between attributes...\n        if (loc.endPosition.column - loc.startPosition.column > param.length) {\n          loc = loc.slice({\n            skipEnd: loc.endPosition.column - loc.startPosition.column - param.length,\n          });\n        }\n\n        params.push({\n          type: 'BlockParam',\n          value: param,\n          loc,\n        });\n      }\n    }\n\n    if (params.length === 0) {\n      throw generateSyntaxError('Cannot use zero block parameters', element.loc);\n    }\n\n    element.attributes = element.attributes.slice(0, asIndex);\n    return params;\n  }\n\n  return null;\n}\n\nexport function childrenFor(\n  node: ASTv1.Block | ASTv1.Template | ASTv1.ElementNode\n): ASTv1.TopLevelStatement[] {\n  switch (node.type) {\n    case 'Block':\n    case 'Template':\n      return node.body;\n    case 'ElementNode':\n      return node.children;\n  }\n}\n\nexport function appendChild(\n  parent: ASTv1.Block | ASTv1.Template | ASTv1.ElementNode,\n  node: ASTv1.Statement\n): void {\n  childrenFor(parent).push(node);\n}\n\nexport function isHBSLiteral(path: HBS.Expression): path is HBS.Literal;\nexport function isHBSLiteral(path: ASTv1.Expression): path is ASTv1.Literal;\nexport function isHBSLiteral(\n  path: HBS.Expression | ASTv1.Expression\n): path is HBS.Literal | ASTv1.Literal {\n  return (\n    path.type === 'StringLiteral' ||\n    path.type === 'BooleanLiteral' ||\n    path.type === 'NumberLiteral' ||\n    path.type === 'NullLiteral' ||\n    path.type === 'UndefinedLiteral'\n  );\n}\n\nexport function printLiteral(literal: ASTv1.Literal): string {\n  if (literal.type === 'UndefinedLiteral') {\n    return 'undefined';\n  } else {\n    return JSON.stringify(literal.value);\n  }\n}\n\nexport function isUpperCase(tag: string): boolean {\n  return tag[0] === tag[0]?.toUpperCase() && tag[0] !== tag[0]?.toLowerCase();\n}\n\nexport function isLowerCase(tag: string): boolean {\n  return tag[0] === tag[0]?.toLowerCase() && tag[0] !== tag[0]?.toUpperCase();\n}\n","import type { Dict, Nullable } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { asPresentArray, assert, assign, deprecate, isPresentArray } from '@glimmer/util';\n\nimport type { SourceLocation, SourcePosition } from '../source/location';\nimport type * as ASTv1 from './api';\n\nimport { SYNTHETIC_LOCATION } from '../source/location';\nimport { Source } from '../source/source';\nimport { SourceSpan } from '../source/span';\nimport { PathExpressionImplV1 } from './legacy-interop';\n\nlet _SOURCE: Source | undefined;\n\nfunction SOURCE(): Source {\n  if (!_SOURCE) {\n    _SOURCE = new Source('', '(synthetic)');\n  }\n\n  return _SOURCE;\n}\n\n// const SOURCE = new Source('', '(tests)');\n\n// Statements\n\nexport type BuilderHead = string | ASTv1.Expression;\nexport type TagDescriptor = string | { name: string; selfClosing: boolean };\n\nfunction buildMustache(\n  path: BuilderHead | ASTv1.Literal,\n  params?: ASTv1.Expression[],\n  hash?: ASTv1.Hash,\n  raw?: boolean,\n  loc?: SourceLocation,\n  strip?: ASTv1.StripFlags\n): ASTv1.MustacheStatement {\n  if (typeof path === 'string') {\n    path = buildPath(path);\n  }\n\n  return {\n    type: 'MustacheStatement',\n    path,\n    params: params || [],\n    hash: hash || buildHash([]),\n    escaped: !raw,\n    trusting: !!raw,\n    loc: buildLoc(loc || null),\n    strip: strip || { open: false, close: false },\n  };\n}\n\nfunction buildBlock(\n  path: BuilderHead,\n  params: Nullable<ASTv1.Expression[]>,\n  hash: Nullable<ASTv1.Hash>,\n  _defaultBlock: ASTv1.PossiblyDeprecatedBlock,\n  _elseBlock?: Nullable<ASTv1.PossiblyDeprecatedBlock>,\n  loc?: SourceLocation,\n  openStrip?: ASTv1.StripFlags,\n  inverseStrip?: ASTv1.StripFlags,\n  closeStrip?: ASTv1.StripFlags\n): ASTv1.BlockStatement {\n  let defaultBlock: ASTv1.Block;\n  let elseBlock: Nullable<ASTv1.Block> | undefined;\n\n  if (_defaultBlock.type === 'Template') {\n    if (LOCAL_DEBUG) {\n      deprecate(`b.program is deprecated. Use b.blockItself instead.`);\n    }\n\n    defaultBlock = assign({}, _defaultBlock, { type: 'Block' }) as unknown as ASTv1.Block;\n  } else {\n    defaultBlock = _defaultBlock;\n  }\n\n  if (_elseBlock !== undefined && _elseBlock !== null && _elseBlock.type === 'Template') {\n    if (LOCAL_DEBUG) {\n      deprecate(`b.program is deprecated. Use b.blockItself instead.`);\n    }\n\n    elseBlock = assign({}, _elseBlock, { type: 'Block' }) as unknown as ASTv1.Block;\n  } else {\n    elseBlock = _elseBlock;\n  }\n\n  return {\n    type: 'BlockStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    program: defaultBlock || null,\n    inverse: elseBlock || null,\n    loc: buildLoc(loc || null),\n    openStrip: openStrip || { open: false, close: false },\n    inverseStrip: inverseStrip || { open: false, close: false },\n    closeStrip: closeStrip || { open: false, close: false },\n  };\n}\n\nfunction buildElementModifier(\n  path: BuilderHead | ASTv1.Expression,\n  params?: ASTv1.Expression[],\n  hash?: ASTv1.Hash,\n  loc?: Nullable<SourceLocation>\n): ASTv1.ElementModifierStatement {\n  return {\n    type: 'ElementModifierStatement',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPartial(\n  name: ASTv1.PathExpression,\n  params?: ASTv1.Expression[],\n  hash?: ASTv1.Hash,\n  indent?: string,\n  loc?: SourceLocation\n): ASTv1.PartialStatement {\n  return {\n    type: 'PartialStatement',\n    name: name,\n    params: params || [],\n    hash: hash || buildHash([]),\n    indent: indent || '',\n    strip: { open: false, close: false },\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildComment(value: string, loc?: SourceLocation): ASTv1.CommentStatement {\n  return {\n    type: 'CommentStatement',\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildMustacheComment(value: string, loc?: SourceLocation): ASTv1.MustacheCommentStatement {\n  return {\n    type: 'MustacheCommentStatement',\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildConcat(\n  parts: (ASTv1.TextNode | ASTv1.MustacheStatement)[],\n  loc?: SourceLocation\n): ASTv1.ConcatStatement {\n  if (!isPresentArray(parts)) {\n    throw new Error(`b.concat requires at least one part`);\n  }\n\n  return {\n    type: 'ConcatStatement',\n    parts: parts || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\n// Nodes\n\nexport type ElementParts =\n  | ['attrs', ...AttrSexp[]]\n  | ['modifiers', ...ModifierSexp[]]\n  | ['body', ...ASTv1.Statement[]]\n  | ['comments', ...ElementComment[]]\n  | ['as', ...string[]]\n  | ['loc', SourceLocation];\n\nexport type PathSexp = string | ['path', string, LocSexp?];\n\nexport type ModifierSexp =\n  | string\n  | [PathSexp, LocSexp?]\n  | [PathSexp, ASTv1.Expression[], LocSexp?]\n  | [PathSexp, ASTv1.Expression[], Dict<ASTv1.Expression>, LocSexp?];\n\nexport type AttrSexp = [string, ASTv1.AttrNode['value'] | string, LocSexp?];\n\nexport type LocSexp = ['loc', SourceLocation];\n\nexport type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;\n\nexport type SexpValue =\n  | string\n  | ASTv1.Expression[]\n  | Dict<ASTv1.Expression>\n  | LocSexp\n  | PathSexp\n  | undefined;\n\nexport interface BuildElementOptions {\n  attrs?: ASTv1.AttrNode[];\n  modifiers?: ASTv1.ElementModifierStatement[];\n  children?: ASTv1.Statement[];\n  comments?: ElementComment[];\n  blockParams?: string[];\n  loc?: SourceSpan;\n}\n\nfunction buildElement(tag: TagDescriptor, options: BuildElementOptions = {}): ASTv1.ElementNode {\n  let { attrs, blockParams, modifiers, comments, children, loc } = options;\n\n  let tagName: string;\n\n  // this is used for backwards compat, prior to `selfClosing` being part of the ElementNode AST\n  let selfClosing = false;\n  if (typeof tag === 'object') {\n    selfClosing = tag.selfClosing;\n    tagName = tag.name;\n  } else if (tag.slice(-1) === '/') {\n    tagName = tag.slice(0, -1);\n    selfClosing = true;\n  } else {\n    tagName = tag;\n  }\n\n  return {\n    type: 'ElementNode',\n    tag: tagName,\n    nameNode: {\n      type: 'ElementNameNode',\n      value: tag,\n    } as ASTv1.ElementNameNode,\n    startTag: {\n      type: 'ElementStartNode',\n      value: tag,\n    } as ASTv1.ElementStartNode,\n    endTag: {\n      type: 'ElementEndNode',\n      value: selfClosing ? '' : tag,\n    } as ASTv1.ElementEndNode,\n    parts: tagName\n      .split('.')\n      .map((t) => ({ type: 'ElementPartNode', value: t }) as ASTv1.ElementPartNode),\n    selfClosing: selfClosing,\n    attributes: attrs || [],\n    blockParams: blockParams || [],\n    blockParamNodes:\n      blockParams?.map((x) => ({ type: 'BlockParam', value: x }) as ASTv1.BlockParam) || [],\n    modifiers: modifiers || [],\n    comments: (comments as ASTv1.MustacheCommentStatement[]) || [],\n    children: children || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildAttr(\n  name: string,\n  value: ASTv1.AttrNode['value'],\n  loc?: SourceLocation\n): ASTv1.AttrNode {\n  return {\n    type: 'AttrNode',\n    name: name,\n    value: value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildText(chars?: string, loc?: SourceLocation): ASTv1.TextNode {\n  return {\n    type: 'TextNode',\n    chars: chars || '',\n    loc: buildLoc(loc || null),\n  };\n}\n\n// Expressions\n\nfunction buildSexpr(\n  path: BuilderHead,\n  params?: ASTv1.Expression[],\n  hash?: ASTv1.Hash,\n  loc?: SourceLocation\n): ASTv1.SubExpression {\n  return {\n    type: 'SubExpression',\n    path: buildPath(path),\n    params: params || [],\n    hash: hash || buildHash([]),\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction headToString(head: ASTv1.PathHead): { original: string; parts: string[] } {\n  switch (head.type) {\n    case 'AtHead':\n      return { original: head.name, parts: [head.name] };\n    case 'ThisHead':\n      return { original: `this`, parts: [] };\n    case 'VarHead':\n      return { original: head.name, parts: [head.name] };\n  }\n}\n\nfunction buildHead(\n  original: string,\n  loc: SourceLocation\n): { head: ASTv1.PathHead; tail: string[] } {\n  let [head, ...tail] = asPresentArray(original.split('.'));\n  let headNode: ASTv1.PathHead;\n\n  if (head === 'this') {\n    headNode = {\n      type: 'ThisHead',\n      loc: buildLoc(loc || null),\n    };\n  } else if (head[0] === '@') {\n    headNode = {\n      type: 'AtHead',\n      name: head,\n      loc: buildLoc(loc || null),\n    };\n  } else {\n    headNode = {\n      type: 'VarHead',\n      name: head,\n      loc: buildLoc(loc || null),\n    };\n  }\n\n  return {\n    head: headNode,\n    tail,\n  };\n}\n\nfunction buildThis(loc: SourceLocation): ASTv1.PathHead {\n  return {\n    type: 'ThisHead',\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildAtName(name: string, loc: SourceLocation): ASTv1.PathHead {\n  // the `@` should be included so we have a complete source range\n  assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);\n\n  return {\n    type: 'AtHead',\n    name,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildVar(name: string, loc: SourceLocation): ASTv1.PathHead {\n  assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);\n  assert(\n    name[0] !== '@',\n    `You called builders.var() with '${name}'. Call builders.at('${name}') instead`\n  );\n\n  return {\n    type: 'VarHead',\n    name,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildHeadFromString(head: string, loc: SourceLocation): ASTv1.PathHead {\n  if (head[0] === '@') {\n    return buildAtName(head, loc);\n  } else if (head === 'this') {\n    return buildThis(loc);\n  } else {\n    return buildVar(head, loc);\n  }\n}\n\nfunction buildNamedBlockName(name: string, loc?: SourceLocation): ASTv1.NamedBlockName {\n  return {\n    type: 'NamedBlockName',\n    name,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildCleanPath(\n  head: ASTv1.PathHead,\n  tail: string[],\n  loc: SourceLocation\n): ASTv1.PathExpression {\n  let { original: originalHead, parts: headParts } = headToString(head);\n  let parts = [...headParts, ...tail];\n  let original = [...originalHead, ...parts].join('.');\n\n  return new PathExpressionImplV1(original, head, tail, buildLoc(loc || null));\n}\n\nfunction buildPath(\n  path: ASTv1.PathExpression | string | { head: string; tail: string[] },\n  loc?: SourceLocation\n): ASTv1.PathExpression;\nfunction buildPath(path: ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;\nfunction buildPath(path: BuilderHead | ASTv1.Expression, loc?: SourceLocation): ASTv1.Expression;\nfunction buildPath(\n  path: BuilderHead | ASTv1.Expression | { head: string; tail: string[] },\n  loc?: SourceLocation\n): ASTv1.Expression {\n  if (typeof path !== 'string') {\n    if ('type' in path) {\n      return path;\n    } else {\n      let { head, tail } = buildHead(path.head, SourceSpan.broken());\n\n      assert(\n        tail.length === 0,\n        `builder.path({ head, tail }) should not be called with a head with dots in it`\n      );\n\n      let { original: originalHead } = headToString(head);\n\n      return new PathExpressionImplV1(\n        [originalHead, ...tail].join('.'),\n        head,\n        tail,\n        buildLoc(loc || null)\n      );\n    }\n  }\n\n  let { head, tail } = buildHead(path, SourceSpan.broken());\n\n  return new PathExpressionImplV1(path, head, tail, buildLoc(loc || null));\n}\n\nfunction buildLiteral<T extends ASTv1.Literal>(\n  type: T['type'],\n  value: T['value'],\n  loc?: SourceLocation\n): T {\n  return {\n    type,\n    value,\n    original: value,\n    loc: buildLoc(loc || null),\n  } as T;\n}\n\n// Miscellaneous\n\nfunction buildHash(pairs?: ASTv1.HashPair[], loc?: SourceLocation): ASTv1.Hash {\n  return {\n    type: 'Hash',\n    pairs: pairs || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPair(key: string, value: ASTv1.Expression, loc?: SourceLocation): ASTv1.HashPair {\n  return {\n    type: 'HashPair',\n    key: key,\n    value,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildProgram(\n  body?: ASTv1.Statement[],\n  blockParams?: string[],\n  loc?: SourceLocation\n): ASTv1.Template {\n  return {\n    type: 'Template',\n    body: body || [],\n    blockParams: blockParams || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildBlockItself(\n  body?: ASTv1.Statement[],\n  blockParams?: string[],\n  chained = false,\n  loc?: SourceLocation\n): ASTv1.Block {\n  return {\n    type: 'Block',\n    body: body || [],\n    blockParams: blockParams || [],\n    blockParamNodes:\n      blockParams?.map((b) => ({ type: 'BlockParam', value: b }) as ASTv1.BlockParam) || [],\n    chained,\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildTemplate(\n  body?: ASTv1.Statement[],\n  blockParams?: string[],\n  loc?: SourceLocation\n): ASTv1.Template {\n  return {\n    type: 'Template',\n    body: body || [],\n    blockParams: blockParams || [],\n    loc: buildLoc(loc || null),\n  };\n}\n\nfunction buildPosition(line: number, column: number): SourcePosition {\n  return {\n    line,\n    column,\n  };\n}\n\nfunction buildLoc(loc: Nullable<SourceLocation>): SourceSpan;\nfunction buildLoc(\n  startLine: number,\n  startColumn: number,\n  endLine?: number,\n  endColumn?: number,\n  source?: string\n): SourceSpan;\n\nfunction buildLoc(...args: any[]): SourceSpan {\n  if (args.length === 1) {\n    let loc = args[0];\n\n    if (loc && typeof loc === 'object') {\n      return SourceSpan.forHbsLoc(SOURCE(), loc);\n    } else {\n      return SourceSpan.forHbsLoc(SOURCE(), SYNTHETIC_LOCATION);\n    }\n  } else {\n    let [startLine, startColumn, endLine, endColumn, _source] = args;\n    let source = _source ? new Source('', _source) : SOURCE();\n\n    return SourceSpan.forHbsLoc(source, {\n      start: {\n        line: startLine,\n        column: startColumn,\n      },\n      end: {\n        line: endLine,\n        column: endColumn,\n      },\n    });\n  }\n}\n\nexport default {\n  mustache: buildMustache,\n  block: buildBlock,\n  partial: buildPartial,\n  comment: buildComment,\n  mustacheComment: buildMustacheComment,\n  element: buildElement,\n  elementModifier: buildElementModifier,\n  attr: buildAttr,\n  text: buildText,\n  sexpr: buildSexpr,\n\n  concat: buildConcat,\n  hash: buildHash,\n  pair: buildPair,\n  literal: buildLiteral,\n  program: buildProgram,\n  blockItself: buildBlockItself,\n  template: buildTemplate,\n  loc: buildLoc,\n  pos: buildPosition,\n\n  path: buildPath,\n\n  fullPath: buildCleanPath,\n  head: buildHeadFromString,\n  at: buildAtName,\n  var: buildVar,\n  this: buildThis,\n  blockName: buildNamedBlockName,\n\n  string: literal('StringLiteral') as (value: string) => ASTv1.StringLiteral,\n  boolean: literal('BooleanLiteral') as (value: boolean) => ASTv1.BooleanLiteral,\n  number: literal('NumberLiteral') as (value: number) => ASTv1.NumberLiteral,\n  undefined(): ASTv1.UndefinedLiteral {\n    return buildLiteral('UndefinedLiteral', undefined);\n  },\n  null(): ASTv1.NullLiteral {\n    return buildLiteral('NullLiteral', null);\n  },\n};\n\ntype BuildLiteral<T extends ASTv1.Literal> = (value: T['value']) => T;\n\nfunction literal<T extends ASTv1.Literal>(type: T['type']): BuildLiteral<T> {\n  return function (value: T['value'], loc?: SourceLocation): T {\n    return buildLiteral(type, value, loc);\n  };\n}\n","import { asPresentArray, assertPresentArray, getFirst } from '@glimmer/util';\n\nimport type { SourceSpan } from '../source/span';\nimport type { PathExpression, PathHead } from './nodes-v1';\n\nimport b from './public-builders';\n\nexport class PathExpressionImplV1 implements PathExpression {\n  type = 'PathExpression' as const;\n  public parts: string[];\n  public this = false;\n  public data = false;\n\n  constructor(\n    public original: string,\n    head: PathHead,\n    tail: string[],\n    public loc: SourceSpan\n  ) {\n    let parts = tail.slice();\n\n    if (head.type === 'ThisHead') {\n      this.this = true;\n    } else if (head.type === 'AtHead') {\n      this.data = true;\n      parts.unshift(head.name.slice(1));\n    } else {\n      parts.unshift(head.name);\n    }\n\n    this.parts = parts;\n  }\n\n  // Cache for the head value.\n  _head?: PathHead = undefined;\n\n  get head(): PathHead {\n    if (this._head) {\n      return this._head;\n    }\n\n    let firstPart: string;\n\n    if (this.this) {\n      firstPart = 'this';\n    } else if (this.data) {\n      firstPart = `@${getFirst(asPresentArray(this.parts))}`;\n    } else {\n      assertPresentArray(this.parts);\n      firstPart = getFirst(this.parts);\n    }\n\n    let firstPartLoc = this.loc.collapse('start').sliceStartChars({\n      chars: firstPart.length,\n    }).loc;\n\n    return (this._head = b.head(firstPart, firstPartLoc));\n  }\n\n  get tail(): string[] {\n    return this.this ? this.parts : this.parts.slice(1);\n  }\n}\n","import type { Dict, Nullable, PresentArray } from '@glimmer/interfaces';\nimport { assert } from '@glimmer/util';\n\nimport type { ParserNodeBuilder } from '../parser';\nimport type { SourceLocation } from '../source/location';\nimport type { SourceOffset, SourceSpan } from '../source/span';\nimport type * as ASTv1 from './api';\n\nimport { PathExpressionImplV1 } from './legacy-interop';\n\nconst DEFAULT_STRIP = {\n  close: false,\n  open: false,\n};\n\n/**\n * The Parser Builder differentiates from the public builder API by:\n *\n * 1. Offering fewer different ways to instantiate nodes\n * 2. Mandating source locations\n */\nclass Builders {\n  pos(line: number, column: number) {\n    return {\n      line,\n      column,\n    };\n  }\n\n  blockItself({\n    body = [],\n    blockParams = [],\n    chained = false,\n    loc,\n  }: {\n    body?: ASTv1.Statement[] | undefined;\n    blockParams?: string[] | undefined;\n    chained?: boolean | undefined;\n    loc: SourceSpan;\n  }): ASTv1.Block {\n    return {\n      type: 'Block',\n      body: body,\n      blockParams: blockParams,\n      blockParamNodes: blockParams?.map(\n        (b) => ({ type: 'BlockParam', value: b }) as ASTv1.BlockParam\n      ),\n      chained,\n      loc,\n    };\n  }\n\n  template({\n    body,\n    blockParams,\n    loc,\n  }: {\n    body?: ASTv1.Statement[];\n    blockParams?: string[];\n    loc: SourceSpan;\n  }): ASTv1.Template {\n    return {\n      type: 'Template',\n      body: body || [],\n      blockParams: blockParams || [],\n      loc,\n    };\n  }\n\n  mustache({\n    path,\n    params,\n    hash,\n    trusting,\n    loc,\n    strip = DEFAULT_STRIP,\n  }: {\n    path: ASTv1.Expression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    trusting: boolean;\n    loc: SourceSpan;\n    strip: ASTv1.StripFlags;\n  }): ASTv1.MustacheStatement {\n    return {\n      type: 'MustacheStatement',\n      path,\n      params,\n      hash,\n      escaped: !trusting,\n      trusting,\n      loc,\n      strip: strip || { open: false, close: false },\n    };\n  }\n\n  block({\n    path,\n    params,\n    hash,\n    defaultBlock,\n    elseBlock = null,\n    loc,\n    openStrip = DEFAULT_STRIP,\n    inverseStrip = DEFAULT_STRIP,\n    closeStrip = DEFAULT_STRIP,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    defaultBlock: ASTv1.Block;\n    elseBlock?: Nullable<ASTv1.Block>;\n    loc: SourceSpan;\n    openStrip: ASTv1.StripFlags;\n    inverseStrip: ASTv1.StripFlags;\n    closeStrip: ASTv1.StripFlags;\n  }): ASTv1.BlockStatement {\n    return {\n      type: 'BlockStatement',\n      path: path,\n      params,\n      hash,\n      program: defaultBlock,\n      inverse: elseBlock,\n      loc: loc,\n      openStrip: openStrip,\n      inverseStrip: inverseStrip,\n      closeStrip: closeStrip,\n    };\n  }\n\n  comment(value: string, loc: SourceOffset): ParserNodeBuilder<ASTv1.CommentStatement> {\n    return {\n      type: 'CommentStatement',\n      value: value,\n      loc,\n    };\n  }\n\n  mustacheComment(value: string, loc: SourceSpan): ASTv1.MustacheCommentStatement {\n    return {\n      type: 'MustacheCommentStatement',\n      value: value,\n      loc,\n    };\n  }\n\n  concat(\n    parts: PresentArray<ASTv1.TextNode | ASTv1.MustacheStatement>,\n    loc: SourceSpan\n  ): ASTv1.ConcatStatement {\n    return {\n      type: 'ConcatStatement',\n      parts,\n      loc,\n    };\n  }\n\n  element({\n    tag,\n    selfClosing,\n    attrs,\n    blockParams,\n    modifiers,\n    comments,\n    children,\n    loc,\n  }: BuildElementOptions): ASTv1.ElementNode {\n    return {\n      type: 'ElementNode',\n      tag,\n      nameNode: {\n        type: 'ElementNameNode',\n        value: tag,\n      } as ASTv1.ElementNameNode,\n      startTag: {\n        type: 'ElementStartNode',\n        value: tag,\n      } as ASTv1.ElementStartNode,\n      endTag: {\n        type: 'ElementEndNode',\n        value: selfClosing ? '' : tag,\n      } as ASTv1.ElementEndNode,\n      parts: tag\n        .split('.')\n        .map((t) => ({ type: 'ElementPartNode', value: t }) as ASTv1.ElementPartNode),\n      selfClosing: selfClosing,\n      attributes: attrs || [],\n      blockParams: blockParams,\n      blockParamNodes:\n        blockParams.map((x) => ({ type: 'BlockParam', value: x }) as ASTv1.BlockParam) || [],\n      modifiers: modifiers || [],\n      comments: (comments as ASTv1.MustacheCommentStatement[]) || [],\n      children: children || [],\n      loc,\n    };\n  }\n\n  elementModifier({\n    path,\n    params,\n    hash,\n    loc,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    loc: SourceSpan;\n  }): ASTv1.ElementModifierStatement {\n    return {\n      type: 'ElementModifierStatement',\n      path,\n      params,\n      hash,\n      loc,\n    };\n  }\n\n  attr({\n    name,\n    value,\n    loc,\n  }: {\n    name: string;\n    value: ASTv1.AttrNode['value'];\n    loc: SourceSpan;\n  }): ASTv1.AttrNode {\n    return {\n      type: 'AttrNode',\n      name: name,\n      value: value,\n      loc,\n    };\n  }\n\n  text({ chars, loc }: { chars: string; loc: SourceSpan }): ASTv1.TextNode {\n    return {\n      type: 'TextNode',\n      chars,\n      loc,\n    };\n  }\n\n  sexpr({\n    path,\n    params,\n    hash,\n    loc,\n  }: {\n    path: ASTv1.PathExpression | ASTv1.SubExpression;\n    params: ASTv1.Expression[];\n    hash: ASTv1.Hash;\n    loc: SourceSpan;\n  }): ASTv1.SubExpression {\n    return {\n      type: 'SubExpression',\n      path,\n      params,\n      hash,\n      loc,\n    };\n  }\n\n  path({\n    head,\n    tail,\n    loc,\n  }: {\n    head: ASTv1.PathHead;\n    tail: string[];\n    loc: SourceSpan;\n  }): ASTv1.PathExpression {\n    let { original: originalHead } = headToString(head);\n    let original = [...originalHead, ...tail].join('.');\n\n    return new PathExpressionImplV1(original, head, tail, loc);\n  }\n\n  head(head: string, loc: SourceSpan): ASTv1.PathHead {\n    if (head[0] === '@') {\n      return this.atName(head, loc);\n    } else if (head === 'this') {\n      return this.this(loc);\n    } else {\n      return this.var(head, loc);\n    }\n  }\n\n  this(loc: SourceSpan): ASTv1.PathHead {\n    return {\n      type: 'ThisHead',\n      loc,\n    };\n  }\n\n  atName(name: string, loc: SourceSpan): ASTv1.PathHead {\n    // the `@` should be included so we have a complete source range\n    assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);\n\n    return {\n      type: 'AtHead',\n      name,\n      loc,\n    };\n  }\n\n  var(name: string, loc: SourceSpan): ASTv1.PathHead {\n    assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);\n    assert(\n      name[0] !== '@',\n      `You called builders.var() with '${name}'. Call builders.at('${name}') instead`\n    );\n\n    return {\n      type: 'VarHead',\n      name,\n      loc,\n    };\n  }\n\n  hash(pairs: ASTv1.HashPair[], loc: SourceSpan): ASTv1.Hash {\n    return {\n      type: 'Hash',\n      pairs: pairs || [],\n      loc,\n    };\n  }\n\n  pair({\n    key,\n    value,\n    loc,\n  }: {\n    key: string;\n    value: ASTv1.Expression;\n    loc: SourceSpan;\n  }): ASTv1.HashPair {\n    return {\n      type: 'HashPair',\n      key: key,\n      value,\n      loc,\n    };\n  }\n\n  literal<T extends ASTv1.Literal>({\n    type,\n    value,\n    loc,\n  }: {\n    type: T['type'];\n    value: T['value'];\n    loc?: SourceLocation;\n  }): T {\n    return {\n      type,\n      value,\n      original: value,\n      loc,\n    } as T;\n  }\n\n  undefined(): ASTv1.UndefinedLiteral {\n    return this.literal({ type: 'UndefinedLiteral', value: undefined });\n  }\n\n  null(): ASTv1.NullLiteral {\n    return this.literal({ type: 'NullLiteral', value: null });\n  }\n\n  string(value: string, loc: SourceSpan): ASTv1.StringLiteral {\n    return this.literal({ type: 'StringLiteral', value, loc });\n  }\n\n  boolean(value: boolean, loc: SourceSpan): ASTv1.BooleanLiteral {\n    return this.literal({ type: 'BooleanLiteral', value, loc });\n  }\n\n  number(value: number, loc: SourceSpan): ASTv1.NumberLiteral {\n    return this.literal({ type: 'NumberLiteral', value, loc });\n  }\n}\n\n// Nodes\n\nexport type ElementParts =\n  | ['attrs', ...AttrSexp[]]\n  | ['modifiers', ...ModifierSexp[]]\n  | ['body', ...ASTv1.Statement[]]\n  | ['comments', ...ElementComment[]]\n  | ['as', ...string[]]\n  | ['loc', SourceLocation];\n\nexport type PathSexp = string | ['path', string, LocSexp?];\n\nexport type ModifierSexp =\n  | string\n  | [PathSexp, LocSexp?]\n  | [PathSexp, ASTv1.Expression[], LocSexp?]\n  | [PathSexp, ASTv1.Expression[], Dict<ASTv1.Expression>, LocSexp?];\n\nexport type AttrSexp = [string, ASTv1.AttrNode['value'] | string, LocSexp?];\n\nexport type LocSexp = ['loc', SourceLocation];\n\nexport type ElementComment = ASTv1.MustacheCommentStatement | SourceLocation | string;\n\nexport type SexpValue =\n  | string\n  | ASTv1.Expression[]\n  | Dict<ASTv1.Expression>\n  | LocSexp\n  | PathSexp\n  | undefined;\n\nexport interface BuildElementOptions {\n  tag: string;\n  selfClosing: boolean;\n  attrs: ASTv1.AttrNode[];\n  modifiers: ASTv1.ElementModifierStatement[];\n  children: ASTv1.Statement[];\n  comments: ElementComment[];\n  blockParams: string[];\n  loc: SourceSpan;\n}\n\n// Expressions\n\nfunction headToString(head: ASTv1.PathHead): { original: string; parts: string[] } {\n  switch (head.type) {\n    case 'AtHead':\n      return { original: head.name, parts: [head.name] };\n    case 'ThisHead':\n      return { original: `this`, parts: [] };\n    case 'VarHead':\n      return { original: head.name, parts: [head.name] };\n  }\n}\n\nexport default new Builders();\n","import type { Nullable } from '@glimmer/interfaces';\nimport { asPresentArray, assert, assign, expect, getLast, unwrap } from '@glimmer/util';\nimport {\n  EntityParser,\n  EventedTokenizer,\n  HTML5NamedCharRefs as namedCharRefs,\n} from 'simple-html-tokenizer';\n\nimport type * as src from './source/api';\nimport type * as ASTv1 from './v1/api';\nimport type * as HBS from './v1/handlebars-ast';\n\nexport type ParserNodeBuilder<N extends { loc: src.SourceSpan }> = Omit<N, 'loc'> & {\n  loc: src.SourceOffset;\n};\n\nexport interface Tag<T extends 'StartTag' | 'EndTag'> {\n  readonly type: T;\n  name: string;\n  readonly attributes: ASTv1.AttrNode[];\n  readonly modifiers: ASTv1.ElementModifierStatement[];\n  readonly comments: ASTv1.MustacheCommentStatement[];\n  selfClosing: boolean;\n  readonly loc: src.SourceSpan;\n}\n\nexport interface Attribute {\n  name: string;\n  currentPart: ASTv1.TextNode | null;\n  parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[];\n  isQuoted: boolean;\n  isDynamic: boolean;\n  start: src.SourceOffset;\n  valueSpan: src.SourceSpan;\n}\n\nexport abstract class Parser {\n  protected elementStack: ASTv1.ParentNode[] = [];\n  private lines: string[];\n  readonly source: src.Source;\n  public currentAttribute: Nullable<Attribute> = null;\n  public currentNode: Nullable<\n    Readonly<\n      | ParserNodeBuilder<ASTv1.CommentStatement>\n      | ASTv1.TextNode\n      | ParserNodeBuilder<Tag<'StartTag'>>\n      | ParserNodeBuilder<Tag<'EndTag'>>\n    >\n  > = null;\n  public tokenizer: EventedTokenizer;\n\n  constructor(\n    source: src.Source,\n    entityParser = new EntityParser(namedCharRefs),\n    mode: 'precompile' | 'codemod' = 'precompile'\n  ) {\n    this.source = source;\n    this.lines = source.source.split(/\\r\\n?|\\n/u);\n    this.tokenizer = new EventedTokenizer(this, entityParser, mode);\n  }\n\n  offset(): src.SourceOffset {\n    let { line, column } = this.tokenizer;\n    return this.source.offsetFor(line, column);\n  }\n\n  pos({ line, column }: src.SourcePosition): src.SourceOffset {\n    return this.source.offsetFor(line, column);\n  }\n\n  finish<T extends { loc: src.SourceSpan }>(node: ParserNodeBuilder<T>): T {\n    return assign({}, node, {\n      loc: node.loc.until(this.offset()),\n    } as const) as unknown as T;\n\n    // node.loc = node.loc.withEnd(end);\n  }\n\n  abstract Program(node: HBS.Program): HBS.Output<'Program'>;\n  abstract MustacheStatement(node: HBS.MustacheStatement): HBS.Output<'MustacheStatement'>;\n  abstract Decorator(node: HBS.Decorator): HBS.Output<'Decorator'>;\n  abstract BlockStatement(node: HBS.BlockStatement): HBS.Output<'BlockStatement'>;\n  abstract DecoratorBlock(node: HBS.DecoratorBlock): HBS.Output<'DecoratorBlock'>;\n  abstract PartialStatement(node: HBS.PartialStatement): HBS.Output<'PartialStatement'>;\n  abstract PartialBlockStatement(\n    node: HBS.PartialBlockStatement\n  ): HBS.Output<'PartialBlockStatement'>;\n  abstract ContentStatement(node: HBS.ContentStatement): HBS.Output<'ContentStatement'>;\n  abstract CommentStatement(node: HBS.CommentStatement): HBS.Output<'CommentStatement'>;\n  abstract SubExpression(node: HBS.SubExpression): HBS.Output<'SubExpression'>;\n  abstract PathExpression(node: HBS.PathExpression): HBS.Output<'PathExpression'>;\n  abstract StringLiteral(node: HBS.StringLiteral): HBS.Output<'StringLiteral'>;\n  abstract BooleanLiteral(node: HBS.BooleanLiteral): HBS.Output<'BooleanLiteral'>;\n  abstract NumberLiteral(node: HBS.NumberLiteral): HBS.Output<'NumberLiteral'>;\n  abstract UndefinedLiteral(node: HBS.UndefinedLiteral): HBS.Output<'UndefinedLiteral'>;\n  abstract NullLiteral(node: HBS.NullLiteral): HBS.Output<'NullLiteral'>;\n\n  abstract reset(): void;\n  abstract finishData(): void;\n  abstract tagOpen(): void;\n  abstract beginData(): void;\n  abstract appendToData(char: string): void;\n  abstract beginStartTag(): void;\n  abstract appendToTagName(char: string): void;\n  abstract beginAttribute(): void;\n  abstract appendToAttributeName(char: string): void;\n  abstract beginAttributeValue(quoted: boolean): void;\n  abstract appendToAttributeValue(char: string): void;\n  abstract finishAttributeValue(): void;\n  abstract markTagAsSelfClosing(): void;\n  abstract beginEndTag(): void;\n  abstract finishTag(): void;\n  abstract beginComment(): void;\n  abstract appendToCommentData(char: string): void;\n  abstract finishComment(): void;\n  abstract reportSyntaxError(error: string): void;\n\n  get currentAttr(): Attribute {\n    return expect(this.currentAttribute, 'expected attribute');\n  }\n\n  get currentTag(): ParserNodeBuilder<Tag<'StartTag' | 'EndTag'>> {\n    let node = this.currentNode;\n    assert(node && (node.type === 'StartTag' || node.type === 'EndTag'), 'expected tag');\n    return node;\n  }\n\n  get currentStartTag(): ParserNodeBuilder<Tag<'StartTag'>> {\n    let node = this.currentNode;\n    assert(node && node.type === 'StartTag', 'expected start tag');\n    return node;\n  }\n\n  get currentEndTag(): ParserNodeBuilder<Tag<'EndTag'>> {\n    let node = this.currentNode;\n    assert(node && node.type === 'EndTag', 'expected end tag');\n    return node;\n  }\n\n  get currentComment(): ParserNodeBuilder<ASTv1.CommentStatement> {\n    let node = this.currentNode;\n    assert(node && node.type === 'CommentStatement', 'expected a comment');\n    return node;\n  }\n\n  get currentData(): ASTv1.TextNode {\n    let node = this.currentNode;\n    assert(node && node.type === 'TextNode', 'expected a text node');\n    return node;\n  }\n\n  acceptTemplate(node: HBS.Program): ASTv1.Template {\n    return this[node.type as 'Program'](node) as ASTv1.Template;\n  }\n\n  acceptNode(node: HBS.Program): ASTv1.Block | ASTv1.Template;\n  acceptNode<U extends HBS.Node | ASTv1.Node>(node: HBS.Node): U;\n  acceptNode<T extends HBS.NodeType>(node: HBS.Node<T>): HBS.Output<T> {\n    return (this[node.type as T] as (node: HBS.Node<T>) => HBS.Output<T>)(node);\n  }\n\n  currentElement(): ASTv1.ParentNode {\n    return getLast(asPresentArray(this.elementStack));\n  }\n\n  sourceForNode(node: HBS.Node, endNode?: { loc: HBS.SourceLocation }): string {\n    let firstLine = node.loc.start.line - 1;\n    let currentLine = firstLine - 1;\n    let firstColumn = node.loc.start.column;\n    let string = [];\n    let line: string;\n\n    let lastLine: number;\n    let lastColumn: number;\n\n    if (endNode) {\n      lastLine = endNode.loc.end.line - 1;\n      lastColumn = endNode.loc.end.column;\n    } else {\n      lastLine = node.loc.end.line - 1;\n      lastColumn = node.loc.end.column;\n    }\n\n    while (currentLine < lastLine) {\n      currentLine++;\n      line = unwrap(this.lines[currentLine]);\n\n      if (currentLine === firstLine) {\n        if (firstLine === lastLine) {\n          string.push(line.slice(firstColumn, lastColumn));\n        } else {\n          string.push(line.slice(firstColumn));\n        }\n      } else if (currentLine === lastLine) {\n        string.push(line.slice(0, lastColumn));\n      } else {\n        string.push(line);\n      }\n    }\n\n    return string.join('\\n');\n  }\n}\n","import type { Nullable, Recast } from '@glimmer/interfaces';\nimport type { TokenizerState } from 'simple-html-tokenizer';\nimport { getLast, isPresentArray, unwrap } from '@glimmer/util';\n\nimport type { ParserNodeBuilder, Tag } from '../parser';\nimport type * as ASTv1 from '../v1/api';\nimport type * as HBS from '../v1/handlebars-ast';\n\nimport { Parser } from '../parser';\nimport { NON_EXISTENT_LOCATION } from '../source/location';\nimport { generateSyntaxError } from '../syntax-error';\nimport { appendChild, isHBSLiteral, parseProgramBlockParamsLocs, printLiteral } from '../utils';\nimport { PathExpressionImplV1 } from '../v1/legacy-interop';\nimport b from '../v1/parser-builders';\n\nconst BEFORE_ATTRIBUTE_NAME = 'beforeAttributeName' as TokenizerState;\nconst ATTRIBUTE_VALUE_UNQUOTED = 'attributeValueUnquoted' as TokenizerState;\n\nexport abstract class HandlebarsNodeVisitors extends Parser {\n  abstract override appendToCommentData(s: string): void;\n  abstract override beginAttributeValue(quoted: boolean): void;\n  abstract override finishAttributeValue(): void;\n\n  private get isTopLevel() {\n    return this.elementStack.length === 0;\n  }\n\n  Program(program: HBS.Program): ASTv1.Block;\n  Program(program: HBS.Program): ASTv1.Template;\n  Program(program: HBS.Program): ASTv1.Template | ASTv1.Block;\n  Program(program: HBS.Program): ASTv1.Block | ASTv1.Template {\n    const body: ASTv1.Statement[] = [];\n    let node;\n\n    if (this.isTopLevel) {\n      node = b.template({\n        body,\n        blockParams: program.blockParams,\n        loc: this.source.spanFor(program.loc),\n      });\n    } else {\n      node = b.blockItself({\n        body,\n        blockParams: program.blockParams,\n        chained: program.chained,\n        loc: this.source.spanFor(program.loc),\n      });\n    }\n\n    let i,\n      l = program.body.length;\n\n    this.elementStack.push(node);\n\n    if (l === 0) {\n      return this.elementStack.pop() as ASTv1.Block | ASTv1.Template;\n    }\n\n    for (i = 0; i < l; i++) {\n      this.acceptNode(unwrap(program.body[i]));\n    }\n\n    // Ensure that that the element stack is balanced properly.\n    const poppedNode = this.elementStack.pop();\n    if (poppedNode !== node) {\n      const elementNode = poppedNode as ASTv1.ElementNode;\n\n      throw generateSyntaxError(`Unclosed element \\`${elementNode.tag}\\``, elementNode.loc);\n    }\n\n    return node;\n  }\n\n  BlockStatement(block: HBS.BlockStatement): ASTv1.BlockStatement | void {\n    if (this.tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(block));\n      return;\n    }\n\n    if (this.tokenizer.state !== 'data' && this.tokenizer.state !== 'beforeData') {\n      throw generateSyntaxError(\n        'A block may only be used inside an HTML element or another block.',\n        this.source.spanFor(block.loc)\n      );\n    }\n\n    const { path, params, hash } = acceptCallNodes(this, block);\n\n    // These are bugs in Handlebars upstream\n    if (!block.program.loc) {\n      block.program.loc = NON_EXISTENT_LOCATION;\n    }\n\n    if (block.inverse && !block.inverse.loc) {\n      block.inverse.loc = NON_EXISTENT_LOCATION;\n    }\n\n    const program = this.Program(block.program);\n    const inverse = block.inverse ? this.Program(block.inverse) : null;\n\n    const node = b.block({\n      path,\n      params,\n      hash,\n      defaultBlock: program,\n      elseBlock: inverse,\n      loc: this.source.spanFor(block.loc),\n      openStrip: block.openStrip,\n      inverseStrip: block.inverseStrip,\n      closeStrip: block.closeStrip,\n    });\n    parseProgramBlockParamsLocs(this.source, node);\n\n    const parentProgram = this.currentElement();\n\n    appendChild(parentProgram, node);\n  }\n\n  MustacheStatement(rawMustache: HBS.MustacheStatement): ASTv1.MustacheStatement | void {\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawMustache));\n      return;\n    }\n\n    let mustache: ASTv1.MustacheStatement;\n    const { escaped, loc, strip } = rawMustache;\n\n    if (isHBSLiteral(rawMustache.path)) {\n      mustache = b.mustache({\n        path: this.acceptNode<ASTv1.Literal>(rawMustache.path),\n        params: [],\n        hash: b.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    } else {\n      const { path, params, hash } = acceptCallNodes(\n        this,\n        rawMustache as HBS.MustacheStatement & {\n          path: HBS.PathExpression | HBS.SubExpression;\n        }\n      );\n      mustache = b.mustache({\n        path,\n        params,\n        hash,\n        trusting: !escaped,\n        loc: this.source.spanFor(loc),\n        strip,\n      });\n    }\n\n    switch (tokenizer.state) {\n      // Tag helpers\n      case 'tagOpen':\n      case 'tagName':\n        throw generateSyntaxError(`Cannot use mustaches in an elements tagname`, mustache.loc);\n\n      case 'beforeAttributeName':\n        addElementModifier(this.currentStartTag, mustache);\n        break;\n      case 'attributeName':\n      case 'afterAttributeName':\n        this.beginAttributeValue(false);\n        this.finishAttributeValue();\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n      case 'afterAttributeValueQuoted':\n        addElementModifier(this.currentStartTag, mustache);\n        tokenizer.transitionTo(BEFORE_ATTRIBUTE_NAME);\n        break;\n\n      // Attribute values\n      case 'beforeAttributeValue':\n        this.beginAttributeValue(false);\n        this.appendDynamicAttributeValuePart(mustache);\n        tokenizer.transitionTo(ATTRIBUTE_VALUE_UNQUOTED);\n        break;\n      case 'attributeValueDoubleQuoted':\n      case 'attributeValueSingleQuoted':\n      case 'attributeValueUnquoted':\n        this.appendDynamicAttributeValuePart(mustache);\n        break;\n\n      // TODO: Only append child when the tokenizer state makes\n      // sense to do so, otherwise throw an error.\n      default:\n        appendChild(this.currentElement(), mustache);\n    }\n\n    return mustache;\n  }\n\n  appendDynamicAttributeValuePart(part: ASTv1.MustacheStatement): void {\n    this.finalizeTextPart();\n    const attr = this.currentAttr;\n    attr.isDynamic = true;\n    attr.parts.push(part);\n  }\n\n  finalizeTextPart(): void {\n    const attr = this.currentAttr;\n    const text = attr.currentPart;\n    if (text !== null) {\n      this.currentAttr.parts.push(text);\n      this.startTextPart();\n    }\n  }\n\n  startTextPart(): void {\n    this.currentAttr.currentPart = null;\n  }\n\n  ContentStatement(content: HBS.ContentStatement): void {\n    updateTokenizerLocation(this.tokenizer, content);\n\n    this.tokenizer.tokenizePart(content.value);\n    this.tokenizer.flushData();\n  }\n\n  CommentStatement(rawComment: HBS.CommentStatement): Nullable<ASTv1.MustacheCommentStatement> {\n    const { tokenizer } = this;\n\n    if (tokenizer.state === 'comment') {\n      this.appendToCommentData(this.sourceForNode(rawComment));\n      return null;\n    }\n\n    const { value, loc } = rawComment;\n    const comment = b.mustacheComment(value, this.source.spanFor(loc));\n\n    switch (tokenizer.state) {\n      case 'beforeAttributeName':\n      case 'afterAttributeName':\n        this.currentStartTag.comments.push(comment);\n        break;\n\n      case 'beforeData':\n      case 'data':\n        appendChild(this.currentElement(), comment);\n        break;\n\n      default:\n        throw generateSyntaxError(\n          `Using a Handlebars comment when in the \\`${tokenizer['state']}\\` state is not supported`,\n          this.source.spanFor(rawComment.loc)\n        );\n    }\n\n    return comment;\n  }\n\n  PartialStatement(partial: HBS.PartialStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partials are not supported`,\n      this.source.spanFor(partial.loc)\n    );\n  }\n\n  PartialBlockStatement(partialBlock: HBS.PartialBlockStatement): never {\n    throw generateSyntaxError(\n      `Handlebars partial blocks are not supported`,\n      this.source.spanFor(partialBlock.loc)\n    );\n  }\n\n  Decorator(decorator: HBS.Decorator): never {\n    throw generateSyntaxError(\n      `Handlebars decorators are not supported`,\n      this.source.spanFor(decorator.loc)\n    );\n  }\n\n  DecoratorBlock(decoratorBlock: HBS.DecoratorBlock): never {\n    throw generateSyntaxError(\n      `Handlebars decorator blocks are not supported`,\n      this.source.spanFor(decoratorBlock.loc)\n    );\n  }\n\n  SubExpression(sexpr: HBS.SubExpression): ASTv1.SubExpression {\n    const { path, params, hash } = acceptCallNodes(this, sexpr);\n    return b.sexpr({ path, params, hash, loc: this.source.spanFor(sexpr.loc) });\n  }\n\n  PathExpression(path: HBS.PathExpression): ASTv1.PathExpression {\n    const { original } = path;\n    let parts: string[];\n\n    if (original.indexOf('/') !== -1) {\n      if (original.slice(0, 2) === './') {\n        throw generateSyntaxError(\n          `Using \"./\" is not supported in Glimmer and unnecessary`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.slice(0, 3) === '../') {\n        throw generateSyntaxError(\n          `Changing context using \"../\" is not supported in Glimmer`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      if (original.indexOf('.') !== -1) {\n        throw generateSyntaxError(\n          `Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`,\n          this.source.spanFor(path.loc)\n        );\n      }\n      parts = [path.parts.join('/')];\n    } else if (original === '.') {\n      throw generateSyntaxError(\n        `'.' is not a supported path in Glimmer; check for a path with a trailing '.'`,\n        this.source.spanFor(path.loc)\n      );\n    } else {\n      parts = path.parts;\n    }\n\n    let thisHead = false;\n\n    // This is to fix a bug in the Handlebars AST where the path expressions in\n    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)\n    // are simply turned into `{{foo}}`. The fix is to push it back onto the\n    // parts array and let the runtime see the difference. However, we cannot\n    // simply use the string `this` as it means literally the property called\n    // \"this\" in the current context (it can be expressed in the syntax as\n    // `{{[this]}}`, where the square bracket are generally for this kind of\n    // escaping  such as `{{foo.[\"bar.baz\"]}}` would mean lookup a property\n    // named literally \"bar.baz\" on `this.foo`). By convention, we use `null`\n    // for this purpose.\n    if (/^this(?:\\..+)?$/u.test(original)) {\n      thisHead = true;\n    }\n\n    let pathHead: ASTv1.PathHead;\n    if (thisHead) {\n      pathHead = {\n        type: 'ThisHead',\n        loc: {\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + 4 },\n        },\n      };\n    } else if (path.data) {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = {\n        type: 'AtHead',\n        name: `@${head}`,\n        loc: {\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length + 1 },\n        },\n      };\n    } else {\n      const head = parts.shift();\n\n      if (head === undefined) {\n        throw generateSyntaxError(\n          `Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`,\n          this.source.spanFor(path.loc)\n        );\n      }\n\n      pathHead = {\n        type: 'VarHead',\n        name: head,\n        loc: {\n          start: path.loc.start,\n          end: { line: path.loc.start.line, column: path.loc.start.column + head.length },\n        },\n      };\n    }\n\n    return new PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));\n  }\n\n  Hash(hash: HBS.Hash): ASTv1.Hash {\n    const pairs = hash.pairs.map((pair) =>\n      b.pair({\n        key: pair.key,\n        value: this.acceptNode(pair.value),\n        loc: this.source.spanFor(pair.loc),\n      })\n    );\n\n    return b.hash(pairs, this.source.spanFor(hash.loc));\n  }\n\n  StringLiteral(string: HBS.StringLiteral): ASTv1.StringLiteral {\n    return b.literal({ type: 'StringLiteral', value: string.value, loc: string.loc });\n  }\n\n  BooleanLiteral(boolean: HBS.BooleanLiteral): ASTv1.BooleanLiteral {\n    return b.literal({ type: 'BooleanLiteral', value: boolean.value, loc: boolean.loc });\n  }\n\n  NumberLiteral(number: HBS.NumberLiteral): ASTv1.NumberLiteral {\n    return b.literal({ type: 'NumberLiteral', value: number.value, loc: number.loc });\n  }\n\n  UndefinedLiteral(undef: HBS.UndefinedLiteral): ASTv1.UndefinedLiteral {\n    return b.literal({ type: 'UndefinedLiteral', value: undefined, loc: undef.loc });\n  }\n\n  NullLiteral(nul: HBS.NullLiteral): ASTv1.NullLiteral {\n    return b.literal({ type: 'NullLiteral', value: null, loc: nul.loc });\n  }\n}\n\nfunction calculateRightStrippedOffsets(original: string, value: string) {\n  if (value === '') {\n    // if it is empty, just return the count of newlines\n    // in original\n    return {\n      lines: original.split('\\n').length - 1,\n      columns: 0,\n    };\n  }\n\n  // otherwise, return the number of newlines prior to\n  // `value`\n  const [difference] = original.split(value) as [string];\n  const lines = difference.split(/\\n/u);\n  const lineCount = lines.length - 1;\n\n  return {\n    lines: lineCount,\n    columns: unwrap(lines[lineCount]).length,\n  };\n}\n\nfunction updateTokenizerLocation(tokenizer: Parser['tokenizer'], content: HBS.ContentStatement) {\n  let line = content.loc.start.line;\n  let column = content.loc.start.column;\n\n  const offsets = calculateRightStrippedOffsets(\n    content.original as Recast<HBS.StripFlags, string>,\n    content.value\n  );\n\n  line = line + offsets.lines;\n  if (offsets.lines) {\n    column = offsets.columns;\n  } else {\n    column = column + offsets.columns;\n  }\n\n  tokenizer.line = line;\n  tokenizer.column = column;\n}\n\nfunction acceptCallNodes(\n  compiler: HandlebarsNodeVisitors,\n  node: {\n    path:\n      | HBS.PathExpression\n      | HBS.SubExpression\n      | HBS.StringLiteral\n      | HBS.UndefinedLiteral\n      | HBS.NullLiteral\n      | HBS.NumberLiteral\n      | HBS.BooleanLiteral;\n    params: HBS.Expression[];\n    hash: HBS.Hash;\n  }\n): {\n  path: ASTv1.PathExpression | ASTv1.SubExpression;\n  params: ASTv1.Expression[];\n  hash: ASTv1.Hash;\n} {\n  if (node.path.type.endsWith('Literal')) {\n    const path = node.path as unknown as\n      | HBS.StringLiteral\n      | HBS.UndefinedLiteral\n      | HBS.NullLiteral\n      | HBS.NumberLiteral\n      | HBS.BooleanLiteral;\n\n    let value = '';\n    if (path.type === 'BooleanLiteral') {\n      value = path.original.toString();\n    } else if (path.type === 'StringLiteral') {\n      value = `\"${path.original}\"`;\n    } else if (path.type === 'NullLiteral') {\n      value = 'null';\n    } else if (path.type === 'NumberLiteral') {\n      value = path.value.toString();\n    } else {\n      value = 'undefined';\n    }\n    throw generateSyntaxError(\n      `${path.type} \"${\n        path.type === 'StringLiteral' ? path.original : value\n      }\" cannot be called as a sub-expression, replace (${value}) with ${value}`,\n      compiler.source.spanFor(path.loc)\n    );\n  }\n\n  const path =\n    node.path.type === 'PathExpression'\n      ? compiler.PathExpression(node.path)\n      : compiler.SubExpression(node.path as unknown as HBS.SubExpression);\n  const params = node.params\n    ? node.params.map((e) => compiler.acceptNode<ASTv1.Expression>(e))\n    : [];\n\n  // if there is no hash, position it as a collapsed node immediately after the last param (or the\n  // path, if there are also no params)\n  const end = isPresentArray(params) ? getLast(params).loc : path.loc;\n\n  const hash = node.hash\n    ? compiler.Hash(node.hash)\n    : ({\n        type: 'Hash',\n        pairs: [] as ASTv1.HashPair[],\n        loc: compiler.source.spanFor(end).collapse('end'),\n      } as const);\n\n  return { path, params, hash };\n}\n\nfunction addElementModifier(\n  element: ParserNodeBuilder<Tag<'StartTag'>>,\n  mustache: ASTv1.MustacheStatement\n) {\n  const { path, params, hash, loc } = mustache;\n\n  if (isHBSLiteral(path)) {\n    const modifier = `{{${printLiteral(path)}}}`;\n    const tag = `<${element.name} ... ${modifier} ...`;\n\n    throw generateSyntaxError(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);\n  }\n\n  const modifier = b.elementModifier({ path, params, hash, loc });\n  element.modifiers.push(modifier);\n}\n","import type { Nullable } from '@glimmer/interfaces';\nimport { assertPresentArray, assign, getFirst, getLast, isPresentArray } from '@glimmer/util';\nimport { parse, parseWithoutProcessing } from '@handlebars/parser';\nimport { EntityParser } from 'simple-html-tokenizer';\n\nimport type { Tag } from '../parser';\nimport type { NodeVisitor } from '../traversal/visitor';\nimport type * as ASTv1 from '../v1/api';\nimport type * as HBS from '../v1/handlebars-ast';\n\nimport print from '../generation/print';\nimport { voidMap } from '../generation/printer';\nimport * as src from '../source/api';\nimport { generateSyntaxError } from '../syntax-error';\nimport traverse from '../traversal/traverse';\nimport Walker from '../traversal/walker';\nimport { appendChild, parseElementBlockParams, parseElementPartLocs } from '../utils';\nimport b from '../v1/parser-builders';\nimport publicBuilder from '../v1/public-builders';\nimport { HandlebarsNodeVisitors } from './handlebars-node-visitors';\n\nexport class TokenizerEventHandlers extends HandlebarsNodeVisitors {\n  private tagOpenLine = 0;\n  private tagOpenColumn = 0;\n\n  reset(): void {\n    this.currentNode = null;\n  }\n\n  // Comment\n\n  beginComment(): void {\n    this.currentNode = b.comment('', this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn));\n  }\n\n  appendToCommentData(char: string): void {\n    this.currentComment.value += char;\n  }\n\n  finishComment(): void {\n    appendChild(this.currentElement(), this.finish(this.currentComment));\n  }\n\n  // Data\n\n  beginData(): void {\n    this.currentNode = b.text({\n      chars: '',\n      loc: this.offset().collapsed(),\n    });\n  }\n\n  appendToData(char: string): void {\n    this.currentData.chars += char;\n  }\n\n  finishData(): void {\n    this.currentData.loc = this.currentData.loc.withEnd(this.offset());\n\n    appendChild(this.currentElement(), this.currentData);\n  }\n\n  // Tags - basic\n\n  tagOpen(): void {\n    this.tagOpenLine = this.tokenizer.line;\n    this.tagOpenColumn = this.tokenizer.column;\n  }\n\n  beginStartTag(): void {\n    this.currentNode = {\n      type: 'StartTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn),\n    };\n  }\n\n  beginEndTag(): void {\n    this.currentNode = {\n      type: 'EndTag',\n      name: '',\n      attributes: [],\n      modifiers: [],\n      comments: [],\n      selfClosing: false,\n      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn),\n    };\n  }\n\n  finishTag(): void {\n    let tag = this.finish(this.currentTag);\n\n    if (tag.type === 'StartTag') {\n      this.finishStartTag();\n\n      if (tag.name === ':') {\n        throw generateSyntaxError(\n          'Invalid named block named detected, you may have created a named block without a name, or you may have began your name with a number. Named blocks must have names that are at least one character long, and begin with a lower case letter',\n          this.source.spanFor({\n            start: this.currentTag.loc.toJSON(),\n            end: this.offset().toJSON(),\n          })\n        );\n      }\n\n      if (voidMap.has(tag.name) || tag.selfClosing) {\n        this.finishEndTag(true);\n      }\n    } else if (tag.type === 'EndTag') {\n      this.finishEndTag(false);\n    }\n  }\n\n  finishStartTag(): void {\n    let {\n      name,\n      attributes: attrs,\n      modifiers,\n      comments,\n      selfClosing,\n      loc,\n    } = this.finish(this.currentStartTag);\n\n    let element = b.element({\n      tag: name,\n      selfClosing,\n      attrs,\n      modifiers,\n      comments,\n      children: [],\n      blockParams: [],\n      loc,\n    });\n    element.startTag = {\n      type: 'ElementStartNode',\n      value: name,\n      loc: loc,\n    };\n    element.nameNode = {\n      type: 'ElementNameNode',\n      value: name,\n      loc: loc\n        .withStart(this.source.offsetFor(loc.startPosition.line, loc.startPosition.column + 1))\n        .withEnd(\n          this.source.offsetFor(loc.startPosition.line, loc.startPosition.column + 1 + name.length)\n        ),\n    };\n    parseElementPartLocs(this.source, element);\n    this.elementStack.push(element);\n  }\n\n  finishEndTag(isVoid: boolean): void {\n    let tag = this.finish(this.currentTag);\n\n    let element = this.elementStack.pop() as ASTv1.ElementNode;\n\n    element.endTag = {\n      type: 'ElementEndNode',\n      loc: tag.loc,\n      value: element.selfClosing ? '' : tag.name,\n    };\n\n    this.validateEndTag(tag, element, isVoid);\n    let parent = this.currentElement();\n\n    element.loc = element.loc.withEnd(this.offset());\n    parseElementBlockParams(element);\n    appendChild(parent, element);\n  }\n\n  markTagAsSelfClosing(): void {\n    this.currentTag.selfClosing = true;\n  }\n\n  // Tags - name\n\n  appendToTagName(char: string): void {\n    this.currentTag.name += char;\n  }\n\n  // Tags - attributes\n\n  beginAttribute(): void {\n    let offset = this.offset();\n\n    this.currentAttribute = {\n      name: '',\n      parts: [],\n      currentPart: null,\n      isQuoted: false,\n      isDynamic: false,\n      start: offset,\n      valueSpan: offset.collapsed(),\n    };\n  }\n\n  appendToAttributeName(char: string): void {\n    this.currentAttr.name += char;\n  }\n\n  beginAttributeValue(isQuoted: boolean): void {\n    this.currentAttr.isQuoted = isQuoted;\n    this.startTextPart();\n    this.currentAttr.valueSpan = this.offset().collapsed();\n  }\n\n  appendToAttributeValue(char: string): void {\n    let parts = this.currentAttr.parts;\n    let lastPart = parts[parts.length - 1];\n\n    let current = this.currentAttr.currentPart;\n\n    if (current) {\n      current.chars += char;\n\n      // update end location for each added char\n      current.loc = current.loc.withEnd(this.offset());\n    } else {\n      // initially assume the text node is a single char\n      let loc: src.SourceOffset = this.offset();\n\n      // the tokenizer line/column have already been advanced, correct location info\n      if (char === '\\n') {\n        loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();\n      } else {\n        loc = loc.move(-1);\n      }\n\n      this.currentAttr.currentPart = b.text({ chars: char, loc: loc.collapsed() });\n    }\n  }\n\n  finishAttributeValue(): void {\n    this.finalizeTextPart();\n\n    let tag = this.currentTag;\n    let tokenizerPos = this.offset();\n\n    if (tag.type === 'EndTag') {\n      throw generateSyntaxError(\n        `Invalid end tag: closing tag must not have attributes`,\n        this.source.spanFor({ start: tag.loc.toJSON(), end: tokenizerPos.toJSON() })\n      );\n    }\n\n    let { name, parts, start, isQuoted, isDynamic, valueSpan } = this.currentAttr;\n    let value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));\n    value.loc = valueSpan.withEnd(tokenizerPos);\n\n    let attribute = b.attr({ name, value, loc: start.until(tokenizerPos) });\n\n    this.currentStartTag.attributes.push(attribute);\n  }\n\n  reportSyntaxError(message: string): void {\n    throw generateSyntaxError(message, this.offset().collapsed());\n  }\n\n  assembleConcatenatedValue(\n    parts: (ASTv1.MustacheStatement | ASTv1.TextNode)[]\n  ): ASTv1.ConcatStatement {\n    for (const part of parts) {\n      if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {\n        throw generateSyntaxError(\n          `Unsupported node in quoted attribute value: ${part['type'] as string}`,\n          (part as ASTv1.BaseNode).loc\n        );\n      }\n    }\n\n    assertPresentArray(parts, `the concatenation parts of an element should not be empty`);\n\n    let first = getFirst(parts);\n    let last = getLast(parts);\n\n    return b.concat(parts, this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)));\n  }\n\n  validateEndTag(\n    tag: Tag<'StartTag' | 'EndTag'>,\n    element: ASTv1.ElementNode,\n    selfClosing: boolean\n  ): void {\n    if (voidMap.has(tag.name) && !selfClosing) {\n      // EngTag is also called by StartTag for void and self-closing tags (i.e.\n      // <input> or <br />, so we need to check for that here. Otherwise, we would\n      // throw an error for those cases.\n      throw generateSyntaxError(\n        `<${tag.name}> elements do not need end tags. You should remove it`,\n        tag.loc\n      );\n    } else if (element.tag === undefined) {\n      throw generateSyntaxError(`Closing tag </${tag.name}> without an open tag`, tag.loc);\n    } else if (element.tag !== tag.name) {\n      throw generateSyntaxError(\n        `Closing tag </${tag.name}> did not match last open tag <${element.tag}> (on line ${element.loc.startPosition.line})`,\n        tag.loc\n      );\n    }\n  }\n\n  assembleAttributeValue(\n    parts: ASTv1.AttrPart[],\n    isQuoted: boolean,\n    isDynamic: boolean,\n    span: src.SourceSpan\n  ): ASTv1.AttrValue {\n    if (isDynamic) {\n      if (isQuoted) {\n        return this.assembleConcatenatedValue(parts);\n      } else {\n        assertPresentArray(parts);\n\n        const [head, a] = parts;\n        if (a === undefined || (a.type === 'TextNode' && a.chars === '/')) {\n          return head;\n        } else {\n          throw generateSyntaxError(\n            `An unquoted attribute value must be a string or a mustache, ` +\n              `preceded by whitespace or a '=' character, and ` +\n              `followed by whitespace, a '>' character, or '/>'`,\n            span\n          );\n        }\n      }\n    } else if (isPresentArray(parts)) {\n      return parts[0];\n    } else {\n      return b.text({ chars: '', loc: span });\n    }\n  }\n}\n\n/**\n  ASTPlugins can make changes to the Glimmer template AST before\n  compilation begins.\n*/\nexport interface ASTPluginBuilder<TEnv extends ASTPluginEnvironment = ASTPluginEnvironment> {\n  (env: TEnv): ASTPlugin;\n}\n\nexport interface ASTPlugin {\n  name: string;\n  visitor: NodeVisitor;\n}\n\nexport interface ASTPluginEnvironment {\n  meta?: object;\n  syntax: Syntax;\n}\n\ninterface HandlebarsParseOptions {\n  srcName?: string;\n  ignoreStandalone?: boolean;\n}\n\nexport interface TemplateIdFn {\n  (src: string): Nullable<string>;\n}\n\nexport interface PrecompileOptions extends PreprocessOptions {\n  id?: TemplateIdFn;\n  customizeComponentName?: ((input: string) => string) | undefined;\n}\n\nexport interface PrecompileOptionsWithLexicalScope extends PrecompileOptions {\n  lexicalScope: (variable: string) => boolean;\n}\n\nexport interface PreprocessOptions {\n  strictMode?: boolean;\n  locals?: string[];\n  meta?: {\n    moduleName?: string;\n  };\n  plugins?: {\n    ast?: ASTPluginBuilder[];\n  };\n  parseOptions?: HandlebarsParseOptions;\n  customizeComponentName?: ((input: string) => string) | undefined;\n\n  /**\n    Useful for specifying a group of options together.\n\n    When `'codemod'` we disable all whitespace control in handlebars\n    (to preserve as much as possible) and we also avoid any\n    escaping/unescaping of HTML entity codes.\n   */\n  mode?: 'codemod' | 'precompile';\n}\n\nexport interface Syntax {\n  parse: typeof preprocess;\n  builders: typeof publicBuilder;\n  print: typeof print;\n  traverse: typeof traverse;\n  Walker: typeof Walker;\n}\n\nconst syntax: Syntax = {\n  parse: preprocess,\n  builders: publicBuilder,\n  print,\n  traverse,\n  Walker,\n};\n\nclass CodemodEntityParser extends EntityParser {\n  // match upstream types, but never match an entity\n  constructor() {\n    super({});\n  }\n\n  override parse(): string | undefined {\n    return undefined;\n  }\n}\n\nexport function preprocess(\n  input: string | src.Source | HBS.Program,\n  options: PreprocessOptions = {}\n): ASTv1.Template {\n  let mode = options.mode || 'precompile';\n\n  let source: src.Source;\n  let ast: HBS.Program;\n  if (typeof input === 'string') {\n    source = new src.Source(input, options.meta?.moduleName);\n\n    if (mode === 'codemod') {\n      ast = parseWithoutProcessing(input, options.parseOptions) as HBS.Program;\n    } else {\n      ast = parse(input, options.parseOptions) as HBS.Program;\n    }\n  } else if (input instanceof src.Source) {\n    source = input;\n\n    if (mode === 'codemod') {\n      ast = parseWithoutProcessing(input.source, options.parseOptions) as HBS.Program;\n    } else {\n      ast = parse(input.source, options.parseOptions) as HBS.Program;\n    }\n  } else {\n    source = new src.Source('', options.meta?.moduleName);\n    ast = input;\n  }\n\n  let entityParser = undefined;\n  if (mode === 'codemod') {\n    entityParser = new CodemodEntityParser();\n  }\n\n  let offsets = src.SourceSpan.forCharPositions(source, 0, source.source.length);\n  ast.loc = {\n    source: '(program)',\n    start: offsets.startPosition,\n    end: offsets.endPosition,\n  };\n\n  let program = new TokenizerEventHandlers(source, entityParser, mode).acceptTemplate(ast);\n\n  if (options.strictMode) {\n    program.blockParams = options.locals ?? [];\n  }\n\n  if (options && options.plugins && options.plugins.ast) {\n    for (const transform of options.plugins.ast) {\n      let env: ASTPluginEnvironment = assign({}, options, { syntax }, { plugins: undefined });\n\n      let pluginResult = transform(env);\n\n      traverse(program, pluginResult.visitor);\n    }\n  }\n\n  return program;\n}\n","import type * as ASTv1 from './v1/api';\n\nimport { isKeyword } from './keywords';\nimport { preprocess } from './parser/tokenizer-event-handlers';\nimport traverse from './traversal/traverse';\n\ninterface GetTemplateLocalsOptions {\n  includeKeywords?: boolean;\n  includeHtmlElements?: boolean;\n}\n\n/**\n * Gets the correct Token from the Node based on it's type\n */\nfunction tokensFromType(\n  node: ASTv1.Node,\n  scopedTokens: string[],\n  options: GetTemplateLocalsOptions\n): string | void {\n  if (node.type === 'PathExpression') {\n    if (node.head.type === 'AtHead' || node.head.type === 'ThisHead') {\n      return;\n    }\n\n    const possbleToken = node.head.name;\n\n    if (scopedTokens.indexOf(possbleToken) === -1) {\n      return possbleToken;\n    }\n  } else if (node.type === 'ElementNode') {\n    const { tag } = node;\n\n    const char = tag.charAt(0);\n\n    if (char === ':' || char === '@') {\n      return;\n    }\n\n    if (!options.includeHtmlElements && tag.indexOf('.') === -1 && tag.toLowerCase() === tag) {\n      return;\n    }\n\n    if (tag.substr(0, 5) === 'this.') {\n      return;\n    }\n\n    // the tag may be from a yielded object\n    // example:\n    //   <x.button>\n    // An ElementNode does not parse the \"tag\" in to a PathExpression\n    // so we have to split on `.`, just like how `this` presence is checked.\n    if (tag.includes('.')) {\n      let [potentialLocal] = tag.split('.') as [string, ...string[]];\n\n      if (scopedTokens.includes(potentialLocal)) return;\n    }\n\n    if (scopedTokens.includes(tag)) return;\n\n    return tag;\n  }\n}\n\n/**\n * Adds tokens to the tokensSet based on their node.type\n */\nfunction addTokens(\n  tokensSet: Set<string>,\n  node: ASTv1.Node,\n  scopedTokens: string[],\n  options: GetTemplateLocalsOptions\n) {\n  const maybeTokens = tokensFromType(node, scopedTokens, options);\n\n  (Array.isArray(maybeTokens) ? maybeTokens : [maybeTokens]).forEach((maybeToken) => {\n    if (maybeToken !== undefined && maybeToken[0] !== '@') {\n      const maybeTokenFirstSegment = maybeToken.split('.')[0];\n      if (!scopedTokens.includes(maybeTokenFirstSegment)) {\n        tokensSet.add(maybeToken.split('.')[0]);\n      }\n    }\n  });\n}\n\n/**\n * Parses and traverses a given handlebars html template to extract all template locals\n * referenced that could possible come from the parent scope. Can exclude known keywords\n * optionally.\n */\nexport function getTemplateLocals(\n  html: string,\n  options: GetTemplateLocalsOptions = {\n    includeHtmlElements: false,\n    includeKeywords: false,\n  }\n): string[] {\n  const ast = preprocess(html);\n  const tokensSet = new Set<string>();\n  const scopedTokens: string[] = [];\n\n  traverse(ast, {\n    Block: {\n      enter({ blockParams }) {\n        blockParams.forEach((param) => {\n          scopedTokens.push(param);\n        });\n      },\n\n      exit({ blockParams }) {\n        blockParams.forEach(() => {\n          scopedTokens.pop();\n        });\n      },\n    },\n\n    ElementNode: {\n      enter(node) {\n        node.blockParams.forEach((param) => {\n          scopedTokens.push(param);\n        });\n        addTokens(tokensSet, node, scopedTokens, options);\n      },\n\n      exit({ blockParams }) {\n        blockParams.forEach(() => {\n          scopedTokens.pop();\n        });\n      },\n    },\n\n    PathExpression(node) {\n      addTokens(tokensSet, node, scopedTokens, options);\n    },\n  });\n\n  let tokens: string[] = [];\n\n  tokensSet.forEach((s) => tokens.push(s));\n\n  if (!options?.includeKeywords) {\n    tokens = tokens.filter((token) => !isKeyword(token));\n  }\n\n  return tokens;\n}\n","import { assign } from '@glimmer/util';\n\nimport type { SourceSpan } from '../../source/span';\n\nexport interface BaseNodeFields {\n  loc: SourceSpan;\n}\n\n/**\n * This is a convenience function for creating ASTv2 nodes, with an optional name and the node's\n * options.\n *\n * ```ts\n * export class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}\n * ```\n *\n * This creates a new ASTv2 node with the name `'HtmlText'` and one field `chars: string` (in\n * addition to a `loc: SourceOffsets` field, which all nodes have).\n *\n * ```ts\n * export class Args extends node().fields<{\n *  positional: PositionalArguments;\n *  named: NamedArguments\n * }>() {}\n * ```\n *\n * This creates a new un-named ASTv2 node with two fields (`positional: Positional` and `named:\n * Named`, in addition to the generic `loc: SourceOffsets` field).\n *\n * Once you create a node using `node`, it is instantiated with all of its fields (including `loc`):\n *\n * ```ts\n * new HtmlText({ loc: offsets, chars: someString });\n * ```\n */\nexport function node(): {\n  fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;\n};\nexport function node<T extends string>(\n  name: T\n): {\n  fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;\n};\n\nexport function node<T extends string>(\n  name?: T\n):\n  | {\n      fields<Fields extends object>(): TypedNodeConstructor<T, Fields & BaseNodeFields>;\n    }\n  | {\n      fields<Fields extends object>(): NodeConstructor<Fields & BaseNodeFields>;\n    } {\n  if (name !== undefined) {\n    const type = name;\n    return {\n      fields<Fields extends object>(): TypedNodeConstructor<T, BaseNodeFields & Fields> {\n        return class {\n          // SAFETY: initialized via `assign` in the constructor.\n          declare readonly loc: SourceSpan;\n          readonly type: T;\n\n          constructor(fields: BaseNodeFields & Fields) {\n            this.type = type;\n            assign(this, fields);\n          }\n        } as TypedNodeConstructor<T, BaseNodeFields & Fields>;\n      },\n    };\n  } else {\n    return {\n      fields<Fields>(): NodeConstructor<Fields & BaseNodeFields> {\n        return class {\n          // SAFETY: initialized via `assign` in the constructor.\n          declare readonly loc: SourceSpan;\n\n          constructor(fields: BaseNodeFields & Fields) {\n            assign(this, fields);\n          }\n        } as NodeConstructor<BaseNodeFields & Fields>;\n      },\n    };\n  }\n}\n\nexport interface NodeConstructor<Fields> {\n  new (fields: Fields): Readonly<Fields>;\n}\n\ntype TypedNode<T extends string, Fields> = { type: T } & Readonly<Fields>;\n\nexport interface TypedNodeConstructor<T extends string, Fields> {\n  new (options: Fields): TypedNode<T, Fields>;\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { SourceSpan } from '../../source/span';\nimport type { ExpressionNode } from './expr';\n\nimport { node } from './node';\n\n/**\n * Corresponds to syntaxes with positional and named arguments:\n *\n * - SubExpression\n * - Invoking Append\n * - Invoking attributes\n * - InvokeBlock\n *\n * If `Args` is empty, the `SourceOffsets` for this node should be the collapsed position\n * immediately after the parent call node's `callee`.\n */\nexport class Args extends node().fields<{\n  positional: PositionalArguments;\n  named: NamedArguments;\n}>() {\n  static empty(loc: SourceSpan): Args {\n    return new Args({\n      loc,\n      positional: PositionalArguments.empty(loc),\n      named: NamedArguments.empty(loc),\n    });\n  }\n\n  static named(named: NamedArguments): Args {\n    return new Args({\n      loc: named.loc,\n      positional: PositionalArguments.empty(named.loc.collapse('end')),\n      named,\n    });\n  }\n\n  nth(offset: number): ExpressionNode | null {\n    return this.positional.nth(offset);\n  }\n\n  get(name: string): ExpressionNode | null {\n    return this.named.get(name);\n  }\n\n  isEmpty(): boolean {\n    return this.positional.isEmpty() && this.named.isEmpty();\n  }\n}\n\n/**\n * Corresponds to positional arguments.\n *\n * If `PositionalArguments` is empty, the `SourceOffsets` for this node should be the collapsed\n * position immediately after the parent call node's `callee`.\n */\nexport class PositionalArguments extends node().fields<{\n  exprs: readonly ExpressionNode[];\n}>() {\n  static empty(loc: SourceSpan): PositionalArguments {\n    return new PositionalArguments({\n      loc,\n      exprs: [],\n    });\n  }\n\n  get size(): number {\n    return this.exprs.length;\n  }\n\n  nth(offset: number): ExpressionNode | null {\n    return this.exprs[offset] || null;\n  }\n\n  isEmpty(): boolean {\n    return this.exprs.length === 0;\n  }\n}\n\n/**\n * Corresponds to named arguments.\n *\n * If `PositionalArguments` and `NamedArguments` are empty, the `SourceOffsets` for this node should\n * be the same as the `Args` node that contains this node.\n *\n * If `PositionalArguments` is not empty but `NamedArguments` is empty, the `SourceOffsets` for this\n * node should be the collapsed position immediately after the last positional argument.\n */\nexport class NamedArguments extends node().fields<{\n  entries: readonly NamedArgument[];\n}>() {\n  static empty(loc: SourceSpan): NamedArguments {\n    return new NamedArguments({\n      loc,\n      entries: [],\n    });\n  }\n\n  get size(): number {\n    return this.entries.length;\n  }\n\n  get(name: string): ExpressionNode | null {\n    let entry = this.entries.filter((e) => e.name.chars === name)[0];\n\n    return entry ? entry.value : null;\n  }\n\n  isEmpty(): boolean {\n    return this.entries.length === 0;\n  }\n}\n\n/**\n * Corresponds to a single named argument.\n *\n * ```hbs\n * x=<expr>\n * ```\n */\nexport class NamedArgument {\n  readonly loc: SourceSpan;\n  readonly name: SourceSlice;\n  readonly value: ExpressionNode;\n\n  constructor(options: { name: SourceSlice; value: ExpressionNode }) {\n    this.loc = options.name.loc.extend(options.value.loc);\n    this.name = options.name;\n    this.value = options.value;\n  }\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { CallFields } from './base';\nimport type { ExpressionNode } from './expr';\n\nimport { NamedArgument } from './args';\nimport { node } from './node';\n\n/**\n * Attr nodes look like HTML attributes, but are classified as:\n *\n * 1. `HtmlAttr`, which means a regular HTML attribute in Glimmer\n * 2. `SplatAttr`, which means `...attributes`\n * 3. `ComponentArg`, which means an attribute whose name begins with `@`, and it is therefore a\n *    component argument.\n */\nexport type AttrNode = HtmlAttr | SplatAttr | ComponentArg;\n\n/**\n * `HtmlAttr` and `SplatAttr` are grouped together because the order of the `SplatAttr` node,\n * relative to other attributes, matters.\n */\nexport type HtmlOrSplatAttr = HtmlAttr | SplatAttr;\n\n/**\n * \"Attr Block\" nodes are allowed inside an open element tag in templates. They interact with the\n * element (or component).\n */\nexport type AttrBlockNode = AttrNode | ElementModifier;\n\n/**\n * `HtmlAttr` nodes are valid HTML attributes, with or without a value.\n *\n * Exceptions:\n *\n * - `...attributes` is `SplatAttr`\n * - `@x=<value>` is `ComponentArg`\n */\nexport class HtmlAttr extends node('HtmlAttr').fields<AttrNodeOptions>() {}\n\nexport class SplatAttr extends node('SplatAttr').fields<{ symbol: number }>() {}\n\n/**\n * Corresponds to an argument passed by a component (`@x=<value>`)\n */\nexport class ComponentArg extends node().fields<AttrNodeOptions>() {\n  /**\n   * Convert the component argument into a named argument node\n   */\n  toNamedArgument(): NamedArgument {\n    return new NamedArgument({\n      name: this.name,\n      value: this.value,\n    });\n  }\n}\n\n/**\n * An `ElementModifier` is just a normal call node in modifier position.\n */\nexport class ElementModifier extends node('ElementModifier').fields<CallFields>() {}\n\nexport interface AttrNodeOptions {\n  name: SourceSlice;\n  value: ExpressionNode;\n  trusting: boolean;\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { SymbolTable } from '../../symbol-table';\nimport type { ComponentArg, ElementModifier, HtmlOrSplatAttr } from './attr-block';\nimport type { CallFields } from './base';\nimport type { ExpressionNode } from './expr';\nimport type { NamedBlock, NamedBlocks } from './internal-node';\nimport type { BaseNodeFields } from './node';\n\nimport { SpanList } from '../../source/span-list';\nimport { Args, NamedArguments } from './args';\nimport { node } from './node';\n\n/**\n * Content Nodes are allowed in content positions in templates. They correspond to behavior in the\n * [Data][data] tokenization state in HTML.\n *\n * [data]: https://html.spec.whatwg.org/multipage/parsing.html#data-state\n */\nexport type ContentNode =\n  | HtmlText\n  | HtmlComment\n  | AppendContent\n  | InvokeBlock\n  | InvokeComponent\n  | SimpleElement\n  | GlimmerComment;\n\nexport class GlimmerComment extends node('GlimmerComment').fields<{ text: SourceSlice }>() {}\nexport class HtmlText extends node('HtmlText').fields<{ chars: string }>() {}\nexport class HtmlComment extends node('HtmlComment').fields<{ text: SourceSlice }>() {}\n\nexport class AppendContent extends node('AppendContent').fields<{\n  value: ExpressionNode;\n  trusting: boolean;\n  table: SymbolTable;\n}>() {\n  get callee(): ExpressionNode {\n    if (this.value.type === 'Call') {\n      return this.value.callee;\n    } else {\n      return this.value;\n    }\n  }\n\n  get args(): Args {\n    if (this.value.type === 'Call') {\n      return this.value.args;\n    } else {\n      return Args.empty(this.value.loc.collapse('end'));\n    }\n  }\n}\n\nexport class InvokeBlock extends node('InvokeBlock').fields<\n  CallFields & { blocks: NamedBlocks }\n>() {}\n\ninterface InvokeComponentFields {\n  callee: ExpressionNode;\n  blocks: NamedBlocks;\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a component invocation. When the content of a component invocation contains no\n * named blocks, `blocks` contains a single named block named `\"default\"`. When a component\n * invocation is self-closing, `blocks` is empty.\n */\nexport class InvokeComponent extends node('InvokeComponent').fields<InvokeComponentFields>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.callee.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n\ninterface SimpleElementOptions extends BaseNodeFields {\n  tag: SourceSlice;\n  body: readonly ContentNode[];\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a simple HTML element. The AST allows component arguments and modifiers to support\n * future extensions.\n */\nexport class SimpleElement extends node('SimpleElement').fields<SimpleElementOptions>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.tag.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n\nexport type ElementNode = NamedBlock | InvokeComponent | SimpleElement;\n","import type { PresentArray } from '@glimmer/interfaces';\n\nimport type { CallFields } from './base';\nimport type { FreeVarReference, VariableReference } from './refs';\n\nimport { SourceSlice } from '../../source/slice';\nimport { node } from './node';\n\n/**\n * A Handlebars literal.\n *\n * {@link https://handlebarsjs.com/guide/expressions.html#literal-segments}\n */\nexport type LiteralValue = string | boolean | number | undefined | null;\n\nexport interface LiteralTypes {\n  string: string;\n  boolean: boolean;\n  number: number;\n  null: null;\n  undefined: undefined;\n}\n\n/**\n * Corresponds to a Handlebars literal.\n *\n * @see {LiteralValue}\n */\nexport class LiteralExpression extends node('Literal').fields<{ value: LiteralValue }>() {\n  toSlice(this: StringLiteral): SourceSlice {\n    return new SourceSlice({ loc: this.loc, chars: this.value });\n  }\n}\n\nexport type StringLiteral = LiteralExpression & { value: string };\n\n/**\n * Returns true if an input {@see ExpressionNode} is a literal.\n */\nexport function isLiteral<K extends keyof LiteralTypes = keyof LiteralTypes>(\n  node: ExpressionNode,\n  kind?: K\n): node is StringLiteral {\n  if (node.type === 'Literal') {\n    if (kind === undefined) {\n      return true;\n    } else if (kind === 'null') {\n      return node.value === null;\n    } else {\n      return typeof node.value === kind;\n    }\n  } else {\n    return false;\n  }\n}\n\n/**\n * Corresponds to a path in expression position.\n *\n * ```hbs\n * this\n * this.x\n * @x\n * @x.y\n * x\n * x.y\n * ```\n */\nexport class PathExpression extends node('Path').fields<{\n  ref: VariableReference;\n  tail: readonly SourceSlice[];\n}>() {}\n\n/**\n * Corresponds to a parenthesized call expression.\n *\n * ```hbs\n * (x)\n * (x.y)\n * (x y)\n * (x.y z)\n * ```\n */\nexport class CallExpression extends node('Call').fields<CallFields>() {}\n\n/**\n * Corresponds to a possible deprecated helper call. Must be:\n *\n * 1. A free variable (not this.foo, not @foo, not local).\n * 2. Argument-less.\n * 3. In a component invocation's named argument position.\n * 4. Not parenthesized (not @bar={{(helper)}}).\n * 5. Not interpolated (not @bar=\"{{helper}}\").\n *\n * ```hbs\n * <Foo @bar={{helper}} />\n * ```\n */\nexport class DeprecatedCallExpression extends node('DeprecatedCall').fields<{\n  arg: SourceSlice;\n  callee: FreeVarReference;\n}>() {}\n\n/**\n * Corresponds to an interpolation in attribute value position.\n *\n * ```hbs\n * <a href=\"{{url}}.html\"\n * ```\n */\nexport class InterpolateExpression extends node('Interpolate').fields<{\n  parts: PresentArray<ExpressionNode>;\n}>() {}\n\nexport type ExpressionNode =\n  | LiteralExpression\n  | PathExpression\n  | CallExpression\n  | DeprecatedCallExpression\n  | InterpolateExpression;\n","import type { SourceSlice } from '../../source/slice';\nimport type { BlockSymbolTable, ProgramSymbolTable } from '../../symbol-table';\nimport type { ComponentArg, ElementModifier, HtmlOrSplatAttr } from './attr-block';\nimport type { GlimmerParentNodeOptions } from './base';\nimport type { BaseNodeFields } from './node';\n\nimport { SpanList } from '../../source/span-list';\nimport { Args, NamedArguments } from './args';\nimport { node } from './node';\n\n/**\n * Corresponds to an entire template.\n */\nexport class Template extends node().fields<\n  {\n    table: ProgramSymbolTable;\n  } & GlimmerParentNodeOptions\n>() {}\n\n/**\n * Represents a block. In principle this could be merged with `NamedBlock`, because all cases\n * involving blocks have at least a notional name.\n */\nexport class Block extends node().fields<\n  { scope: BlockSymbolTable } & GlimmerParentNodeOptions\n>() {}\n\n/**\n * Corresponds to a collection of named blocks.\n */\nexport class NamedBlocks extends node().fields<{ blocks: readonly NamedBlock[] }>() {\n  /**\n   * Get the `NamedBlock` for a given name.\n   */\n  get(name: 'default'): NamedBlock;\n  get(name: string): NamedBlock | null;\n  get(name: string): NamedBlock | null {\n    return this.blocks.filter((block) => block.name.chars === name)[0] || null;\n  }\n}\n\nexport interface NamedBlockFields extends BaseNodeFields {\n  name: SourceSlice;\n  block: Block;\n\n  // these are not currently supported, but are here for future expansion\n  attrs: readonly HtmlOrSplatAttr[];\n  componentArgs: readonly ComponentArg[];\n  modifiers: readonly ElementModifier[];\n}\n\n/**\n * Corresponds to a single named block. This is used for anonymous named blocks (`default` and\n * `else`).\n */\nexport class NamedBlock extends node().fields<NamedBlockFields>() {\n  get args(): Args {\n    let entries = this.componentArgs.map((a) => a.toNamedArgument());\n\n    return Args.named(\n      new NamedArguments({\n        loc: SpanList.range(entries, this.name.loc.collapse('end')),\n        entries,\n      })\n    );\n  }\n}\n","import type { SourceSlice } from '../../source/slice';\nimport type { FreeVarResolution } from './resolution';\n\nimport { node } from './node';\n\n/**\n * Corresponds to `this` at the head of an expression.\n */\nexport class ThisReference extends node('This').fields() {}\n\n/**\n * Corresponds to `@<ident>` at the beginning of an expression.\n */\nexport class ArgReference extends node('Arg').fields<{ name: SourceSlice; symbol: number }>() {}\n\n/**\n * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is in the current\n * block's scope.\n */\nexport class LocalVarReference extends node('Local').fields<{\n  name: string;\n  isTemplateLocal: boolean;\n  symbol: number;\n}>() {}\n\n/**\n * Corresponds to `<ident>` at the beginning of an expression, when `<ident>` is *not* in the\n * current block's scope.\n *\n * The `resolution: FreeVarResolution` field describes how to resolve the free variable.\n *\n * Note: In strict mode, it must always be a variable that is in a concrete JavaScript scope that\n * the template will be installed into.\n */\nexport class FreeVarReference extends node('Free').fields<{\n  name: string;\n  resolution: FreeVarResolution;\n  symbol: number;\n}>() {}\n\nexport type VariableReference = ThisReference | ArgReference | LocalVarReference | FreeVarReference;\n","/**\n * A free variable is resolved according to a resolution rule:\n *\n * 1. Strict resolution\n * 2. Namespaced resolution\n * 3. Fallback resolution\n */\n\nimport type { GetContextualFreeOpcode } from '@glimmer/interfaces';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\n/**\n * Strict resolution is used:\n *\n * 1. in a strict mode template\n * 2. in an unambiguous invocation with dot paths\n */\nexport const STRICT_RESOLUTION = {\n  resolution: (): GetContextualFreeOpcode => SexpOpcodes.GetStrictKeyword,\n  serialize: (): SerializedResolution => 'Strict',\n  isAngleBracket: false as const,\n};\n\nexport type StrictResolution = typeof STRICT_RESOLUTION;\n\nexport const HTML_RESOLUTION = {\n  ...STRICT_RESOLUTION,\n  isAngleBracket: true as const,\n};\n\nexport type HtmlResolution = typeof HTML_RESOLUTION;\n\nexport function isStrictResolution(value: unknown): value is StrictResolution {\n  return value === STRICT_RESOLUTION;\n}\n\n/**\n * A `LooseModeResolution` includes:\n *\n * - 0 or more namespaces to resolve the variable in\n * - optional fallback behavior\n *\n * In practice, there are a limited number of possible combinations of these degrees of freedom,\n * and they are captured by the `Ambiguity` union below.\n */\nexport class LooseModeResolution {\n  /**\n   * Namespaced resolution is used in an unambiguous syntax position:\n   *\n   * 1. `(sexp)` (namespace: `Helper`)\n   * 2. `{{#block}}` (namespace: `Component`)\n   * 3. `<a {{modifier}}>` (namespace: `Modifier`)\n   * 4. `<Component />` (namespace: `Component`)\n   *\n   * @see {NamespacedAmbiguity}\n   */\n  static namespaced(namespace: FreeVarNamespace, isAngleBracket = false): LooseModeResolution {\n    return new LooseModeResolution(\n      {\n        namespaces: [namespace],\n        fallback: false,\n      },\n      isAngleBracket\n    );\n  }\n\n  /**\n   * Fallback resolution is used when no namespaced resolutions are possible, but fallback\n   * resolution is still allowed.\n   *\n   * ```hbs\n   * {{x.y}}\n   * ```\n   *\n   * @see {FallbackAmbiguity}\n   */\n  static fallback(): LooseModeResolution {\n    return new LooseModeResolution({ namespaces: [], fallback: true });\n  }\n\n  /**\n   * Append resolution is used when the variable should be resolved in both the `component` and\n   * `helper` namespaces. Fallback resolution is optional.\n   *\n   * ```hbs\n   * {{x}}\n   * ```\n   *\n   * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.\n   *\n   * ```hbs\n   * {{x y}}\n   * ```\n   *\n   * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback\n   * resolution.\n   *\n   * @see {ComponentOrHelperAmbiguity}\n   */\n  static append({ invoke }: { invoke: boolean }): LooseModeResolution {\n    return new LooseModeResolution({\n      namespaces: [FreeVarNamespace.Component, FreeVarNamespace.Helper],\n      fallback: !invoke,\n    });\n  }\n\n  /**\n   * Trusting append resolution is used when the variable should be resolved in both the `component` and\n   * `helper` namespaces. Fallback resolution is optional.\n   *\n   * ```hbs\n   * {{{x}}}\n   * ```\n   *\n   * ^ `x` should be resolved in the `component` and `helper` namespaces with fallback resolution.\n   *\n   * ```hbs\n   * {{{x y}}}\n   * ```\n   *\n   * ^ `x` should be resolved in the `component` and `helper` namespaces without fallback\n   * resolution.\n   *\n   * @see {HelperAmbiguity}\n   */\n  static trustingAppend({ invoke }: { invoke: boolean }): LooseModeResolution {\n    return new LooseModeResolution({\n      namespaces: [FreeVarNamespace.Helper],\n      fallback: !invoke,\n    });\n  }\n\n  /**\n   * Attribute resolution is used when the variable should be resolved as a `helper` with fallback\n   * resolution.\n   *\n   * ```hbs\n   * <a href={{x}} />\n   * <a href=\"{{x}}.html\" />\n   * ```\n   *\n   * ^ resolved in the `helper` namespace with fallback\n   *\n   * @see {HelperAmbiguity}\n   */\n  static attr(): LooseModeResolution {\n    return new LooseModeResolution({ namespaces: [FreeVarNamespace.Helper], fallback: true });\n  }\n\n  constructor(\n    readonly ambiguity: Ambiguity,\n    readonly isAngleBracket = false\n  ) {}\n\n  resolution(): GetContextualFreeOpcode {\n    if (this.ambiguity.namespaces.length === 0) {\n      return SexpOpcodes.GetStrictKeyword;\n    } else if (this.ambiguity.namespaces.length === 1) {\n      if (this.ambiguity.fallback) {\n        // simple namespaced resolution with fallback must be attr={{x}}\n        return SexpOpcodes.GetFreeAsHelperHeadOrThisFallback;\n      } else {\n        // simple namespaced resolution without fallback\n        switch (this.ambiguity.namespaces[0]) {\n          case FreeVarNamespace.Helper:\n            return SexpOpcodes.GetFreeAsHelperHead;\n          case FreeVarNamespace.Modifier:\n            return SexpOpcodes.GetFreeAsModifierHead;\n          case FreeVarNamespace.Component:\n            return SexpOpcodes.GetFreeAsComponentHead;\n        }\n      }\n    } else if (this.ambiguity.fallback) {\n      // component or helper + fallback ({{something}})\n      return SexpOpcodes.GetFreeAsComponentOrHelperHeadOrThisFallback;\n    } else {\n      // component or helper without fallback ({{something something}})\n      return SexpOpcodes.GetFreeAsComponentOrHelperHead;\n    }\n  }\n\n  serialize(): SerializedResolution {\n    if (this.ambiguity.namespaces.length === 0) {\n      return 'Loose';\n    } else if (this.ambiguity.namespaces.length === 1) {\n      if (this.ambiguity.fallback) {\n        // simple namespaced resolution with fallback must be attr={{x}}\n        return ['ambiguous', SerializedAmbiguity.Attr];\n      } else {\n        return ['ns', this.ambiguity.namespaces[0]];\n      }\n    } else if (this.ambiguity.fallback) {\n      // component or helper + fallback ({{something}})\n      return ['ambiguous', SerializedAmbiguity.Append];\n    } else {\n      // component or helper without fallback ({{something something}})\n      return ['ambiguous', SerializedAmbiguity.Invoke];\n    }\n  }\n}\n\nexport const ARGUMENT_RESOLUTION = LooseModeResolution.fallback();\n\nexport enum FreeVarNamespace {\n  Helper = 'Helper',\n  Modifier = 'Modifier',\n  Component = 'Component',\n}\n\nexport const HELPER_NAMESPACE = FreeVarNamespace.Helper;\nexport const MODIFIER_NAMESPACE = FreeVarNamespace.Modifier;\nexport const COMPONENT_NAMESPACE = FreeVarNamespace.Component;\n\n/**\n * A `ComponentOrHelperAmbiguity` might be a component or a helper, with an optional fallback\n *\n * ```hbs\n * {{x}}\n * ```\n *\n * ^ `x` is resolved in the `component` and `helper` namespaces, with fallback\n *\n * ```hbs\n * {{x y}}\n * ```\n *\n * ^ `x` is resolved in the `component` and `helper` namespaces, without fallback\n */\ntype ComponentOrHelperAmbiguity = {\n  namespaces: [FreeVarNamespace.Component, FreeVarNamespace.Helper];\n  fallback: boolean;\n};\n\n/**\n * A `HelperAmbiguity` must be a helper, but it has fallback. If it didn't have fallback, it would\n * be a `NamespacedAmbiguity`.\n *\n * ```hbs\n * <a href={{x}} />\n * <a href=\"{{x}}.html\" />\n * ```\n *\n * ^ `x` is resolved in the `helper` namespace with fallback\n */\ntype HelperAmbiguity = { namespaces: [FreeVarNamespace.Helper]; fallback: boolean };\n\n/**\n * A `NamespacedAmbiguity` must be resolved in a particular namespace, without fallback.\n *\n * ```hbs\n * <X />\n * ```\n *\n * ^ `X` is resolved in the `component` namespace without fallback\n *\n * ```hbs\n * (x)\n * ```\n *\n * ^ `x` is resolved in the `helper` namespace without fallback\n *\n * ```hbs\n * <a {{x}} />\n * ```\n *\n * ^ `x` is resolved in the `modifier` namespace without fallback\n */\ntype NamespacedAmbiguity = {\n  namespaces: [FreeVarNamespace.Component | FreeVarNamespace.Helper | FreeVarNamespace.Modifier];\n  fallback: false;\n};\n\ntype FallbackAmbiguity = {\n  namespaces: [];\n  fallback: true;\n};\n\ntype Ambiguity =\n  | ComponentOrHelperAmbiguity\n  | HelperAmbiguity\n  | NamespacedAmbiguity\n  | FallbackAmbiguity;\n\nexport type FreeVarResolution = StrictResolution | HtmlResolution | LooseModeResolution;\n\n// Serialization\n\nconst enum SerializedAmbiguity {\n  // {{x}}\n  Append = 'Append',\n  // href={{x}}\n  Attr = 'Attr',\n  // {{x y}} (not attr)\n  Invoke = 'Invoke',\n}\n\nexport type SerializedResolution =\n  | 'Strict'\n  | 'Loose'\n  | ['ns', FreeVarNamespace]\n  | ['ambiguous', SerializedAmbiguity];\n\nexport function loadResolution(resolution: SerializedResolution): FreeVarResolution {\n  if (typeof resolution === 'string') {\n    switch (resolution) {\n      case 'Loose':\n        return LooseModeResolution.fallback();\n      case 'Strict':\n        return STRICT_RESOLUTION;\n    }\n  }\n\n  switch (resolution[0]) {\n    case 'ambiguous':\n      switch (resolution[1]) {\n        case SerializedAmbiguity.Append:\n          return LooseModeResolution.append({ invoke: false });\n        case SerializedAmbiguity.Attr:\n          return LooseModeResolution.attr();\n        case SerializedAmbiguity.Invoke:\n          return LooseModeResolution.append({ invoke: true });\n      }\n\n    case 'ns':\n      return LooseModeResolution.namespaced(resolution[1]);\n  }\n}\n","import type { Core, Dict } from '@glimmer/interfaces';\nimport { dict, unwrap } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport * as ASTv2 from './v2/api';\n\nexport interface Upvar {\n  readonly name: string;\n  readonly resolution: ASTv2.FreeVarResolution;\n}\n\ninterface SymbolTableOptions {\n  customizeComponentName: (input: string) => string;\n  lexicalScope: (variable: string) => boolean;\n}\n\nexport abstract class SymbolTable {\n  static top(locals: string[], options: SymbolTableOptions): ProgramSymbolTable {\n    return new ProgramSymbolTable(locals, options);\n  }\n\n  abstract has(name: string): boolean;\n  abstract get(name: string): [symbol: number, isRoot: boolean];\n\n  abstract hasLexical(name: string): boolean;\n  abstract getLexical(name: string): number;\n\n  abstract getLocalsMap(): Dict<number>;\n  abstract getDebugInfo(): Core.DebugInfo;\n  abstract setHasDebugger(): void;\n\n  abstract allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number;\n  abstract allocateNamed(name: string): number;\n  abstract allocateBlock(name: string): number;\n  abstract allocate(identifier: string): number;\n\n  child(locals: string[]): BlockSymbolTable {\n    let symbols = locals.map((name) => this.allocate(name));\n    return new BlockSymbolTable(this, locals, symbols);\n  }\n}\n\nexport class ProgramSymbolTable extends SymbolTable {\n  constructor(\n    private templateLocals: string[],\n    private options: SymbolTableOptions\n  ) {\n    super();\n  }\n\n  public symbols: string[] = [];\n  public upvars: string[] = [];\n\n  private size = 1;\n  private named = dict<number>();\n  private blocks = dict<number>();\n  private usedTemplateLocals: string[] = [];\n\n  #hasDebugger = false;\n\n  hasLexical(name: string): boolean {\n    return this.options.lexicalScope(name);\n  }\n\n  getLexical(name: string): number {\n    return this.allocateFree(name, ASTv2.HTML_RESOLUTION);\n  }\n\n  getUsedTemplateLocals(): string[] {\n    return this.usedTemplateLocals;\n  }\n\n  setHasDebugger(): void {\n    this.#hasDebugger = true;\n  }\n\n  get hasEval(): boolean {\n    return this.#hasDebugger;\n  }\n\n  has(name: string): boolean {\n    return this.templateLocals.includes(name);\n  }\n\n  get(name: string): [number, boolean] {\n    let index = this.usedTemplateLocals.indexOf(name);\n\n    if (index !== -1) {\n      return [index, true];\n    }\n\n    index = this.usedTemplateLocals.length;\n    this.usedTemplateLocals.push(name);\n    return [index, true];\n  }\n\n  getLocalsMap(): Dict<number> {\n    return dict();\n  }\n\n  getDebugInfo(): Core.DebugInfo {\n    return Object.values(this.getLocalsMap());\n  }\n\n  allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number {\n    // If the name in question is an uppercase (i.e. angle-bracket) component invocation, run\n    // the optional `customizeComponentName` function provided to the precompiler.\n    if (\n      resolution.resolution() === SexpOpcodes.GetFreeAsComponentHead &&\n      resolution.isAngleBracket\n    ) {\n      name = this.options.customizeComponentName(name);\n    }\n\n    let index = this.upvars.indexOf(name);\n\n    if (index !== -1) {\n      return index;\n    }\n\n    index = this.upvars.length;\n    this.upvars.push(name);\n    return index;\n  }\n\n  allocateNamed(name: string): number {\n    let named = this.named[name];\n\n    if (!named) {\n      named = this.named[name] = this.allocate(name);\n    }\n\n    return named;\n  }\n\n  allocateBlock(name: string): number {\n    if (name === 'inverse') {\n      name = 'else';\n    }\n\n    let block = this.blocks[name];\n\n    if (!block) {\n      block = this.blocks[name] = this.allocate(`&${name}`);\n    }\n\n    return block;\n  }\n\n  allocate(identifier: string): number {\n    this.symbols.push(identifier);\n    return this.size++;\n  }\n}\n\nexport class BlockSymbolTable extends SymbolTable {\n  constructor(\n    private parent: SymbolTable,\n    public symbols: string[],\n    public slots: number[]\n  ) {\n    super();\n  }\n\n  get locals(): string[] {\n    return this.symbols;\n  }\n\n  getLexical(name: string): number {\n    return this.parent.getLexical(name);\n  }\n\n  hasLexical(name: string): boolean {\n    return this.parent.hasLexical(name);\n  }\n\n  has(name: string): boolean {\n    return this.symbols.indexOf(name) !== -1 || this.parent.has(name);\n  }\n\n  get(name: string): [number, boolean] {\n    let local = this.#get(name);\n    return local ? [local, false] : this.parent.get(name);\n  }\n\n  #get(name: string): number | null {\n    let slot = this.symbols.indexOf(name);\n    return slot === -1 ? null : unwrap(this.slots[slot]);\n  }\n\n  getLocalsMap(): Dict<number> {\n    let dict = this.parent.getLocalsMap();\n    this.symbols.forEach((symbol) => (dict[symbol] = this.get(symbol)[0]));\n    return dict;\n  }\n\n  getDebugInfo(): Core.DebugInfo {\n    return Object.values(this.getLocalsMap());\n  }\n\n  setHasDebugger(): void {\n    this.parent.setHasDebugger();\n  }\n\n  allocateFree(name: string, resolution: ASTv2.FreeVarResolution): number {\n    return this.parent.allocateFree(name, resolution);\n  }\n\n  allocateNamed(name: string): number {\n    return this.parent.allocateNamed(name);\n  }\n\n  allocateBlock(name: string): number {\n    return this.parent.allocateBlock(name);\n  }\n\n  allocate(identifier: string): number {\n    return this.parent.allocate(identifier);\n  }\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { assert, assertPresentArray, assign } from '@glimmer/util';\n\nimport type { SourceSpan } from '../source/span';\nimport type { BlockSymbolTable, ProgramSymbolTable, SymbolTable } from '../symbol-table';\n\nimport { SourceSlice } from '../source/slice';\nimport { SpanList } from '../source/span-list';\nimport * as ASTv2 from './api';\n\nexport interface CallParts {\n  callee: ASTv2.ExpressionNode;\n  args: ASTv2.Args;\n}\n\nexport class Builder {\n  // TEMPLATE //\n\n  template(\n    symbols: ProgramSymbolTable,\n    body: ASTv2.ContentNode[],\n    loc: SourceSpan\n  ): ASTv2.Template {\n    return new ASTv2.Template({\n      table: symbols,\n      body,\n      loc,\n    });\n  }\n\n  // INTERNAL (these nodes cannot be reached when doing general-purpose visiting) //\n\n  block(symbols: BlockSymbolTable, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.Block {\n    return new ASTv2.Block({\n      scope: symbols,\n      body,\n      loc,\n    });\n  }\n\n  namedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new ASTv2.NamedBlock({\n      name,\n      block,\n      attrs: [],\n      componentArgs: [],\n      modifiers: [],\n      loc,\n    });\n  }\n\n  simpleNamedBlock(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new BuildElement({\n      selfClosing: false,\n      attrs: [],\n      componentArgs: [],\n      modifiers: [],\n      comments: [],\n    }).named(name, block, loc);\n  }\n\n  slice(chars: string, loc: SourceSpan): SourceSlice {\n    return new SourceSlice({\n      loc,\n      chars,\n    });\n  }\n\n  args(\n    positional: ASTv2.PositionalArguments,\n    named: ASTv2.NamedArguments,\n    loc: SourceSpan\n  ): ASTv2.Args {\n    return new ASTv2.Args({\n      loc,\n      positional,\n      named,\n    });\n  }\n\n  positional(exprs: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.PositionalArguments {\n    return new ASTv2.PositionalArguments({\n      loc,\n      exprs,\n    });\n  }\n\n  namedArgument(key: SourceSlice, value: ASTv2.ExpressionNode): ASTv2.NamedArgument {\n    return new ASTv2.NamedArgument({\n      name: key,\n      value,\n    });\n  }\n\n  named(entries: ASTv2.NamedArgument[], loc: SourceSpan): ASTv2.NamedArguments {\n    return new ASTv2.NamedArguments({\n      loc,\n      entries,\n    });\n  }\n\n  attr(\n    {\n      name,\n      value,\n      trusting,\n    }: { name: SourceSlice; value: ASTv2.ExpressionNode; trusting: boolean },\n    loc: SourceSpan\n  ): ASTv2.HtmlAttr {\n    return new ASTv2.HtmlAttr({\n      loc,\n      name,\n      value,\n      trusting,\n    });\n  }\n\n  splatAttr(symbol: number, loc: SourceSpan): ASTv2.SplatAttr {\n    return new ASTv2.SplatAttr({\n      symbol,\n      loc,\n    });\n  }\n\n  arg(\n    {\n      name,\n      value,\n      trusting,\n    }: { name: SourceSlice; value: ASTv2.ExpressionNode; trusting: boolean },\n    loc: SourceSpan\n  ): ASTv2.ComponentArg {\n    return new ASTv2.ComponentArg({\n      name,\n      value,\n      trusting,\n      loc,\n    });\n  }\n\n  // EXPRESSIONS //\n\n  path(head: ASTv2.VariableReference, tail: SourceSlice[], loc: SourceSpan): ASTv2.PathExpression {\n    return new ASTv2.PathExpression({\n      loc,\n      ref: head,\n      tail,\n    });\n  }\n\n  self(loc: SourceSpan): ASTv2.VariableReference {\n    return new ASTv2.ThisReference({\n      loc,\n    });\n  }\n\n  at(name: string, symbol: number, loc: SourceSpan): ASTv2.VariableReference {\n    // the `@` should be included so we have a complete source range\n    assert(name[0] === '@', `call builders.at() with a string that starts with '@'`);\n\n    return new ASTv2.ArgReference({\n      loc,\n      name: new SourceSlice({ loc, chars: name }),\n      symbol,\n    });\n  }\n\n  freeVar({\n    name,\n    context,\n    symbol,\n    loc,\n  }: {\n    name: string;\n    context: ASTv2.FreeVarResolution;\n    symbol: number;\n    loc: SourceSpan;\n  }): ASTv2.FreeVarReference {\n    assert(\n      name !== 'this',\n      `You called builders.freeVar() with 'this'. Call builders.this instead`\n    );\n    assert(\n      name[0] !== '@',\n      `You called builders.freeVar() with '${name}'. Call builders.at('${name}') instead`\n    );\n\n    return new ASTv2.FreeVarReference({\n      name,\n      resolution: context,\n      symbol,\n      loc,\n    });\n  }\n\n  localVar(\n    name: string,\n    symbol: number,\n    isTemplateLocal: boolean,\n    loc: SourceSpan\n  ): ASTv2.VariableReference {\n    assert(name !== 'this', `You called builders.var() with 'this'. Call builders.this instead`);\n    assert(\n      name[0] !== '@',\n      `You called builders.var() with '${name}'. Call builders.at('${name}') instead`\n    );\n\n    return new ASTv2.LocalVarReference({\n      loc,\n      name,\n      isTemplateLocal,\n      symbol,\n    });\n  }\n\n  sexp(parts: CallParts, loc: SourceSpan): ASTv2.CallExpression {\n    return new ASTv2.CallExpression({\n      loc,\n      callee: parts.callee,\n      args: parts.args,\n    });\n  }\n\n  deprecatedCall(\n    arg: SourceSlice,\n    callee: ASTv2.FreeVarReference,\n    loc: SourceSpan\n  ): ASTv2.DeprecatedCallExpression {\n    return new ASTv2.DeprecatedCallExpression({\n      loc,\n      arg,\n      callee,\n    });\n  }\n\n  interpolate(parts: ASTv2.ExpressionNode[], loc: SourceSpan): ASTv2.InterpolateExpression {\n    assertPresentArray(parts);\n\n    return new ASTv2.InterpolateExpression({\n      loc,\n      parts,\n    });\n  }\n\n  literal(value: string, loc: SourceSpan): ASTv2.LiteralExpression & { value: string };\n  literal(value: number, loc: SourceSpan): ASTv2.LiteralExpression & { value: number };\n  literal(value: boolean, loc: SourceSpan): ASTv2.LiteralExpression & { value: boolean };\n  literal(value: null, loc: SourceSpan): ASTv2.LiteralExpression & { value: null };\n  literal(value: undefined, loc: SourceSpan): ASTv2.LiteralExpression & { value: undefined };\n  literal(\n    value: string | number | boolean | null | undefined,\n    loc: SourceSpan\n  ): ASTv2.LiteralExpression;\n  literal(\n    value: string | number | boolean | null | undefined,\n    loc: SourceSpan\n  ): ASTv2.LiteralExpression {\n    return new ASTv2.LiteralExpression({\n      loc,\n      value,\n    });\n  }\n\n  // STATEMENTS //\n\n  append(\n    {\n      table,\n      trusting,\n      value,\n    }: { table: SymbolTable; trusting: boolean; value: ASTv2.ExpressionNode },\n    loc: SourceSpan\n  ): ASTv2.AppendContent {\n    return new ASTv2.AppendContent({\n      table,\n      trusting,\n      value,\n      loc,\n    });\n  }\n\n  modifier({ callee, args }: CallParts, loc: SourceSpan): ASTv2.ElementModifier {\n    return new ASTv2.ElementModifier({\n      loc,\n      callee,\n      args,\n    });\n  }\n\n  namedBlocks(blocks: ASTv2.NamedBlock[], loc: SourceSpan): ASTv2.NamedBlocks {\n    return new ASTv2.NamedBlocks({\n      loc,\n      blocks,\n    });\n  }\n\n  blockStatement(\n    {\n      program,\n      inverse = null,\n      ...call\n    }: {\n      symbols: SymbolTable;\n      program: ASTv2.Block;\n      inverse?: ASTv2.Block | null;\n    } & CallParts,\n    loc: SourceSpan\n  ): ASTv2.InvokeBlock {\n    let blocksLoc = program.loc;\n    let blocks: PresentArray<ASTv2.NamedBlock> = [\n      this.namedBlock(SourceSlice.synthetic('default'), program, program.loc),\n    ];\n    if (inverse) {\n      blocksLoc = blocksLoc.extend(inverse.loc);\n      blocks.push(this.namedBlock(SourceSlice.synthetic('else'), inverse, inverse.loc));\n    }\n\n    return new ASTv2.InvokeBlock({\n      loc,\n      blocks: this.namedBlocks(blocks, blocksLoc),\n      callee: call.callee,\n      args: call.args,\n    });\n  }\n\n  element(options: BuildBaseElement): BuildElement {\n    return new BuildElement(options);\n  }\n}\n\nexport interface BuildBaseElement {\n  selfClosing: boolean;\n  attrs: ASTv2.HtmlOrSplatAttr[];\n  componentArgs: ASTv2.ComponentArg[];\n  modifiers: ASTv2.ElementModifier[];\n  comments: ASTv2.GlimmerComment[];\n}\n\nexport class BuildElement {\n  readonly builder: Builder;\n  constructor(readonly base: BuildBaseElement) {\n    this.builder = new Builder();\n  }\n\n  simple(tag: SourceSlice, body: ASTv2.ContentNode[], loc: SourceSpan): ASTv2.SimpleElement {\n    return new ASTv2.SimpleElement(\n      assign(\n        {\n          tag,\n          body,\n          componentArgs: [],\n          loc,\n        },\n        this.base\n      )\n    );\n  }\n\n  named(name: SourceSlice, block: ASTv2.Block, loc: SourceSpan): ASTv2.NamedBlock {\n    return new ASTv2.NamedBlock(\n      assign(\n        {\n          name,\n          block,\n          componentArgs: [],\n          loc,\n        },\n        this.base\n      )\n    );\n  }\n\n  selfClosingComponent(callee: ASTv2.ExpressionNode, loc: SourceSpan): ASTv2.InvokeComponent {\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          // point the empty named blocks at the `/` self-closing tag\n          blocks: new ASTv2.NamedBlocks({\n            blocks: [],\n            loc: loc.sliceEndChars({ skipEnd: 1, chars: 1 }),\n          }),\n        },\n        this.base\n      )\n    );\n  }\n\n  componentWithDefaultBlock(\n    callee: ASTv2.ExpressionNode,\n    children: ASTv2.ContentNode[],\n    symbols: BlockSymbolTable,\n    loc: SourceSpan\n  ): ASTv2.InvokeComponent {\n    let block = this.builder.block(symbols, children, loc);\n    let namedBlock = this.builder.namedBlock(SourceSlice.synthetic('default'), block, loc); // BUILDER.simpleNamedBlock('default', children, symbols, loc);\n\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          blocks: this.builder.namedBlocks([namedBlock], namedBlock.loc),\n        },\n        this.base\n      )\n    );\n  }\n\n  componentWithNamedBlocks(\n    callee: ASTv2.ExpressionNode,\n    blocks: PresentArray<ASTv2.NamedBlock>,\n    loc: SourceSpan\n  ): ASTv2.InvokeComponent {\n    return new ASTv2.InvokeComponent(\n      assign(\n        {\n          loc,\n          callee,\n          blocks: this.builder.namedBlocks(blocks, SpanList.range(blocks)),\n        },\n        this.base\n      )\n    );\n  }\n}\n","import type * as ASTv1 from '../v1/api';\n\nimport * as ASTv2 from './api';\n\nexport interface AstCallParts {\n  path: ASTv1.Expression;\n  params: ASTv1.Expression[];\n  hash: ASTv1.Hash;\n}\n\nexport interface VarPath extends ASTv1.PathExpression {\n  head: ASTv1.VarHead;\n}\n\nexport function SexpSyntaxContext(node: ASTv1.SubExpression): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.HELPER_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\nexport function ModifierSyntaxContext(\n  node: ASTv1.ElementModifierStatement\n): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.MODIFIER_NAMESPACE);\n  } else {\n    return null;\n  }\n}\n\nexport function BlockSyntaxContext(node: ASTv1.BlockStatement): ASTv2.FreeVarResolution | null {\n  if (isSimpleCallee(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.COMPONENT_NAMESPACE);\n  } else {\n    return ASTv2.LooseModeResolution.fallback();\n  }\n}\n\nexport function ComponentSyntaxContext(node: ASTv1.PathExpression): ASTv2.FreeVarResolution | null {\n  if (isSimplePath(node)) {\n    return ASTv2.LooseModeResolution.namespaced(ASTv2.FreeVarNamespace.Component, true);\n  } else {\n    return null;\n  }\n}\n\n/**\n * This corresponds to append positions (text curlies or attribute\n * curlies). In strict mode, this also corresponds to arg curlies.\n */\nexport function AttrValueSyntaxContext(node: ASTv1.MustacheStatement): ASTv2.FreeVarResolution {\n  let isSimple = isSimpleCallee(node);\n  let isInvoke = isInvokeNode(node);\n\n  if (isSimple) {\n    return isInvoke\n      ? ASTv2.LooseModeResolution.namespaced(ASTv2.FreeVarNamespace.Helper)\n      : ASTv2.LooseModeResolution.attr();\n  } else {\n    return isInvoke ? ASTv2.STRICT_RESOLUTION : ASTv2.LooseModeResolution.fallback();\n  }\n}\n\n/**\n * This corresponds to append positions (text curlies or attribute\n * curlies). In strict mode, this also corresponds to arg curlies.\n */\nexport function AppendSyntaxContext(node: ASTv1.MustacheStatement): ASTv2.FreeVarResolution {\n  let isSimple = isSimpleCallee(node);\n  let isInvoke = isInvokeNode(node);\n  let trusting = node.trusting;\n\n  if (isSimple) {\n    return trusting\n      ? ASTv2.LooseModeResolution.trustingAppend({ invoke: isInvoke })\n      : ASTv2.LooseModeResolution.append({ invoke: isInvoke });\n  } else {\n    return ASTv2.LooseModeResolution.fallback();\n  }\n}\n\nexport type Resolution<P extends AstCallParts | ASTv1.PathExpression> = (\n  call: P\n) => ASTv2.FreeVarResolution | null;\n\n// UTILITIES\n\n/**\n * A call node has a simple callee if its head is:\n *\n * - a `PathExpression`\n * - the `PathExpression`'s head is a `VarHead`\n * - it has no tail\n *\n * Simple heads:\n *\n * ```\n * {{x}}\n * {{x y}}\n * ```\n *\n * Not simple heads:\n *\n * ```\n * {{x.y}}\n * {{x.y z}}\n * {{@x}}\n * {{@x a}}\n * {{this}}\n * {{this a}}\n * ```\n */\nfunction isSimpleCallee(node: AstCallParts): boolean {\n  let path = node.path;\n\n  return isSimplePath(path);\n}\n\ntype SimplePath = ASTv1.PathExpression & { head: ASTv1.VarHead };\n\nfunction isSimplePath(node: ASTv1.Expression): node is SimplePath {\n  if (node.type === 'PathExpression' && node.head.type === 'VarHead') {\n    return node.tail.length === 0;\n  } else {\n    return false;\n  }\n}\n\n/**\n * The call expression has at least one argument.\n */\nfunction isInvokeNode(node: AstCallParts): boolean {\n  return node.params.length > 0 || node.hash.pairs.length > 0;\n}\n","import type { PresentArray } from '@glimmer/interfaces';\nimport { asPresentArray, assert, assign, isPresentArray } from '@glimmer/util';\n\nimport type {\n  PrecompileOptions,\n  PrecompileOptionsWithLexicalScope,\n} from '../parser/tokenizer-event-handlers';\nimport type { SourceLocation } from '../source/location';\nimport type { Source } from '../source/source';\nimport type { SourceSpan } from '../source/span';\nimport type { BlockSymbolTable, ProgramSymbolTable } from '../symbol-table';\nimport type * as ASTv1 from '../v1/api';\nimport type { BuildElement, CallParts } from './builders';\nimport type { Resolution } from './loose-resolution';\n\nimport Printer from '../generation/printer';\nimport { preprocess } from '../parser/tokenizer-event-handlers';\nimport { SourceSlice } from '../source/slice';\nimport { SpanList } from '../source/span-list';\nimport { SymbolTable } from '../symbol-table';\nimport { generateSyntaxError } from '../syntax-error';\nimport { isLowerCase, isUpperCase } from '../utils';\nimport b from '../v1/parser-builders';\nimport * as ASTv2 from './api';\nimport { Builder } from './builders';\nimport {\n  AppendSyntaxContext,\n  AttrValueSyntaxContext,\n  BlockSyntaxContext,\n  ComponentSyntaxContext,\n  ModifierSyntaxContext,\n  SexpSyntaxContext,\n} from './loose-resolution';\n\nexport function normalize(\n  source: Source,\n  options: PrecompileOptionsWithLexicalScope = { lexicalScope: () => false }\n): [ast: ASTv2.Template, locals: string[]] {\n  let ast = preprocess(source, options);\n\n  let normalizeOptions = {\n    strictMode: false,\n    locals: [],\n    ...options,\n  };\n\n  let top = SymbolTable.top(\n    normalizeOptions.locals,\n\n    {\n      customizeComponentName: options.customizeComponentName ?? ((name) => name),\n      lexicalScope: options.lexicalScope,\n    }\n  );\n  let block = new BlockContext(source, normalizeOptions, top);\n  let normalizer = new StatementNormalizer(block);\n\n  let astV2 = new TemplateChildren(\n    block.loc(ast.loc),\n    ast.body.map((b) => normalizer.normalize(b)),\n    block\n  ).assertTemplate(top);\n\n  let locals = top.getUsedTemplateLocals();\n\n  return [astV2, locals];\n}\n\n/**\n * A `BlockContext` represents the block that a particular AST node is contained inside of.\n *\n * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings\n * that are in-scope within that block.\n *\n * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides\n * facilities for working with those options.\n *\n * `BlockContext` is stateless.\n */\nexport class BlockContext<Table extends SymbolTable = SymbolTable> {\n  readonly builder: Builder;\n\n  constructor(\n    readonly source: Source,\n    private readonly options: PrecompileOptions,\n    readonly table: Table\n  ) {\n    this.builder = new Builder();\n  }\n\n  get strict(): boolean {\n    return this.options.strictMode || false;\n  }\n\n  loc(loc: SourceLocation): SourceSpan {\n    return this.source.spanFor(loc);\n  }\n\n  resolutionFor<N extends ASTv1.CallNode | ASTv1.PathExpression>(\n    node: N,\n    resolution: Resolution<N>\n  ): { result: ASTv2.FreeVarResolution } | { result: 'error'; path: string; head: string } {\n    if (this.strict) {\n      return { result: ASTv2.STRICT_RESOLUTION };\n    }\n\n    if (this.isFreeVar(node)) {\n      let r = resolution(node);\n\n      if (r === null) {\n        return {\n          result: 'error',\n          path: printPath(node),\n          head: printHead(node),\n        };\n      }\n\n      return { result: r };\n    } else {\n      return { result: ASTv2.STRICT_RESOLUTION };\n    }\n  }\n\n  isLexicalVar(variable: string): boolean {\n    return this.table.hasLexical(variable);\n  }\n\n  private isFreeVar(callee: ASTv1.CallNode | ASTv1.PathExpression): boolean {\n    if (callee.type === 'PathExpression') {\n      if (callee.head.type !== 'VarHead') {\n        return false;\n      }\n\n      return !this.table.has(callee.head.name);\n    } else if (callee.path.type === 'PathExpression') {\n      return this.isFreeVar(callee.path);\n    } else {\n      return false;\n    }\n  }\n\n  hasBinding(name: string): boolean {\n    return this.table.has(name) || this.table.hasLexical(name);\n  }\n\n  child(blockParams: string[]): BlockContext<BlockSymbolTable> {\n    return new BlockContext(this.source, this.options, this.table.child(blockParams));\n  }\n\n  customizeComponentName(input: string): string {\n    if (this.options.customizeComponentName) {\n      return this.options.customizeComponentName(input);\n    } else {\n      return input;\n    }\n  }\n}\n\n/**\n * An `ExpressionNormalizer` normalizes expressions within a block.\n *\n * `ExpressionNormalizer` is stateless.\n */\nclass ExpressionNormalizer {\n  constructor(private block: BlockContext) {}\n\n  /**\n   * The `normalize` method takes an arbitrary expression and its original syntax context and\n   * normalizes it to an ASTv2 expression.\n   *\n   * @see {SyntaxContext}\n   */\n  normalize(expr: ASTv1.Literal, resolution: ASTv2.FreeVarResolution): ASTv2.LiteralExpression;\n  normalize(\n    expr: ASTv1.MinimalPathExpression,\n    resolution: ASTv2.FreeVarResolution\n  ): ASTv2.PathExpression;\n  normalize(expr: ASTv1.SubExpression, resolution: ASTv2.FreeVarResolution): ASTv2.CallExpression;\n  normalize(expr: ASTv1.Expression, resolution: ASTv2.FreeVarResolution): ASTv2.ExpressionNode;\n  normalize(\n    expr: ASTv1.Expression | ASTv1.MinimalPathExpression,\n    resolution: ASTv2.FreeVarResolution\n  ): ASTv2.ExpressionNode {\n    switch (expr.type) {\n      case 'NullLiteral':\n      case 'BooleanLiteral':\n      case 'NumberLiteral':\n      case 'StringLiteral':\n      case 'UndefinedLiteral':\n        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));\n      case 'PathExpression':\n        return this.path(expr, resolution);\n      case 'SubExpression': {\n        let resolution = this.block.resolutionFor(expr, SexpSyntaxContext);\n\n        if (resolution.result === 'error') {\n          throw generateSyntaxError(\n            `You attempted to invoke a path (\\`${resolution.path}\\`) but ${resolution.head} was not in scope`,\n            expr.loc\n          );\n        }\n\n        return this.block.builder.sexp(\n          this.callParts(expr, resolution.result),\n          this.block.loc(expr.loc)\n        );\n      }\n    }\n  }\n\n  private path(\n    expr: ASTv1.MinimalPathExpression,\n    resolution: ASTv2.FreeVarResolution\n  ): ASTv2.PathExpression {\n    let headOffsets = this.block.loc(expr.head.loc);\n\n    let tail = [];\n\n    // start with the head\n    let offset = headOffsets;\n\n    for (let part of expr.tail) {\n      offset = offset.sliceStartChars({ chars: part.length, skipStart: 1 });\n      tail.push(\n        new SourceSlice({\n          loc: offset,\n          chars: part,\n        })\n      );\n    }\n\n    return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));\n  }\n\n  /**\n   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes\n   * it to an ASTv2 CallParts.\n   */\n  callParts(parts: ASTv1.CallParts, context: ASTv2.FreeVarResolution): CallParts {\n    let { path, params, hash } = parts;\n\n    let callee = this.normalize(path, context);\n    let paramList = params.map((p) => this.normalize(p, ASTv2.ARGUMENT_RESOLUTION));\n    let paramLoc = SpanList.range(paramList, callee.loc.collapse('end'));\n    let namedLoc = this.block.loc(hash.loc);\n    let argsLoc = SpanList.range([paramLoc, namedLoc]);\n\n    let positional = this.block.builder.positional(\n      params.map((p) => this.normalize(p, ASTv2.ARGUMENT_RESOLUTION)),\n      paramLoc\n    );\n\n    let named = this.block.builder.named(\n      hash.pairs.map((p) => this.namedArgument(p)),\n      this.block.loc(hash.loc)\n    );\n\n    return {\n      callee,\n      args: this.block.builder.args(positional, named, argsLoc),\n    };\n  }\n\n  private namedArgument(pair: ASTv1.HashPair): ASTv2.NamedArgument {\n    let offsets = this.block.loc(pair.loc);\n\n    let keyOffsets = offsets.sliceStartChars({ chars: pair.key.length });\n\n    return this.block.builder.namedArgument(\n      new SourceSlice({ chars: pair.key, loc: keyOffsets }),\n      this.normalize(pair.value, ASTv2.ARGUMENT_RESOLUTION)\n    );\n  }\n\n  /**\n   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.\n   * This method is extremely important, because it is responsible for normalizing free\n   * variables into an an ASTv2.PathHead *with appropriate context*.\n   *\n   * The syntax context is originally determined by the syntactic position that this `PathHead`\n   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,\n   * the `VariableReference` node bears full responsibility for loose mode rules that control\n   * the behavior of free variables.\n   */\n  private ref(head: ASTv1.PathHead, resolution: ASTv2.FreeVarResolution): ASTv2.VariableReference {\n    let { block } = this;\n    let { builder, table } = block;\n    let offsets = block.loc(head.loc);\n\n    switch (head.type) {\n      case 'ThisHead':\n        return builder.self(offsets);\n      case 'AtHead': {\n        let symbol = table.allocateNamed(head.name);\n        return builder.at(head.name, symbol, offsets);\n      }\n      case 'VarHead': {\n        if (block.hasBinding(head.name)) {\n          let [symbol, isRoot] = table.get(head.name);\n\n          return block.builder.localVar(head.name, symbol, isRoot, offsets);\n        } else {\n          let context = block.strict ? ASTv2.STRICT_RESOLUTION : resolution;\n          let symbol = block.table.allocateFree(head.name, context);\n\n          return block.builder.freeVar({\n            name: head.name,\n            context,\n            symbol,\n            loc: offsets,\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.\n */\nclass StatementNormalizer {\n  constructor(private readonly block: BlockContext) {}\n\n  normalize(node: ASTv1.Statement): ASTv2.ContentNode | ASTv2.NamedBlock {\n    switch (node.type) {\n      case 'PartialStatement':\n        throw new Error(`Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer`);\n      case 'BlockStatement':\n        return this.BlockStatement(node);\n      case 'ElementNode':\n        return new ElementNormalizer(this.block).ElementNode(node);\n      case 'MustacheStatement':\n        return this.MustacheStatement(node);\n\n      // These are the same in ASTv2\n      case 'MustacheCommentStatement':\n        return this.MustacheCommentStatement(node);\n\n      case 'CommentStatement': {\n        let loc = this.block.loc(node.loc);\n        return new ASTv2.HtmlComment({\n          loc,\n          text: loc.slice({ skipStart: 4, skipEnd: 3 }).toSlice(node.value),\n        });\n      }\n\n      case 'TextNode':\n        return new ASTv2.HtmlText({\n          loc: this.block.loc(node.loc),\n          chars: node.chars,\n        });\n    }\n  }\n\n  MustacheCommentStatement(node: ASTv1.MustacheCommentStatement): ASTv2.GlimmerComment {\n    let loc = this.block.loc(node.loc);\n    let textLoc: SourceSpan;\n\n    if (loc.asString().slice(0, 5) === '{{!--') {\n      textLoc = loc.slice({ skipStart: 5, skipEnd: 4 });\n    } else {\n      textLoc = loc.slice({ skipStart: 3, skipEnd: 2 });\n    }\n\n    return new ASTv2.GlimmerComment({\n      loc,\n      text: textLoc.toSlice(node.value),\n    });\n  }\n\n  /**\n   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement\n   */\n  MustacheStatement(mustache: ASTv1.MustacheStatement): ASTv2.AppendContent {\n    let { escaped } = mustache;\n    let loc = this.block.loc(mustache.loc);\n\n    // Normalize the call parts in AppendSyntaxContext\n    let callParts = this.expr.callParts(\n      {\n        path: mustache.path,\n        params: mustache.params,\n        hash: mustache.hash,\n      },\n      AppendSyntaxContext(mustache)\n    );\n\n    let value = callParts.args.isEmpty()\n      ? callParts.callee\n      : this.block.builder.sexp(callParts, loc);\n\n    return this.block.builder.append(\n      {\n        table: this.block.table,\n        trusting: !escaped,\n        value,\n      },\n      loc\n    );\n  }\n\n  /**\n   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement\n   */\n  BlockStatement(block: ASTv1.BlockStatement): ASTv2.InvokeBlock {\n    let { program, inverse } = block;\n    let loc = this.block.loc(block.loc);\n\n    let resolution = this.block.resolutionFor(block, BlockSyntaxContext);\n\n    if (resolution.result === 'error') {\n      throw generateSyntaxError(\n        `You attempted to invoke a path (\\`{{#${resolution.path}}}\\`) but ${resolution.head} was not in scope`,\n        loc\n      );\n    }\n\n    let callParts = this.expr.callParts(block, resolution.result);\n\n    return this.block.builder.blockStatement(\n      assign(\n        {\n          symbols: this.block.table,\n          program: this.Block(program),\n          inverse: inverse ? this.Block(inverse) : null,\n        },\n        callParts\n      ),\n      loc\n    );\n  }\n\n  Block({ body, loc, blockParams }: ASTv1.Block): ASTv2.Block {\n    let child = this.block.child(blockParams);\n    let normalizer = new StatementNormalizer(child);\n    return new BlockChildren(\n      this.block.loc(loc),\n      body.map((b) => normalizer.normalize(b)),\n      this.block\n    ).assertBlock(child.table);\n  }\n\n  private get expr(): ExpressionNormalizer {\n    return new ExpressionNormalizer(this.block);\n  }\n}\n\nclass ElementNormalizer {\n  constructor(private readonly ctx: BlockContext) {}\n\n  /**\n   * Normalizes an ASTv1.ElementNode to:\n   *\n   * - ASTv2.NamedBlock if the tag name begins with `:`\n   * - ASTv2.Component if the tag name matches the component heuristics\n   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics\n   *\n   * A tag name represents a component if:\n   *\n   * - it begins with `@`\n   * - it is exactly `this` or begins with `this.`\n   * - the part before the first `.` is a reference to an in-scope variable binding\n   * - it begins with an uppercase character\n   */\n  ElementNode(element: ASTv1.ElementNode): ASTv2.ElementNode {\n    let { tag, selfClosing, comments } = element;\n    let loc = this.ctx.loc(element.loc);\n\n    let [tagHead, ...rest] = asPresentArray(tag.split('.'));\n\n    // the head, attributes and modifiers are in the current scope\n    let path = this.classifyTag(tagHead, rest, element.loc);\n\n    let attrs = element.attributes.filter((a) => a.name[0] !== '@').map((a) => this.attr(a));\n    let args = element.attributes.filter((a) => a.name[0] === '@').map((a) => this.arg(a));\n\n    let modifiers = element.modifiers.map((m) => this.modifier(m));\n\n    // the element's block params are in scope for the children\n    let child = this.ctx.child(element.blockParams);\n    let normalizer = new StatementNormalizer(child);\n\n    let childNodes = element.children.map((s) => normalizer.normalize(s));\n\n    let el = this.ctx.builder.element({\n      selfClosing,\n      attrs,\n      componentArgs: args,\n      modifiers,\n      comments: comments.map((c) => new StatementNormalizer(this.ctx).MustacheCommentStatement(c)),\n    });\n\n    let children = new ElementChildren(el, loc, childNodes, this.ctx);\n\n    let offsets = this.ctx.loc(element.loc);\n    let tagOffsets = offsets.sliceStartChars({ chars: tag.length, skipStart: 1 });\n\n    if (path === 'ElementHead') {\n      if (tag[0] === ':') {\n        return children.assertNamedBlock(\n          tagOffsets.slice({ skipStart: 1 }).toSlice(tag.slice(1)),\n          child.table\n        );\n      } else {\n        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);\n      }\n    }\n\n    if (element.selfClosing) {\n      return el.selfClosingComponent(path, loc);\n    } else {\n      let blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);\n      return el.componentWithNamedBlocks(path, blocks, loc);\n    }\n  }\n\n  private modifier(m: ASTv1.ElementModifierStatement): ASTv2.ElementModifier {\n    let resolution = this.ctx.resolutionFor(m, ModifierSyntaxContext);\n\n    if (resolution.result === 'error') {\n      throw generateSyntaxError(\n        `You attempted to invoke a path (\\`{{#${resolution.path}}}\\`) as a modifier, but ${resolution.head} was not in scope. Try adding \\`this\\` to the beginning of the path`,\n        m.loc\n      );\n    }\n\n    let callParts = this.expr.callParts(m, resolution.result);\n    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));\n  }\n\n  /**\n   * This method handles attribute values that are curlies, as well as curlies nested inside of\n   * interpolations:\n   *\n   * ```hbs\n   * <a href={{url}} />\n   * <a href=\"{{url}}.html\" />\n   * ```\n   */\n  private mustacheAttr(mustache: ASTv1.MustacheStatement): ASTv2.ExpressionNode {\n    // Normalize the call parts in AttrValueSyntaxContext\n    let sexp = this.ctx.builder.sexp(\n      this.expr.callParts(mustache, AttrValueSyntaxContext(mustache)),\n      this.ctx.loc(mustache.loc)\n    );\n\n    // If there are no params or hash, just return the function part as its own expression\n    if (sexp.args.isEmpty()) {\n      return sexp.callee;\n    } else {\n      return sexp;\n    }\n  }\n\n  /**\n   * attrPart is the narrowed down list of valid attribute values that are also\n   * allowed as a concat part (you can't nest concats).\n   */\n  private attrPart(part: ASTv1.MustacheStatement | ASTv1.TextNode): {\n    expr: ASTv2.ExpressionNode;\n    trusting: boolean;\n  } {\n    switch (part.type) {\n      case 'MustacheStatement':\n        return { expr: this.mustacheAttr(part), trusting: !part.escaped };\n      case 'TextNode':\n        return {\n          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),\n          trusting: true,\n        };\n    }\n  }\n\n  private attrValue(part: ASTv1.MustacheStatement | ASTv1.TextNode | ASTv1.ConcatStatement): {\n    expr: ASTv2.ExpressionNode;\n    trusting: boolean;\n  } {\n    switch (part.type) {\n      case 'ConcatStatement': {\n        let parts = part.parts.map((p) => this.attrPart(p).expr);\n        return {\n          expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),\n          trusting: false,\n        };\n      }\n      default:\n        return this.attrPart(part);\n    }\n  }\n\n  private attr(m: ASTv1.AttrNode): ASTv2.HtmlOrSplatAttr {\n    assert(m.name[0] !== '@', 'An attr name must not start with `@`');\n\n    if (m.name === '...attributes') {\n      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));\n    }\n\n    let offsets = this.ctx.loc(m.loc);\n    let nameSlice = offsets.sliceStartChars({ chars: m.name.length }).toSlice(m.name);\n\n    let value = this.attrValue(m.value);\n    return this.ctx.builder.attr(\n      { name: nameSlice, value: value.expr, trusting: value.trusting },\n      offsets\n    );\n  }\n\n  private maybeDeprecatedCall(\n    arg: SourceSlice,\n    part: ASTv1.MustacheStatement | ASTv1.TextNode | ASTv1.ConcatStatement\n  ): { expr: ASTv2.DeprecatedCallExpression; trusting: boolean } | null {\n    if (this.ctx.strict) {\n      return null;\n    }\n\n    if (part.type !== 'MustacheStatement') {\n      return null;\n    }\n\n    let { path } = part;\n\n    if (path.type !== 'PathExpression') {\n      return null;\n    }\n\n    if (path.head.type !== 'VarHead') {\n      return null;\n    }\n\n    let { name } = path.head;\n\n    if (name === 'has-block' || name === 'has-block-params') {\n      return null;\n    }\n\n    if (this.ctx.hasBinding(name)) {\n      return null;\n    }\n\n    if (path.tail.length !== 0) {\n      return null;\n    }\n\n    if (part.params.length !== 0 || part.hash.pairs.length !== 0) {\n      return null;\n    }\n\n    let context = ASTv2.LooseModeResolution.attr();\n\n    let callee = this.ctx.builder.freeVar({\n      name,\n      context,\n      symbol: this.ctx.table.allocateFree(name, context),\n      loc: path.loc,\n    });\n\n    return {\n      expr: this.ctx.builder.deprecatedCall(arg, callee, part.loc),\n      trusting: false,\n    };\n  }\n\n  private arg(arg: ASTv1.AttrNode): ASTv2.ComponentArg {\n    assert(arg.name[0] === '@', 'An arg name must start with `@`');\n\n    let offsets = this.ctx.loc(arg.loc);\n    let nameSlice = offsets.sliceStartChars({ chars: arg.name.length }).toSlice(arg.name);\n\n    let value = this.maybeDeprecatedCall(nameSlice, arg.value) || this.attrValue(arg.value);\n    return this.ctx.builder.arg(\n      { name: nameSlice, value: value.expr, trusting: value.trusting },\n      offsets\n    );\n  }\n\n  /**\n   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the\n   * element is a component) or `'ElementHead'` (if the element is a simple element).\n   *\n   * Rules:\n   *\n   * 1. If the variable is an `@arg`, return an `AtHead`\n   * 2. If the variable is `this`, return a `ThisHead`\n   * 3. If the variable is in the current scope:\n   *   a. If the scope is the root scope, then return a Free `LocalVarHead`\n   *   b. Else, return a standard `LocalVarHead`\n   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error\n   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)\n   * 6. Otherwise, return `'ElementHead'`\n   */\n  private classifyTag(\n    variable: string,\n    tail: string[],\n    loc: SourceSpan\n  ): ASTv2.ExpressionNode | 'ElementHead' {\n    let uppercase = isUpperCase(variable);\n    let inScope = variable[0] === '@' || variable === 'this' || this.ctx.hasBinding(variable);\n\n    if (this.ctx.strict && !inScope) {\n      if (uppercase) {\n        throw generateSyntaxError(\n          `Attempted to invoke a component that was not in scope in a strict mode template, \\`<${variable}>\\`. If you wanted to create an element with that name, convert it to lowercase - \\`<${variable.toLowerCase()}>\\``,\n          loc\n        );\n      }\n\n      // In strict mode, values are always elements unless they are in scope\n      return 'ElementHead';\n    }\n\n    // Since the parser handed us the HTML element name as a string, we need\n    // to convert it into an ASTv1 path so it can be processed using the\n    // expression normalizer.\n    let isComponent = inScope || uppercase;\n\n    let variableLoc = loc.sliceStartChars({ skipStart: 1, chars: variable.length });\n\n    let tailLength = tail.reduce((accum, part) => accum + 1 + part.length, 0);\n    let pathEnd = variableLoc.getEnd().move(tailLength);\n    let pathLoc = variableLoc.withEnd(pathEnd);\n\n    if (isComponent) {\n      let path = b.path({\n        head: b.head(variable, variableLoc),\n        tail,\n        loc: pathLoc,\n      });\n\n      let resolution = this.ctx.isLexicalVar(variable)\n        ? { result: ASTv2.STRICT_RESOLUTION }\n        : this.ctx.resolutionFor(path, ComponentSyntaxContext);\n\n      if (resolution.result === 'error') {\n        throw generateSyntaxError(\n          `You attempted to invoke a path (\\`<${resolution.path}>\\`) but ${resolution.head} was not in scope`,\n          loc\n        );\n      }\n\n      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.result);\n    } else {\n      this.ctx.table.allocateFree(variable, ASTv2.STRICT_RESOLUTION);\n    }\n\n    // If the tag name wasn't a valid component but contained a `.`, it's\n    // a syntax error.\n    if (tail.length > 0) {\n      throw generateSyntaxError(\n        `You used ${variable}.${tail.join('.')} as a tag name, but ${variable} is not in scope`,\n        loc\n      );\n    }\n\n    return 'ElementHead';\n  }\n\n  private get expr(): ExpressionNormalizer {\n    return new ExpressionNormalizer(this.ctx);\n  }\n}\n\nclass Children {\n  readonly namedBlocks: ASTv2.NamedBlock[];\n  readonly hasSemanticContent: boolean;\n  readonly nonBlockChildren: ASTv2.ContentNode[];\n\n  constructor(\n    readonly loc: SourceSpan,\n    readonly children: (ASTv2.ContentNode | ASTv2.NamedBlock)[],\n    readonly block: BlockContext\n  ) {\n    this.namedBlocks = children.filter((c): c is ASTv2.NamedBlock => c instanceof ASTv2.NamedBlock);\n    this.hasSemanticContent = Boolean(\n      children.filter((c): c is ASTv2.ContentNode => {\n        if (c instanceof ASTv2.NamedBlock) {\n          return false;\n        }\n        switch (c.type) {\n          case 'GlimmerComment':\n          case 'HtmlComment':\n            return false;\n          case 'HtmlText':\n            return !/^\\s*$/u.test(c.chars);\n          default:\n            return true;\n        }\n      }).length\n    );\n    this.nonBlockChildren = children.filter(\n      (c): c is ASTv2.ContentNode => !(c instanceof ASTv2.NamedBlock)\n    );\n  }\n}\n\nclass TemplateChildren extends Children {\n  assertTemplate(table: ProgramSymbolTable): ASTv2.Template {\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(`Unexpected named block at the top-level of a template`, this.loc);\n    }\n\n    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));\n  }\n}\n\nclass BlockChildren extends Children {\n  assertBlock(table: BlockSymbolTable): ASTv2.Block {\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(`Unexpected named block nested in a normal block`, this.loc);\n    }\n\n    return this.block.builder.block(table, this.nonBlockChildren, this.loc);\n  }\n}\n\nclass ElementChildren extends Children {\n  constructor(\n    private el: BuildElement,\n    loc: SourceSpan,\n    children: (ASTv2.ContentNode | ASTv2.NamedBlock)[],\n    block: BlockContext\n  ) {\n    super(loc, children, block);\n  }\n\n  assertNamedBlock(name: SourceSlice, table: BlockSymbolTable): ASTv2.NamedBlock {\n    if (this.el.base.selfClosing) {\n      throw generateSyntaxError(\n        `<:${name.chars}/> is not a valid named block: named blocks cannot be self-closing`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      throw generateSyntaxError(\n        `Unexpected named block inside <:${name.chars}> named block: named blocks cannot contain nested named blocks`,\n        this.loc\n      );\n    }\n\n    if (!isLowerCase(name.chars)) {\n      throw generateSyntaxError(\n        `<:${name.chars}> is not a valid named block, and named blocks must begin with a lowercase letter`,\n        this.loc\n      );\n    }\n\n    if (\n      this.el.base.attrs.length > 0 ||\n      this.el.base.componentArgs.length > 0 ||\n      this.el.base.modifiers.length > 0\n    ) {\n      throw generateSyntaxError(\n        `named block <:${name.chars}> cannot have attributes, arguments, or modifiers`,\n        this.loc\n      );\n    }\n\n    let offsets = SpanList.range(this.nonBlockChildren, this.loc);\n\n    return this.block.builder.namedBlock(\n      name,\n      this.block.builder.block(table, this.nonBlockChildren, offsets),\n      this.loc\n    );\n  }\n\n  assertElement(name: SourceSlice, hasBlockParams: boolean): ASTv2.SimpleElement {\n    if (hasBlockParams) {\n      throw generateSyntaxError(\n        `Unexpected block params in <${name}>: simple elements cannot have block params`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      let names = this.namedBlocks.map((b) => b.name);\n\n      if (names.length === 1) {\n        throw generateSyntaxError(\n          `Unexpected named block <:foo> inside <${name.chars}> HTML element`,\n          this.loc\n        );\n      } else {\n        let printedNames = names.map((n) => `<:${n.chars}>`).join(', ');\n        throw generateSyntaxError(\n          `Unexpected named blocks inside <${name.chars}> HTML element (${printedNames})`,\n          this.loc\n        );\n      }\n    }\n\n    return this.el.simple(name, this.nonBlockChildren, this.loc);\n  }\n\n  assertComponent(\n    name: string,\n    table: BlockSymbolTable,\n    hasBlockParams: boolean\n  ): PresentArray<ASTv2.NamedBlock> {\n    if (isPresentArray(this.namedBlocks) && this.hasSemanticContent) {\n      throw generateSyntaxError(\n        `Unexpected content inside <${name}> component invocation: when using named blocks, the tag cannot contain other content`,\n        this.loc\n      );\n    }\n\n    if (isPresentArray(this.namedBlocks)) {\n      if (hasBlockParams) {\n        throw generateSyntaxError(\n          `Unexpected block params list on <${name}> component invocation: when passing named blocks, the invocation tag cannot take block params`,\n          this.loc\n        );\n      }\n\n      let seenNames = new Set<string>();\n\n      for (let block of this.namedBlocks) {\n        let name = block.name.chars;\n\n        if (seenNames.has(name)) {\n          throw generateSyntaxError(\n            `Component had two named blocks with the same name, \\`<:${name}>\\`. Only one block with a given name may be passed`,\n            this.loc\n          );\n        }\n\n        if (\n          (name === 'inverse' && seenNames.has('else')) ||\n          (name === 'else' && seenNames.has('inverse'))\n        ) {\n          throw generateSyntaxError(\n            `Component has both <:else> and <:inverse> block. <:inverse> is an alias for <:else>`,\n            this.loc\n          );\n        }\n\n        seenNames.add(name);\n      }\n\n      return this.namedBlocks;\n    } else {\n      return [\n        this.block.builder.namedBlock(\n          SourceSlice.synthetic('default'),\n          this.block.builder.block(table, this.nonBlockChildren, this.loc),\n          this.loc\n        ),\n      ];\n    }\n  }\n}\n\nfunction printPath(node: ASTv1.PathExpression | ASTv1.CallNode): string {\n  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {\n    return printPath(node.path);\n  } else {\n    return new Printer({ entityEncoding: 'raw' }).print(node);\n  }\n}\n\nfunction printHead(node: ASTv1.PathExpression | ASTv1.CallNode): string {\n  if (node.type === 'PathExpression') {\n    switch (node.head.type) {\n      case 'AtHead':\n      case 'VarHead':\n        return node.head.name;\n      case 'ThisHead':\n        return 'this';\n    }\n  } else if (node.path.type === 'PathExpression') {\n    return printHead(node.path);\n  } else {\n    return new Printer({ entityEncoding: 'raw' }).print(node);\n  }\n}\n"],"names":["Char","ATTR_VALUE_REGEX_TEST","ATTR_VALUE_REGEX_REPLACE","RegExp","source","TEXT_REGEX_TEST","TEXT_REGEX_REPLACE","attrValueReplacer","char","charCodeAt","NBSP","QUOT","AMP","textReplacer","LT","GT","sortByLoc","a","b","loc","isInvisible","startPosition","line","column","voidMap","Set","getVoidTags","NON_WHITESPACE","isVoidTag","tag","has","toLowerCase","Printer","buffer","options","constructor","this","handledByOverride","node","ensureLeadingWhitespace","undefined","override","result","test","Node","type","TopLevelStatement","Expression","Block","ConcatStatement","Hash","HashPair","ElementModifierStatement","expression","Literal","PathExpression","SubExpression","literal","StringLiteral","BooleanLiteral","NumberLiteral","UndefinedLiteral","NullLiteral","statement","MustacheStatement","BlockStatement","PartialStatement","MustacheCommentStatement","CommentStatement","TextNode","ElementNode","AttrNode","block","chained","body","TopLevelStatements","statements","forEach","el","OpenElementNode","children","CloseElementNode","parts","attributes","modifiers","comments","sort","part","blockParams","length","BlockParams","selfClosing","attr","name","value","chars","AttrNodeValue","text","isAttr","attrValue","entityEncoding","replace","escapeText","mustache","escaped","strip","open","path","Params","params","hash","close","inverseStrip","openStrip","program","inverse","closeStrip","join","partial","concat","comment","mod","original","sexp","param","pairs","pair","key","str","JSON","stringify","bool","number","print","build","ast","isKeyword","word","KEYWORDS_TYPES","component","debugger","each","helper","if","let","log","modifier","mount","mut","outlet","readonly","unbound","unless","with","yield","UNKNOWN_POSITION","Object","freeze","SYNTHETIC_LOCATION","start","end","NON_EXISTENT_LOCATION","BROKEN_LOCATION","OffsetKind","MatchAny","IsInvisible","WhenList","_whens","whens","first","kind","when","match","isPresentArray","When","_map","Map","get","pattern","or","set","add","out","Broken","InternalsSynthetic","NonExistent","patternFor","exact","fallback","push","callback","Matcher","check","left","right","matchFor","nesteds","assert","LOCAL_DEBUG","window","location","search","SourceSlice","synthetic","offsets","src","load","slice","getString","serialize","SourceSpan","NON_EXISTENT","InvisibleSpan","wrap","serialized","forCharPositions","Array","isArray","broken","assertNever","forHbsLoc","HbsPosition","HbsSpan","startPos","endPos","CharPosition","CharPositionSpan","pos","data","getStart","getEnd","span","toHbsSpan","toHbsLoc","module","getModule","endPosition","toJSON","withStart","other","withEnd","asString","toSlice","expected","console","warn","position","locDidUpdate","collapse","where","collapsed","extend","skipStart","skipEnd","move","sliceStartChars","sliceEndChars","_locPosSpan","charPositions","charPos","locPosSpan","toHbsPos","BROKEN","toCharPosSpan","_charPosSpan","_providedHbsLoc","hbsPositions","providedHbsLoc","updateProvided","edge","hbsPos","charPosSpan","toCharPos","string","InvisiblePosition","m","rightCharPos","leftCharPos","_","SourceOffset","forHbsPos","offset","eql","until","by","_locPos","hbs","locPos","hbsPosFor","_charPos","charPosNumber","charPosFor","Source","from","meta","moduleName","offsetFor","spanFor","seenLines","seenChars","nextLine","indexOf","sourceLength","roundTrip","SpanList","range","map","getRangeOffset","_span","getFirst","last","getLast","hasSpan","maybeLoc","generateSyntaxError","message","code","quotedCode","split","error","Error","visitorKeys","Program","Template","ElementStartNode","ElementPartNode","ElementEndNode","ElementNameNode","PathHead","BlockParam","NamedBlock","SimpleElement","Component","TraversalError","parent","call","stack","prototype","create","cannotRemoveNode","cannotReplaceNode","cannotReplaceOrRemoveInKeyHandlerYet","WalkerPath","parentKey","parentNode","parents","Symbol","iterator","PathParentsIterator","next","done","getEnterFunction","handler","enter","getExitFunction","exit","visitNode","visitor","nodeType","deprecate","All","getNodeHandler","visitArray","keys","i","visitKey","keyEnter","keyExit","keyHandler","keyVisitor","getKeyHandler","assignKey","array","unwrap","spliceArray","index","splice","traverse","Walker","order","visit","pop","visitors","walker","walkBody","child","_SOURCE","ID_INVERSE_PATTERN","parseElementBlockParams","element","l","attrNames","asIndex","charAt","paramsString","expect","startsWith","endsWith","parseBlockParams","blockParamNodes","p","appendChild","childrenFor","isHBSLiteral","SOURCE","headToString","head","buildHead","headNode","tail","asPresentArray","buildLoc","buildThis","buildAtName","buildVar","buildPath","originalHead","PathExpressionImplV1","buildLiteral","buildHash","args","startLine","startColumn","endLine","endColumn","_source","publicBuilder","raw","trusting","_defaultBlock","_elseBlock","defaultBlock","elseBlock","assign","indent","mustacheComment","tagName","attrs","nameNode","startTag","endTag","t","x","elementModifier","sexpr","blockItself","template","fullPath","headParts","at","var","blockName","boolean","null","unshift","_head","firstPart","assertPresentArray","firstPartLoc","DEFAULT_STRIP","atName","Parser","elementStack","lines","currentAttribute","currentNode","tokenizer","entityParser","EntityParser","namedCharRefs","mode","EventedTokenizer","finish","currentAttr","currentTag","currentStartTag","currentEndTag","currentComment","currentData","acceptTemplate","acceptNode","currentElement","sourceForNode","endNode","lastLine","lastColumn","firstLine","currentLine","firstColumn","BEFORE_ATTRIBUTE_NAME","HandlebarsNodeVisitors","isTopLevel","poppedNode","elementNode","state","appendToCommentData","acceptCallNodes","blockRange","idx","exec","parseProgramBlockParamsLocs","rawMustache","addElementModifier","beginAttributeValue","finishAttributeValue","transitionTo","appendDynamicAttributeValuePart","finalizeTextPart","isDynamic","currentPart","startTextPart","ContentStatement","content","columns","difference","lineCount","calculateRightStrippedOffsets","updateTokenizerLocation","tokenizePart","flushData","rawComment","PartialBlockStatement","partialBlock","Decorator","decorator","DecoratorBlock","decoratorBlock","pathHead","thisHead","shift","undef","nul","compiler","toString","e","printLiteral","TokenizerEventHandlers","tagOpenLine","tagOpenColumn","reset","beginComment","finishComment","beginData","appendToData","finishData","tagOpen","beginStartTag","beginEndTag","finishTag","finishStartTag","finishEndTag","elementRange","codeSlice","parseElementPartLocs","isVoid","validateEndTag","markTagAsSelfClosing","appendToTagName","beginAttribute","isQuoted","valueSpan","appendToAttributeName","appendToAttributeValue","lastPart","current","tokenizerPos","assembleAttributeValue","attribute","reportSyntaxError","assembleConcatenatedValue","syntax","parse","preprocess","builders","CodemodEntityParser","super","input","parseWithoutProcessing","parseOptions","strictMode","locals","plugins","transform","addTokens","tokensSet","scopedTokens","maybeTokens","possbleToken","includeHtmlElements","substr","includes","potentialLocal","tokensFromType","maybeToken","maybeTokenFirstSegment","getTemplateLocals","html","includeKeywords","tokens","s","filter","token","fields","Args","empty","positional","PositionalArguments","named","NamedArguments","nth","isEmpty","exprs","size","entries","entry","NamedArgument","HtmlAttr","SplatAttr","ComponentArg","toNamedArgument","ElementModifier","GlimmerComment","HtmlText","HtmlComment","AppendContent","callee","InvokeBlock","InvokeComponent","componentArgs","LiteralExpression","CallExpression","DeprecatedCallExpression","InterpolateExpression","NamedBlocks","blocks","ThisReference","ArgReference","LocalVarReference","FreeVarReference","STRICT_RESOLUTION","resolution","SexpOpcodes","GetStrictKeyword","isAngleBracket","HTML_RESOLUTION","LooseModeResolution","namespaced","namespace","namespaces","append","invoke","FreeVarNamespace","Helper","trustingAppend","ambiguity","GetFreeAsComponentOrHelperHeadOrThisFallback","GetFreeAsComponentOrHelperHead","GetFreeAsHelperHeadOrThisFallback","GetFreeAsHelperHead","Modifier","GetFreeAsModifierHead","GetFreeAsComponentHead","SerializedAmbiguity","Attr","Append","Invoke","ARGUMENT_RESOLUTION","HELPER_NAMESPACE","MODIFIER_NAMESPACE","COMPONENT_NAMESPACE","SymbolTable","top","ProgramSymbolTable","symbols","allocate","BlockSymbolTable","templateLocals","upvars","dict","usedTemplateLocals","hasDebugger","hasLexical","lexicalScope","getLexical","allocateFree","ASTv2","getUsedTemplateLocals","setHasDebugger","hasEval","getLocalsMap","getDebugInfo","values","customizeComponentName","allocateNamed","allocateBlock","identifier","slots","local","slot","symbol","Builder","table","scope","namedBlock","simpleNamedBlock","BuildElement","namedArgument","splatAttr","arg","ref","self","freeVar","context","localVar","isTemplateLocal","deprecatedCall","interpolate","namedBlocks","blockStatement","blocksLoc","builder","base","simple","selfClosingComponent","componentWithDefaultBlock","componentWithNamedBlocks","SexpSyntaxContext","isSimpleCallee","ModifierSyntaxContext","BlockSyntaxContext","ComponentSyntaxContext","isSimplePath","isInvokeNode","normalize","normalizeOptions","BlockContext","normalizer","StatementNormalizer","astV2","TemplateChildren","assertTemplate","strict","resolutionFor","isFreeVar","r","printPath","printHead","isLexicalVar","variable","hasBinding","ExpressionNormalizer","expr","callParts","paramList","paramLoc","namedLoc","argsLoc","keyOffsets","isRoot","ElementNormalizer","textLoc","isSimple","isInvoke","AppendSyntaxContext","BlockChildren","assertBlock","ctx","tagHead","rest","classifyTag","childNodes","c","ElementChildren","tagOffsets","assertNamedBlock","assertElement","assertComponent","mustacheAttr","AttrValueSyntaxContext","attrPart","nameSlice","maybeDeprecatedCall","uppercase","toUpperCase","inScope","isComponent","variableLoc","tailLength","reduce","accum","pathEnd","pathLoc","Children","hasSemanticContent","nonBlockChildren","Boolean","hasBlockParams","names","printedNames","n","seenNames"],"mappings":"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"}