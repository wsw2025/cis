"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTemplatesFromAst = exports.parseTemplates = exports.DEFAULT_PARSE_TEMPLATES_OPTIONS = exports.isTemplateLiteralMatch = void 0;
const traverse_1 = __importDefault(require("@babel/traverse"));
const util_1 = require("./util");
const template_parser_1 = __importDefault(require("./template-parser"));
function isTemplateLiteralMatch(template) {
    return template.type === 'template-literal';
}
exports.isTemplateLiteralMatch = isTemplateLiteralMatch;
exports.DEFAULT_PARSE_TEMPLATES_OPTIONS = {
    templateTag: util_1.TEMPLATE_TAG_NAME
};
/**
 * Parses a template to find all possible valid matches for an embedded template.
 * Supported syntaxes are template literals:
 *
 *   hbs`Hello, world!`
 *
 * And template tags
 *
 *   <template></template>
 *
 * The parser excludes any values found within strings recursively, and also
 * excludes any string literals with dynamic segments (e.g `${}`) since these
 * cannot be valid templates.
 *
 * @param template The template to parse
 * @param relativePath Relative file path for the template (for errors)
 * @param options optional configuration options for how to parse templates
 * @returns
 */
function parseTemplates(template, relativePath, options = exports.DEFAULT_PARSE_TEMPLATES_OPTIONS) {
    options.templateTag = options.templateTag || util_1.TEMPLATE_TAG_NAME;
    const ast = (0, template_parser_1.default)(template, options);
    return parseTemplatesFromAst(ast);
}
exports.parseTemplates = parseTemplates;
function parseTemplatesFromAst(ast) {
    const results = [];
    (0, traverse_1.default)(ast, {
        // @ts-ignore
        enter(path) {
            const node = path.node;
            if (node.type === 'EmberTemplate') {
                results.push({
                    type: 'template-tag',
                    tagName: node.tagName,
                    contents: node.contentNode.quasis[0].value.raw,
                    contentRange: node.contentNode.range,
                    range: node.range,
                    startRange: {
                        start: node.startRange[0],
                        end: node.startRange[1],
                    },
                    endRange: { start: node.endRange[0], end: node.endRange[1] },
                });
            }
        }
    });
    return results;
}
exports.parseTemplatesFromAst = parseTemplatesFromAst;
