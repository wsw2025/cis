"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.doTransform = exports.transform = exports.transformForLint = void 0;
const template_parser_1 = __importDefault(require("./template-parser"));
const parse_templates_1 = require("./parse-templates");
const types_1 = require("@babel/types");
const traverse_1 = __importDefault(require("@babel/traverse"));
const generator_1 = __importDefault(require("@babel/generator"));
const syntax_1 = require("@glimmer/syntax");
const syntax_2 = require("@glimmer/syntax");
const types_2 = require("@babel/types");
types_2.TYPES.push('EmberTemplate');
function minify(htmlContent) {
    const ast = (0, syntax_2.preprocess)(htmlContent, { mode: 'codemod' });
    (0, syntax_2.traverse)(ast, {
        TextNode(node) {
            node.chars = node.chars.replace(/ {2,}/g, ' ').replace(/[\r\n\t\f\v]/g, '');
        }
    });
    return (0, syntax_2.print)(ast);
}
function buildScope(path, options) {
    const locals = options.getTemplateLocals(path.node.contentNode.quasis[0].value.raw);
    const localsWithtemplateTags = options.getTemplateLocals(path.node.contentNode.quasis[0].value.raw, { includeHtmlElements: true });
    const templateTags = localsWithtemplateTags.filter(l => !locals.includes(l) && path.scope.hasBinding(l));
    const all = [...locals, ...templateTags];
    const properties = all.map(l => {
        const id = l.split('.')[0];
        return (0, types_1.objectProperty)((0, types_1.identifier)(id), (0, types_1.identifier)(id), false, true);
    });
    const arrow = (0, types_1.arrowFunctionExpression)([(0, types_1.identifier)('instance')], (0, types_1.objectExpression)(properties));
    return (0, types_1.objectProperty)((0, types_1.identifier)('scope'), arrow);
}
function buildEval() {
    return (0, types_1.objectMethod)('method', (0, types_1.identifier)('eval'), [], (0, types_1.blockStatement)([
        (0, types_1.returnStatement)((0, types_1.callExpression)((0, types_1.identifier)('eval'), [(0, types_1.memberExpression)((0, types_1.identifier)('arguments'), (0, types_1.numericLiteral)(0), true)]))
    ]));
}
function buildTemplateCall(id, path, options) {
    var _a;
    let content = path.node.contentNode.quasis[0].value.raw;
    if (!options.linterMode) {
        if ('trim' in path.node.tagProperties) {
            content = content.trim();
        }
        if ('minify' in path.node.tagProperties) {
            content = minify(content);
        }
    }
    else {
        const startLen = path.node.startRange[1] - path.node.startRange[0];
        const endLen = path.node.endRange[1] - path.node.endRange[0];
        content = ' '.repeat(startLen - 1) + content + ' '.repeat(endLen - 1);
    }
    const literal = (0, types_1.templateLiteral)([(0, types_1.templateElement)({ raw: '' })], []);
    literal.quasis[0].loc = path.node.contentNode.loc;
    literal.quasis[0].value.raw = content;
    literal.quasis[0].value.cooked = content;
    if (options.linterMode) {
        return literal;
    }
    let optionsExpression;
    const explicit = options.explicit;
    const property = explicit ? buildScope(path, options) : buildEval();
    const isInClass = ((_a = path.parent) === null || _a === void 0 ? void 0 : _a.type) === 'ClassBody';
    if (isInClass) {
        optionsExpression = (0, types_1.objectExpression)([
            (0, types_1.objectProperty)((0, types_1.identifier)('component'), (0, types_1.identifier)('this')),
            (0, types_1.objectProperty)((0, types_1.identifier)('moduleName'), (0, types_1.stringLiteral)(options.moduleName)),
            property
        ]);
    }
    else {
        optionsExpression = (0, types_1.objectExpression)([
            (0, types_1.objectProperty)((0, types_1.identifier)('moduleName'), (0, types_1.stringLiteral)(options.moduleName)),
            property
        ]);
    }
    const callId = (0, types_1.identifier)(id);
    path.state.calls.push(callId);
    return (0, types_1.callExpression)(callId, [
        literal,
        optionsExpression
    ]);
}
function ensureImport(path, options) {
    let templateCallSpecifier = path.state.templateCallSpecifier || 'template';
    if (options.linterMode) {
        return templateCallSpecifier;
    }
    const id = (0, types_1.identifier)(templateCallSpecifier);
    const imp = (0, types_1.importDeclaration)([(0, types_1.importSpecifier)(id, (0, types_1.identifier)('template'))], (0, types_1.stringLiteral)('@ember/template-compiler'));
    if (!path.state.addedImport) {
        path.state.addedImport = id;
        path.state.program.node.body.splice(0, 0, imp);
    }
    return templateCallSpecifier;
}
const TemplateTransformPlugins = (babel, options) => {
    return {
        name: 'TemplateTransform',
        visitor: {
            enter(path) {
                var _a;
                if (path.node.type !== 'EmberTemplate')
                    return;
                ;
                const specifier = ensureImport(path, options);
                if (((_a = path.parent) === null || _a === void 0 ? void 0 : _a.type) === 'ClassBody') {
                    const templateExpr = buildTemplateCall(specifier, path, options);
                    templateExpr.loc = path.node.loc;
                    if (options.linterMode) {
                        const staticCallLen = 9; // 'static{;}'.length;
                        const content = templateExpr.quasis[0].value.raw;
                        templateExpr.quasis[0].value.raw = content.slice(7, -2);
                    }
                    const staticB = (0, types_1.staticBlock)([(0, types_1.expressionStatement)(templateExpr)]);
                    path.node.replacedWith = staticB;
                    path.replaceWith(staticB);
                }
                else {
                    const templateExpr = buildTemplateCall(specifier, path, options);
                    templateExpr.loc = path.node.loc;
                    if (path.parent.type === 'Program' && !options.linterMode) {
                        const exportDefault = (0, types_1.exportDefaultDeclaration)(templateExpr);
                        path.node.replacedWith = exportDefault;
                        path.replaceWith(exportDefault);
                        return;
                    }
                    path.node.replacedWith = templateExpr;
                    path.replaceWith(templateExpr);
                }
            },
            Program: {
                enter(path) {
                    path.state = {};
                    path.state.program = path;
                    path.state.calls = [];
                    path.state.identifiers = new Set();
                },
                exit(path) {
                    let counter = 1;
                    let templateCallSpecifier = 'template';
                    while (path.state.identifiers.has(templateCallSpecifier)) {
                        templateCallSpecifier = `template${counter}`;
                        counter += 1;
                    }
                    path.state.calls.forEach((c) => {
                        c.name = templateCallSpecifier;
                    });
                    path.state.program.node.templateCallSpecifier = path.state.templateCallSpecifier;
                    if (path.state.addedImport) {
                        path.state.addedImport.name = templateCallSpecifier;
                    }
                }
            },
            Identifier(path) {
                if (path.state.calls.some((c) => c === path.node))
                    return;
                path.state.identifiers.add(path.node.name);
            }
        }
    };
};
function replaceRange(s, start, end, substitute) {
    return s.substring(0, start) + substitute + s.substring(end);
}
function transformForLint(options) {
    options.linterMode = true;
    options.templateTag = options.templateTag || parse_templates_1.DEFAULT_PARSE_TEMPLATES_OPTIONS.templateTag;
    let { output, replacements, templateCallSpecifier } = doTransform(options);
    replacements = replacements || [];
    templateCallSpecifier = templateCallSpecifier || options.templateTag;
    return { output, replacements, templateCallSpecifier };
}
exports.transformForLint = transformForLint;
function transform(options) {
    options.templateTag = options.templateTag || parse_templates_1.DEFAULT_PARSE_TEMPLATES_OPTIONS.templateTag;
    const { output, map } = doTransform(options);
    return { output, map };
}
exports.transform = transform;
function doTransform(options) {
    var _a, _b, _c, _d;
    const plugins = ['decorators', 'typescript', 'classProperties', 'classStaticBlock', 'classPrivateProperties'].concat(options.babelPlugins || []);
    let ast = options.ast;
    if (!ast) {
        ast = (0, template_parser_1.default)(options.input, {
            ranges: true,
            tokens: true,
            templateTag: options.templateTag,
            plugins: plugins,
            allowImportExportEverywhere: true,
            errorRecovery: true,
        });
    }
    if (!((_b = (_a = ast === null || ast === void 0 ? void 0 : ast.extra) === null || _a === void 0 ? void 0 : _a.detectedTemplateNodes) === null || _b === void 0 ? void 0 : _b.length)) {
        return {
            output: options.input
        };
    }
    const pluginOptions = {
        explicit: (_c = options.explicitMode) !== null && _c !== void 0 ? _c : true,
        getTemplateLocals: options.getTemplateLocals || syntax_1.getTemplateLocals,
        moduleName: options.relativePath || '',
        linterMode: options.linterMode || false
    };
    const visitor = TemplateTransformPlugins(null, pluginOptions);
    (0, traverse_1.default)(ast, visitor.visitor);
    if (options.linterMode) {
        let output = options.input;
        const replacements = [];
        ((_d = ast === null || ast === void 0 ? void 0 : ast.extra) === null || _d === void 0 ? void 0 : _d.detectedTemplateNodes).reverse().forEach((node) => {
            const code = (0, generator_1.default)(node.replacedWith, { compact: true, comments: false }).code;
            output = replaceRange(output, node.start, node.end, code);
            const end = node.start + code.length;
            const range = [node.start, end];
            const diff = end - node.end;
            replacements.forEach((r) => {
                r.replaced.range[0] += diff;
                r.replaced.range[1] += diff;
            });
            replacements.push({
                original: {
                    loc: node.loc,
                    range: node.range,
                    contentRange: node.contentNode.range,
                },
                replaced: { range }
            });
        });
        return { output, replacements, templateCallSpecifier: ast.program.templateCallSpecifier };
    }
    else {
        const result = (0, generator_1.default)(ast, { sourceMaps: !!options.includeSourceMaps, comments: true });
        if (options.includeSourceMaps) {
            result.code += '\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,';
            result.code += btoa(JSON.stringify(result.map));
        }
        return { output: result === null || result === void 0 ? void 0 : result.code, map: result === null || result === void 0 ? void 0 : result.map };
    }
}
exports.doTransform = doTransform;
