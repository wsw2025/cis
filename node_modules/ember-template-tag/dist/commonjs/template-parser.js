"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getParser = exports.createParser = void 0;
const babel_parser_1 = require("./babel-parser");
const types_1 = require("@babel/types");
const util_1 = require("./util");
function parse(input, options) {
    const opts = Object.assign({
        ranges: true,
        allowImportExportEverywhere: true,
        errorRecovery: true,
        templateTag: util_1.TEMPLATE_TAG_NAME,
        plugins: ['typescript', 'decorators'],
    }, options);
    const parser = createParser(opts, input);
    return parser.parse();
}
exports.default = parse;
function createParser(options, input) {
    var _a;
    let cls = babel_parser_1.Parser;
    (_a = options.plugins) === null || _a === void 0 ? void 0 : _a.forEach((name) => {
        var _a, _b;
        cls = ((_b = (_a = babel_parser_1.mixinPlugins)[name]) === null || _b === void 0 ? void 0 : _b.call(_a, cls)) || cls;
    });
    cls = getParser(cls);
    return new cls(options, input);
}
exports.createParser = createParser;
function getParser(superclass = babel_parser_1.Parser) {
    return class TemplateParser extends superclass {
        constructor(options, input) {
            super(options, input);
            this.isInsideTemplate = false;
            this.detectedTemplateNodes = [];
            this.templateTag = options.templateTag;
        }
        parseEmberTemplate(...args) {
            const templateTag = this.templateTag;
            let openTemplates = 0;
            const contentRange = [0, 0];
            if (templateTag &&
                this.state.value === '<' &&
                this.input.slice(this.state.pos).startsWith(templateTag)) {
                const node = this.startNode();
                this.isInsideTemplate = true;
                node.tagName = templateTag;
                openTemplates += 1;
                node.startRange = [this.state.pos - 1, this.state.pos];
                let value = this.state.value;
                while (value !== '>' && value !== undefined) {
                    this.next();
                    value = this.state.value;
                }
                const properties = this.input.slice(node.startRange[0], this.state.pos - 1).split(' ').slice(1).filter(x => !!x).map(p => p.split('='));
                node.tagProperties = {};
                properties.forEach((p) => {
                    node.tagProperties[p[0]] = p.slice(1).length ? p.slice(1).join('=') : undefined;
                });
                node.startRange[1] = this.state.pos;
                contentRange[0] = this.state.pos;
                this.next();
                const contentNode = this.startNode();
                while (openTemplates && this.state.value !== undefined) {
                    if (this.state.value === '<' &&
                        this.input.slice(this.state.pos).startsWith(templateTag)) {
                        openTemplates += 1;
                    }
                    if (this.state.value === '<' &&
                        this.input.slice(this.state.pos).startsWith(`/${templateTag}>`)) {
                        node.endRange = [this.state.pos - 1, this.state.pos];
                        openTemplates -= 1;
                        if (openTemplates === 0) {
                            contentRange[1] = this.state.pos - 1;
                            const content = this.input.slice(...contentRange);
                            this.finishNodeAt(contentNode, 'TemplateLiteral', this.state.lastTokEndLoc);
                            value = this.state.value;
                            contentNode.quasis = [(0, types_1.templateElement)({ raw: '' }, true)];
                            contentNode.quasis[0].value.raw = content;
                            contentNode.quasis[0].value.cooked = content;
                            while (value !== '>' && value !== undefined) {
                                this.next();
                                value = this.state.value;
                            }
                            node.endRange[1] = this.state.pos;
                            node.contentNode = contentNode;
                            this.isInsideTemplate = false;
                            this.next();
                            this.detectedTemplateNodes.push(node);
                            return this.finishNode(node, 'EmberTemplate');
                        }
                    }
                    this.next();
                }
            }
            return null;
        }
        isAlpha(code) {
            if (!(code > 64 && code < 91) && // upper alpha (A-Z)
                !(code > 96 && code < 123)) { // lower alpha (a-z)
                return false;
            }
            return true;
        }
        ;
        getTokenFromCode(code) {
            if (this.isInsideTemplate) {
                if (!this.isAlpha(code)) {
                    ++this.state.pos;
                    this.finishToken(code.toString(), String.fromCharCode(code));
                    return;
                }
            }
            return super.getTokenFromCode(code);
        }
        parseStatementLike(...args) {
            var _a;
            return (_a = this.parseEmberTemplate()) !== null && _a !== void 0 ? _a : super.parseStatementLike(...args);
        }
        parseMaybeAssign(...args) {
            var _a;
            return (_a = this.parseEmberTemplate()) !== null && _a !== void 0 ? _a : super.parseMaybeAssign(...args);
        }
        parseClassMember(classBody, member, state) {
            const node = this.parseEmberTemplate();
            if (node) {
                classBody.body.push(node);
                return node;
            }
            return super.parseClassMember(classBody, member, state);
        }
        parse() {
            const node = super.parse();
            node.extra = {
                detectedTemplateNodes: this.detectedTemplateNodes
            };
            return node;
        }
    };
}
exports.getParser = getParser;
