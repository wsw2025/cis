import { ClassBody, MemberExpression, Node, Program, SourceLocation, Super, TemplateLiteral } from '@babel/types';
export declare class EmberNode implements Super {
    tagName: string;
    contentNode: TemplateLiteral;
    tagProperties: Record<string, string | undefined>;
    startRange: [number, number];
    endRange: [number, number];
    type: "EmberTemplate";
    start: number;
    end: number;
    loc: SourceLocation;
    range: [number, number];
}
declare class MyParser {
    input: string;
    state: {
        value: string;
        pos: number;
        lastTokEndLoc: any;
    };
    constructor(options: any, input: string);
    startNode(): Node;
    finishNode(node: Node, type: string): Node;
    finishNodeAt(node: Node, type: string, loc: any): Node;
    finishToken(type: string, value: string): void;
    next(): void;
    parse(): Program;
    parseStatementLike(...args: any): Node;
    parseMaybeAssign(...args: any): Node;
    getTokenFromCode(code: number): void;
    parseClassMember(classBody: ClassBody, member: MemberExpression, state: any): Node;
}
export default function parse(input: string, options?: any & {
    templateTag?: string;
}): Program;
export declare function createParser(options: any & {
    templateTag?: string;
}, input: string): MyParser;
export declare function getParser(superclass?: typeof MyParser): {
    new (options: any & {
        templateTag?: string;
    }, input: string): {
        isInsideTemplate: boolean;
        templateTag?: string | undefined;
        detectedTemplateNodes: EmberNode[];
        parseEmberTemplate(...args: any): Node | null;
        isAlpha(code: number): boolean;
        getTokenFromCode(code: number): void;
        parseStatementLike(...args: any): Node;
        parseMaybeAssign(...args: any): Node;
        parseClassMember(classBody: ClassBody, member: MemberExpression, state: any): Node;
        parse(): Program;
        input: string;
        state: {
            value: string;
            pos: number;
            lastTokEndLoc: any;
        };
        startNode(): Node;
        finishNode(node: Node, type: string): Node;
        finishNodeAt(node: Node, type: string, loc: any): Node;
        finishToken(type: string, value: string): void;
        next(): void;
    };
};
export {};
