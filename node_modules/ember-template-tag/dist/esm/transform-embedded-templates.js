import parse from './template-parser';
import { DEFAULT_PARSE_TEMPLATES_OPTIONS } from './parse-templates';
import { arrowFunctionExpression, blockStatement, callExpression, exportDefaultDeclaration, expressionStatement, identifier, importDeclaration, importSpecifier, memberExpression, numericLiteral, objectExpression, objectMethod, objectProperty, returnStatement, staticBlock, stringLiteral, templateElement, templateLiteral } from '@babel/types';
import { default as babelTraverse } from '@babel/traverse';
import { default as generate } from '@babel/generator';
import { getTemplateLocals } from '@glimmer/syntax';
import { preprocess, traverse, print } from '@glimmer/syntax';
import { TYPES } from '@babel/types';
TYPES.push('EmberTemplate');
function minify(htmlContent) {
    const ast = preprocess(htmlContent, { mode: 'codemod' });
    traverse(ast, {
        TextNode(node) {
            node.chars = node.chars.replace(/ {2,}/g, ' ').replace(/[\r\n\t\f\v]/g, '');
        }
    });
    return print(ast);
}
function buildScope(path, options) {
    const locals = options.getTemplateLocals(path.node.contentNode.quasis[0].value.raw);
    const localsWithtemplateTags = options.getTemplateLocals(path.node.contentNode.quasis[0].value.raw, { includeHtmlElements: true });
    const templateTags = localsWithtemplateTags.filter(l => !locals.includes(l) && path.scope.hasBinding(l));
    const all = [...locals, ...templateTags];
    const properties = all.map(l => {
        const id = l.split('.')[0];
        return objectProperty(identifier(id), identifier(id), false, true);
    });
    const arrow = arrowFunctionExpression([identifier('instance')], objectExpression(properties));
    return objectProperty(identifier('scope'), arrow);
}
function buildEval() {
    return objectMethod('method', identifier('eval'), [], blockStatement([
        returnStatement(callExpression(identifier('eval'), [memberExpression(identifier('arguments'), numericLiteral(0), true)]))
    ]));
}
function buildTemplateCall(id, path, options) {
    var _a;
    let content = path.node.contentNode.quasis[0].value.raw;
    if (!options.linterMode) {
        if ('trim' in path.node.tagProperties) {
            content = content.trim();
        }
        if ('minify' in path.node.tagProperties) {
            content = minify(content);
        }
    }
    else {
        const startLen = path.node.startRange[1] - path.node.startRange[0];
        const endLen = path.node.endRange[1] - path.node.endRange[0];
        content = ' '.repeat(startLen - 1) + content + ' '.repeat(endLen - 1);
    }
    const literal = templateLiteral([templateElement({ raw: '' })], []);
    literal.quasis[0].loc = path.node.contentNode.loc;
    literal.quasis[0].value.raw = content;
    literal.quasis[0].value.cooked = content;
    if (options.linterMode) {
        return literal;
    }
    let optionsExpression;
    const explicit = options.explicit;
    const property = explicit ? buildScope(path, options) : buildEval();
    const isInClass = ((_a = path.parent) === null || _a === void 0 ? void 0 : _a.type) === 'ClassBody';
    if (isInClass) {
        optionsExpression = objectExpression([
            objectProperty(identifier('component'), identifier('this')),
            objectProperty(identifier('moduleName'), stringLiteral(options.moduleName)),
            property
        ]);
    }
    else {
        optionsExpression = objectExpression([
            objectProperty(identifier('moduleName'), stringLiteral(options.moduleName)),
            property
        ]);
    }
    const callId = identifier(id);
    path.state.calls.push(callId);
    return callExpression(callId, [
        literal,
        optionsExpression
    ]);
}
function ensureImport(path, options) {
    let templateCallSpecifier = path.state.templateCallSpecifier || 'template';
    if (options.linterMode) {
        return templateCallSpecifier;
    }
    const id = identifier(templateCallSpecifier);
    const imp = importDeclaration([importSpecifier(id, identifier('template'))], stringLiteral('@ember/template-compiler'));
    if (!path.state.addedImport) {
        path.state.addedImport = id;
        path.state.program.node.body.splice(0, 0, imp);
    }
    return templateCallSpecifier;
}
const TemplateTransformPlugins = (babel, options) => {
    return {
        name: 'TemplateTransform',
        visitor: {
            enter(path) {
                var _a;
                if (path.node.type !== 'EmberTemplate')
                    return;
                ;
                const specifier = ensureImport(path, options);
                if (((_a = path.parent) === null || _a === void 0 ? void 0 : _a.type) === 'ClassBody') {
                    const templateExpr = buildTemplateCall(specifier, path, options);
                    templateExpr.loc = path.node.loc;
                    if (options.linterMode) {
                        const staticCallLen = 9; // 'static{;}'.length;
                        const content = templateExpr.quasis[0].value.raw;
                        templateExpr.quasis[0].value.raw = content.slice(7, -2);
                    }
                    const staticB = staticBlock([expressionStatement(templateExpr)]);
                    path.node.replacedWith = staticB;
                    path.replaceWith(staticB);
                }
                else {
                    const templateExpr = buildTemplateCall(specifier, path, options);
                    templateExpr.loc = path.node.loc;
                    if (path.parent.type === 'Program' && !options.linterMode) {
                        const exportDefault = exportDefaultDeclaration(templateExpr);
                        path.node.replacedWith = exportDefault;
                        path.replaceWith(exportDefault);
                        return;
                    }
                    path.node.replacedWith = templateExpr;
                    path.replaceWith(templateExpr);
                }
            },
            Program: {
                enter(path) {
                    path.state = {};
                    path.state.program = path;
                    path.state.calls = [];
                    path.state.identifiers = new Set();
                },
                exit(path) {
                    let counter = 1;
                    let templateCallSpecifier = 'template';
                    while (path.state.identifiers.has(templateCallSpecifier)) {
                        templateCallSpecifier = `template${counter}`;
                        counter += 1;
                    }
                    path.state.calls.forEach((c) => {
                        c.name = templateCallSpecifier;
                    });
                    path.state.program.node.templateCallSpecifier = path.state.templateCallSpecifier;
                    if (path.state.addedImport) {
                        path.state.addedImport.name = templateCallSpecifier;
                    }
                }
            },
            Identifier(path) {
                if (path.state.calls.some((c) => c === path.node))
                    return;
                path.state.identifiers.add(path.node.name);
            }
        }
    };
};
function replaceRange(s, start, end, substitute) {
    return s.substring(0, start) + substitute + s.substring(end);
}
export function transformForLint(options) {
    options.linterMode = true;
    options.templateTag = options.templateTag || DEFAULT_PARSE_TEMPLATES_OPTIONS.templateTag;
    let { output, replacements, templateCallSpecifier } = doTransform(options);
    replacements = replacements || [];
    templateCallSpecifier = templateCallSpecifier || options.templateTag;
    return { output, replacements, templateCallSpecifier };
}
export function transform(options) {
    options.templateTag = options.templateTag || DEFAULT_PARSE_TEMPLATES_OPTIONS.templateTag;
    const { output, map } = doTransform(options);
    return { output, map };
}
export function doTransform(options) {
    var _a, _b, _c, _d;
    const plugins = ['decorators', 'typescript', 'classProperties', 'classStaticBlock', 'classPrivateProperties'].concat(options.babelPlugins || []);
    let ast = options.ast;
    if (!ast) {
        ast = parse(options.input, {
            ranges: true,
            tokens: true,
            templateTag: options.templateTag,
            plugins: plugins,
            allowImportExportEverywhere: true,
            errorRecovery: true,
        });
    }
    if (!((_b = (_a = ast === null || ast === void 0 ? void 0 : ast.extra) === null || _a === void 0 ? void 0 : _a.detectedTemplateNodes) === null || _b === void 0 ? void 0 : _b.length)) {
        return {
            output: options.input
        };
    }
    const pluginOptions = {
        explicit: (_c = options.explicitMode) !== null && _c !== void 0 ? _c : true,
        getTemplateLocals: options.getTemplateLocals || getTemplateLocals,
        moduleName: options.relativePath || '',
        linterMode: options.linterMode || false
    };
    const visitor = TemplateTransformPlugins(null, pluginOptions);
    babelTraverse(ast, visitor.visitor);
    if (options.linterMode) {
        let output = options.input;
        const replacements = [];
        ((_d = ast === null || ast === void 0 ? void 0 : ast.extra) === null || _d === void 0 ? void 0 : _d.detectedTemplateNodes).reverse().forEach((node) => {
            const code = generate(node.replacedWith, { compact: true, comments: false }).code;
            output = replaceRange(output, node.start, node.end, code);
            const end = node.start + code.length;
            const range = [node.start, end];
            const diff = end - node.end;
            replacements.forEach((r) => {
                r.replaced.range[0] += diff;
                r.replaced.range[1] += diff;
            });
            replacements.push({
                original: {
                    loc: node.loc,
                    range: node.range,
                    contentRange: node.contentNode.range,
                },
                replaced: { range }
            });
        });
        return { output, replacements, templateCallSpecifier: ast.program.templateCallSpecifier };
    }
    else {
        const result = generate(ast, { sourceMaps: !!options.includeSourceMaps, comments: true });
        if (options.includeSourceMaps) {
            result.code += '\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,';
            result.code += btoa(JSON.stringify(result.map));
        }
        return { output: result === null || result === void 0 ? void 0 : result.code, map: result === null || result === void 0 ? void 0 : result.map };
    }
}
