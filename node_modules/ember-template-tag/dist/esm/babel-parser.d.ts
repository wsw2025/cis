declare class SourceLocation {
    constructor(start: any, end: any);
}
declare class Scope {
    constructor(flags: any);
}
declare class ScopeHandler {
    constructor(parser: any, inModule: any);
    get inTopLevel(): boolean;
    get inFunction(): boolean;
    get allowSuper(): boolean;
    get allowDirectSuper(): boolean;
    get inClass(): boolean;
    get inClassAndNotInNonArrowFunction(): boolean;
    get inStaticBlock(): boolean;
    get inNonArrowFunction(): boolean;
    get treatFunctionsAsVar(): boolean;
    createScope(flags: any): Scope;
    enter(flags: any): void;
    exit(): any;
    treatFunctionsAsVarInScope(scope: any): boolean;
    declareName(name: any, bindingType: any, loc: any): void;
    maybeExportDefined(scope: any, name: any): void;
    checkRedeclarationInScope(scope: any, name: any, bindingType: any, loc: any): void;
    isRedeclaredInScope(scope: any, name: any, bindingType: any): any;
    checkLocalExport(id: any): void;
    currentScope(): any;
    currentVarScopeFlags(): any;
    currentThisScopeFlags(): any;
}
declare class FlowScope extends Scope {
    constructor(...args: any[]);
}
declare class FlowScopeHandler extends ScopeHandler {
    createScope(flags: any): FlowScope;
    declareName(name: any, bindingType: any, loc: any): void;
    isRedeclaredInScope(scope: any, name: any, bindingType: any): boolean;
    checkLocalExport(id: any): void;
}
declare class BaseParser {
    constructor();
    hasPlugin(pluginConfig: any): any;
    getPluginOption(plugin: any, name: any): any;
}
declare class CommentsParser extends BaseParser {
    addComment(comment: any): void;
    processComment(node: any): void;
    finalizeComment(commentWS: any): void;
    finalizeRemainingComments(): void;
    resetPreviousNodeTrailingComments(node: any): void;
    resetPreviousIdentifierLeadingComments(node: any): void;
    takeSurroundingComments(node: any, start: any, end: any): void;
}
declare class Tokenizer extends CommentsParser {
    constructor(options: any, input: any);
    pushToken(token: any): void;
    next(): void;
    eat(type: any): boolean;
    match(type: any): boolean;
    createLookaheadState(state: any): {
        pos: any;
        value: null;
        type: any;
        start: any;
        end: any;
        context: any[];
        inType: any;
        startLoc: any;
        lastTokEndLoc: any;
        curLine: any;
        lineStart: any;
        curPosition: any;
    };
    lookahead(): any;
    nextTokenStart(): any;
    nextTokenStartSince(pos: any): any;
    lookaheadCharCode(): any;
    nextTokenInLineStart(): any;
    nextTokenInLineStartSince(pos: any): any;
    lookaheadInLineCharCode(): any;
    codePointAtPos(pos: any): any;
    setStrict(strict: any): void;
    curContext(): any;
    nextToken(): void;
    skipBlockComment(commentEnd: any): {
        type: string;
        value: any;
        start: any;
        end: any;
        loc: SourceLocation;
    } | undefined;
    skipLineComment(startSkip: any): {
        type: string;
        value: any;
        start: any;
        end: any;
        loc: SourceLocation;
    } | undefined;
    skipSpace(): void;
    finishToken(type: any, val: any): void;
    replaceToken(type: any): void;
    readToken_numberSign(): void;
    readToken_dot(): void;
    readToken_slash(): void;
    readToken_interpreter(): boolean;
    readToken_mult_modulo(code: any): void;
    readToken_pipe_amp(code: any): void;
    readToken_caret(): void;
    readToken_atSign(): void;
    readToken_plus_min(code: any): void;
    readToken_lt(): void;
    readToken_gt(): void;
    readToken_eq_excl(code: any): void;
    readToken_question(): void;
    getTokenFromCode(code: any): void;
    finishOp(type: any, size: any): void;
    readRegexp(): void;
    readInt(radix: any, len: any, forceLen?: boolean, allowNumSeparator?: boolean): number | null;
    readRadixNumber(radix: any): void;
    readNumber(startsWithDot: any): void;
    readCodePoint(throwOnInvalid: any): number | null;
    readString(quote: any): void;
    readTemplateContinuation(): void;
    readTemplateToken(): void;
    recordStrictModeErrors(toParseError: any, at: any): void;
    readWord1(firstCode: any): string;
    readWord(firstCode: any): void;
    checkKeywordEscapes(): void;
    raise(toParseError: any, at: any, details?: {}): any;
    raiseOverwrite(toParseError: any, at: any, details?: {}): any;
    updateContext(prevType: any): void;
    unexpected(loc: any, type: any): void;
    expectPlugin(pluginName: any, loc: any): boolean;
    expectOnePlugin(pluginNames: any): void;
    errorBuilder(error: any): (pos: any, lineStart: any, curLine: any) => void;
}
declare class UtilParser extends Tokenizer {
    addExtra(node: any, key: any, value: any, enumerable?: boolean): void;
    isContextual(token: any): boolean;
    isUnparsedContextual(nameStart: any, name: any): boolean;
    isLookaheadContextual(name: any): boolean;
    eatContextual(token: any): boolean;
    expectContextual(token: any, toParseError: any): void;
    canInsertSemicolon(): boolean;
    hasPrecedingLineBreak(): boolean;
    hasFollowingLineBreak(): boolean;
    isLineTerminator(): boolean;
    semicolon(allowAsi?: boolean): void;
    expect(type: any, loc: any): void;
    tryParse(fn: any, oldState?: any): {
        node: any;
        error: any;
        thrown: boolean;
        aborted: boolean;
        failState: any;
    };
    checkExpressionErrors(refExpressionErrors: any, andThrow: any): boolean | undefined;
    isLiteralPropertyName(): boolean;
    isPrivateName(node: any): boolean;
    getPrivateNameSV(node: any): any;
    hasPropertyAsPrivateName(node: any): boolean;
    isObjectProperty(node: any): boolean;
    isObjectMethod(node: any): boolean;
    initializeScopes(inModule?: boolean): () => void;
    enterInitialScopes(): void;
    checkDestructuringPrivate(refExpressionErrors: any): void;
}
declare class Node {
    constructor(parser: any, pos: any, loc: any);
}
declare class NodeUtils extends UtilParser {
    startNode(): Node;
    startNodeAt(loc: any): Node;
    startNodeAtNode(type: any): Node;
    finishNode(node: any, type: any): any;
    finishNodeAt(node: any, type: any, endLoc: any): any;
    resetStartLocation(node: any, startLoc: any): void;
    resetEndLocation(node: any, endLoc?: any): void;
    resetStartLocationFromNode(node: any, locationNode: any): void;
}
declare class TypeScriptScope extends Scope {
    constructor(...args: any[]);
}
declare class TypeScriptScopeHandler extends ScopeHandler {
    constructor(...args: any[]);
    createScope(flags: any): TypeScriptScope;
    enter(flags: any): void;
    exit(): any;
    hasImport(name: any, allowShadow: any): boolean;
    declareName(name: any, bindingType: any, loc: any): void;
    isRedeclaredInScope(scope: any, name: any, bindingType: any): any;
    checkLocalExport(id: any): void;
}
declare class LValParser extends NodeUtils {
    toAssignable(node: any, isLHS?: boolean): void;
    toAssignableObjectExpressionProp(prop: any, isLast: any, isLHS: any): void;
    toAssignableList(exprList: any, trailingCommaLoc: any, isLHS: any): void;
    isAssignable(node: any, isBinding: any): any;
    toReferencedList(exprList: any, isParenthesizedExpr: any): any;
    toReferencedListDeep(exprList: any, isParenthesizedExpr: any): void;
    parseSpread(refExpressionErrors: any): any;
    parseRestBinding(): any;
    parseBindingAtom(): any;
    parseBindingList(close: any, closeCharCode: any, flags: any): any[];
    parseBindingRestProperty(prop: any): any;
    parseBindingProperty(): any;
    parseAssignableListItem(flags: any, decorators: any): any;
    parseAssignableListItemTypes(param: any, flags: any): any;
    parseMaybeDefault(startLoc: any, left: any): any;
    isValidLVal(type: any, isUnparenthesizedInAssign: any, binding: any): any;
    isOptionalMemberExpression(expression: any): boolean;
    checkLVal(expression: any, { in: ancestor, binding, checkClashes, strictModeChanged, hasParenthesizedAncestor }: {
        in: any;
        binding?: number | undefined;
        checkClashes?: boolean | undefined;
        strictModeChanged?: boolean | undefined;
        hasParenthesizedAncestor?: boolean | undefined;
    }): void;
    checkIdentifier(at: any, bindingType: any, strictModeChanged?: boolean): void;
    declareNameFromIdentifier(identifier: any, binding: any): void;
    checkToRestConversion(node: any, allowPattern: any): void;
    checkCommaAfterRest(close: any): boolean;
}
declare const mixinPlugins: {
    estree: (superClass: any) => {
        new (): {
            [x: string]: any;
            parse(): any;
            parseRegExpLiteral({ pattern, flags }: {
                pattern: any;
                flags: any;
            }): any;
            parseBigIntLiteral(value: any): any;
            parseDecimalLiteral(value: any): any;
            estreeParseLiteral(value: any): any;
            parseStringLiteral(value: any): any;
            parseNumericLiteral(value: any): any;
            parseNullLiteral(): any;
            parseBooleanLiteral(value: any): any;
            directiveToStmt(directive: any): any;
            initFunction(node: any, isAsync: any): void;
            checkDeclaration(node: any): void;
            getObjectOrClassMethodParams(method: any): any;
            isValidDirective(stmt: any): boolean;
            parseBlockBody(node: any, allowDirectives: any, topLevel: any, end: any, afterBlockParse: any): void;
            pushClassMethod(classBody: any, method: any, isGenerator: any, isAsync: any, isConstructor: any, allowsDirectSuper: any): void;
            parsePrivateName(): any;
            convertPrivateNameToPrivateIdentifier(node: any): any;
            isPrivateName(node: any): any;
            getPrivateNameSV(node: any): any;
            parseLiteral(value: any, type: any): any;
            parseFunctionBody(node: any, allowExpression: any, isMethod?: boolean): void;
            parseMethod(node: any, isGenerator: any, isAsync: any, isConstructor: any, allowDirectSuper: any, type: any, inClassScope?: boolean): any;
            parseClassProperty(...args: any[]): any;
            parseClassPrivateProperty(...args: any[]): any;
            parseObjectMethod(prop: any, isGenerator: any, isAsync: any, isPattern: any, isAccessor: any): any;
            parseObjectProperty(prop: any, startLoc: any, isPattern: any, refExpressionErrors: any): any;
            isValidLVal(type: any, isUnparenthesizedInAssign: any, binding: any): any;
            isAssignable(node: any, isBinding: any): any;
            toAssignable(node: any, isLHS?: boolean): void;
            toAssignableObjectExpressionProp(prop: any, isLast: any, isLHS: any): void;
            finishCallExpression(unfinished: any, optional: any): any;
            toReferencedArguments(node: any): void;
            parseExport(unfinished: any, decorators: any): any;
            parseSubscript(base: any, startLoc: any, noCalls: any, state: any): any;
            isOptionalMemberExpression(node: any): any;
            hasPropertyAsPrivateName(node: any): any;
            isObjectProperty(node: any): boolean;
            isObjectMethod(node: any): any;
            finishNodeAt(node: any, type: any, endLoc: any): any;
            resetStartLocation(node: any, startLoc: any): void;
            resetEndLocation(node: any, endLoc?: any): void;
        };
        [x: string]: any;
    };
    jsx: (superClass: any) => {
        new (): {
            [x: string]: any;
            jsxReadToken(): void;
            jsxReadNewLine(normalizeCRLF: any): string;
            jsxReadString(quote: any): void;
            jsxReadEntity(): any;
            jsxReadWord(): void;
            jsxParseIdentifier(): any;
            jsxParseNamespacedName(): any;
            jsxParseElementName(): any;
            jsxParseAttributeValue(): any;
            jsxParseEmptyExpression(): any;
            jsxParseSpreadChild(node: any): any;
            jsxParseExpressionContainer(node: any, previousContext: any): any;
            jsxParseAttribute(): any;
            jsxParseOpeningElementAt(startLoc: any): any;
            jsxParseOpeningElementAfterName(node: any): any;
            jsxParseClosingElementAt(startLoc: any): any;
            jsxParseElementAt(startLoc: any): any;
            jsxParseElement(): any;
            setContext(newContext: any): void;
            parseExprAtom(refExpressionErrors: any): any;
            skipSpace(): void;
            getTokenFromCode(code: any): void;
            updateContext(prevType: any): void;
        };
        [x: string]: any;
    };
    flow: (superClass: any) => {
        new (...args: any[]): {
            [x: string]: any;
            getScopeHandler(): typeof FlowScopeHandler;
            shouldParseTypes(): any;
            shouldParseEnums(): boolean;
            finishToken(type: any, val: any): void;
            addComment(comment: any): void;
            flowParseTypeInitialiser(tok: any): any;
            flowParsePredicate(): any;
            flowParseTypeAndPredicateInitialiser(): any[];
            flowParseDeclareClass(node: any): any;
            flowParseDeclareFunction(node: any): any;
            flowParseDeclare(node: any, insideModule: any): any;
            flowParseDeclareVariable(node: any): any;
            flowParseDeclareModule(node: any): any;
            flowParseDeclareExportDeclaration(node: any, insideModule: any): any;
            flowParseDeclareModuleExports(node: any): any;
            flowParseDeclareTypeAlias(node: any): any;
            flowParseDeclareOpaqueType(node: any): any;
            flowParseDeclareInterface(node: any): any;
            flowParseInterfaceish(node: any, isClass: any): void;
            flowParseInterfaceExtends(): any;
            flowParseInterface(node: any): any;
            checkNotUnderscore(word: any): void;
            checkReservedType(word: any, startLoc: any, declaration: any): void;
            flowParseRestrictedIdentifier(liberal: any, declaration: any): any;
            flowParseTypeAlias(node: any): any;
            flowParseOpaqueType(node: any, declare: any): any;
            flowParseTypeParameter(requireDefault?: boolean): any;
            flowParseTypeParameterDeclaration(): any;
            flowParseTypeParameterInstantiation(): any;
            flowParseTypeParameterInstantiationCallOrNew(): any;
            flowParseInterfaceType(): any;
            flowParseObjectPropertyKey(): any;
            flowParseObjectTypeIndexer(node: any, isStatic: any, variance: any): any;
            flowParseObjectTypeInternalSlot(node: any, isStatic: any): any;
            flowParseObjectTypeMethodish(node: any): any;
            flowParseObjectTypeCallProperty(node: any, isStatic: any): any;
            flowParseObjectType({ allowStatic, allowExact, allowSpread, allowProto, allowInexact }: {
                allowStatic: any;
                allowExact: any;
                allowSpread: any;
                allowProto: any;
                allowInexact: any;
            }): any;
            flowParseObjectTypeProperty(node: any, isStatic: any, protoStartLoc: any, variance: any, kind: any, allowSpread: any, allowInexact: any): any;
            flowCheckGetterSetterParams(property: any): void;
            flowObjectTypeSemicolon(): void;
            flowParseQualifiedTypeIdentifier(startLoc: any, id: any): any;
            flowParseGenericType(startLoc: any, id: any): any;
            flowParseTypeofType(): any;
            flowParseTupleType(): any;
            flowParseFunctionTypeParam(first: any): any;
            reinterpretTypeAsFunctionTypeParam(type: any): any;
            flowParseFunctionTypeParams(params?: never[]): {
                params: never[];
                rest: any;
                _this: any;
            };
            flowIdentToTypeAnnotation(startLoc: any, node: any, id: any): any;
            flowParsePrimaryType(): any;
            flowParsePostfixType(): any;
            flowParsePrefixType(): any;
            flowParseAnonFunctionWithoutParens(): any;
            flowParseIntersectionType(): any;
            flowParseUnionType(): any;
            flowParseType(): any;
            flowParseTypeOrImplicitInstantiation(): any;
            flowParseTypeAnnotation(): any;
            flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride: any): any;
            typeCastToParameter(node: any): any;
            flowParseVariance(): any;
            parseFunctionBody(node: any, allowExpressionBody: any, isMethod?: boolean): void;
            parseFunctionBodyAndFinish(node: any, type: any, isMethod?: boolean): any;
            parseStatementLike(flags: any): any;
            parseExpressionStatement(node: any, expr: any, decorators: any): any;
            shouldParseExportDeclaration(): any;
            isExportDefaultSpecifier(): any;
            parseExportDefaultExpression(): any;
            parseConditional(expr: any, startLoc: any, refExpressionErrors: any): any;
            tryParseConditionalConsequent(): {
                consequent: any;
                failed: boolean;
            };
            getArrowLikeExpressions(node: any, disallowInvalid: any): any[][];
            finishArrowValidation(node: any): void;
            forwardNoArrowParamsConversionAt(node: any, parse: any): any;
            parseParenItem(node: any, startLoc: any): any;
            assertModuleNodeAllowed(node: any): void;
            parseExportDeclaration(node: any): any;
            eatExportStar(node: any): boolean;
            maybeParseExportNamespaceSpecifier(node: any): any;
            parseClassId(node: any, isStatement: any, optionalId: any): void;
            parseClassMember(classBody: any, member: any, state: any): void;
            isIterator(word: any): boolean;
            readIterator(): void;
            getTokenFromCode(code: any): void;
            isAssignable(node: any, isBinding: any): any;
            toAssignable(node: any, isLHS?: boolean): void;
            toAssignableList(exprList: any, trailingCommaLoc: any, isLHS: any): void;
            toReferencedList(exprList: any, isParenthesizedExpr: any): any;
            parseArrayLike(close: any, canBePattern: any, isTuple: any, refExpressionErrors: any): any;
            isValidLVal(type: any, isParenthesized: any, binding: any): any;
            parseClassProperty(node: any): any;
            parseClassPrivateProperty(node: any): any;
            isClassMethod(): any;
            isClassProperty(): any;
            isNonstaticConstructor(method: any): any;
            pushClassMethod(classBody: any, method: any, isGenerator: any, isAsync: any, isConstructor: any, allowsDirectSuper: any): void;
            pushClassPrivateMethod(classBody: any, method: any, isGenerator: any, isAsync: any): void;
            parseClassSuper(node: any): void;
            checkGetterSetterParams(method: any): void;
            parsePropertyNamePrefixOperator(node: any): void;
            parseObjPropValue(prop: any, startLoc: any, isGenerator: any, isAsync: any, isPattern: any, isAccessor: any, refExpressionErrors: any): any;
            parseAssignableListItemTypes(param: any): any;
            parseMaybeDefault(startLoc: any, left: any): any;
            checkImportReflection(node: any): void;
            parseImportSpecifierLocal(node: any, specifier: any, type: any): void;
            isPotentialImportPhase(isExport: any): any;
            applyImportPhase(node: any, isExport: any, phase: any, loc: any): void;
            parseImportSpecifier(specifier: any, importedIsString: any, isInTypeOnlyImport: any, isMaybeTypeOnly: any, bindingType: any): any;
            parseBindingAtom(): any;
            parseFunctionParams(node: any, isConstructor: any): void;
            parseVarId(decl: any, kind: any): void;
            parseAsyncArrowFromCallExpression(node: any, call: any): any;
            shouldParseAsyncArrow(): any;
            parseMaybeAssign(refExpressionErrors: any, afterLeftParse: any): any;
            parseArrow(node: any): any;
            shouldParseArrow(params: any): any;
            setArrowFunctionParameters(node: any, params: any): void;
            checkParams(node: any, allowDuplicates: any, isArrowFunction: any, strictModeChanged?: boolean): void;
            parseParenAndDistinguishExpression(canBeArrow: any): any;
            parseSubscripts(base: any, startLoc: any, noCalls: any): any;
            parseSubscript(base: any, startLoc: any, noCalls: any, subscriptState: any): any;
            parseNewCallee(node: any): void;
            parseAsyncArrowWithTypeParameters(startLoc: any): any;
            readToken_mult_modulo(code: any): void;
            readToken_pipe_amp(code: any): void;
            parseTopLevel(file: any, program: any): any;
            skipBlockComment(): any;
            skipFlowComment(): number | false;
            hasFlowCommentCompletion(): void;
            flowEnumErrorBooleanMemberNotInitialized(loc: any, { enumName, memberName }: {
                enumName: any;
                memberName: any;
            }): void;
            flowEnumErrorInvalidMemberInitializer(loc: any, enumContext: any): any;
            flowEnumErrorNumberMemberNotInitialized(loc: any, details: any): void;
            flowEnumErrorStringMemberInconsistentlyInitialized(node: any, details: any): void;
            flowEnumMemberInit(): {
                type: string;
                loc: any;
                value: any;
            } | {
                type: string;
                loc: any;
                value?: undefined;
            };
            flowEnumMemberRaw(): {
                id: any;
                init: {
                    type: string;
                    loc: any;
                    value: any;
                } | {
                    type: string;
                    loc: any;
                    value?: undefined;
                };
            };
            flowEnumCheckExplicitTypeMismatch(loc: any, context: any, expectedType: any): void;
            flowEnumMembers({ enumName, explicitType }: {
                enumName: any;
                explicitType: any;
            }): {
                members: {
                    booleanMembers: never[];
                    numberMembers: never[];
                    stringMembers: never[];
                    defaultedMembers: never[];
                };
                hasUnknownMembers: boolean;
            };
            flowEnumStringMembers(initializedMembers: any, defaultedMembers: any, { enumName }: {
                enumName: any;
            }): any;
            flowEnumParseExplicitType({ enumName }: {
                enumName: any;
            }): any;
            flowEnumBody(node: any, id: any): any;
            flowParseEnumDeclaration(node: any): any;
            isLookaheadToken_lt(): boolean;
            maybeUnwrapTypeCastExpression(node: any): any;
        };
        [x: string]: any;
    };
    typescript: (superClass: any) => {
        new (...args: any[]): {
            [x: string]: any;
            getScopeHandler(): typeof TypeScriptScopeHandler;
            tsIsIdentifier(): boolean;
            tsTokenCanFollowModifier(): any;
            tsNextTokenCanFollowModifier(): any;
            tsParseModifier(allowedModifiers: any, stopOnStartOfClassStaticBlock: any): any;
            tsParseModifiers({ allowedModifiers, disallowedModifiers, stopOnStartOfClassStaticBlock, errorTemplate }: {
                allowedModifiers: any;
                disallowedModifiers: any;
                stopOnStartOfClassStaticBlock: any;
                errorTemplate?: any;
            }, modified: any): void;
            tsIsListTerminator(kind: any): any;
            tsParseList(kind: any, parseElement: any): any[];
            tsParseDelimitedList(kind: any, parseElement: any, refTrailingCommaPos: any): any;
            tsParseDelimitedListWorker(kind: any, parseElement: any, expectSuccess: any, refTrailingCommaPos: any): any[] | undefined;
            tsParseBracketedList(kind: any, parseElement: any, bracket: any, skipFirstToken: any, refTrailingCommaPos: any): any;
            tsParseImportType(): any;
            tsParseEntityName(allowReservedWords?: boolean): any;
            tsParseTypeReference(): any;
            tsParseThisTypePredicate(lhs: any): any;
            tsParseThisTypeNode(): any;
            tsParseTypeQuery(): any;
            tsParseTypeParameter(parseModifiers: any): any;
            tsTryParseTypeParameters(parseModifiers: any): any;
            tsParseTypeParameters(parseModifiers: any): any;
            tsFillSignature(returnToken: any, signature: any): void;
            tsParseBindingListForSignature(): any;
            tsParseTypeMemberSemicolon(): void;
            tsParseSignatureMember(kind: any, node: any): any;
            tsIsUnambiguouslyIndexSignature(): any;
            tsTryParseIndexSignature(node: any): any;
            tsParsePropertyOrMethodSignature(node: any, readonly: any): any;
            tsParseTypeMember(): any;
            tsParseTypeLiteral(): any;
            tsParseObjectTypeMembers(): any[];
            tsIsStartOfMappedType(): any;
            tsParseMappedTypeParameter(): any;
            tsParseMappedType(): any;
            tsParseTupleType(): any;
            tsParseTupleElementType(): any;
            tsParseParenthesizedType(): any;
            tsParseFunctionOrConstructorType(type: any, abstract: any): any;
            tsParseLiteralTypeNode(): any;
            tsParseTemplateLiteralType(): any;
            parseTemplateSubstitution(): any;
            tsParseThisTypeOrThisTypePredicate(): any;
            tsParseNonArrayType(): any;
            tsParseArrayTypeOrHigher(): any;
            tsParseTypeOperator(): any;
            tsCheckTypeAnnotationForReadOnly(node: any): void;
            tsParseInferType(): any;
            tsParseConstraintForInferType(): any;
            tsParseTypeOperatorOrHigher(): any;
            tsParseUnionOrIntersectionType(kind: any, parseConstituentType: any, operator: any): any;
            tsParseIntersectionTypeOrHigher(): any;
            tsParseUnionTypeOrHigher(): any;
            tsIsStartOfFunctionType(): any;
            tsSkipParameterStart(): boolean;
            tsIsUnambiguouslyStartOfFunctionType(): boolean;
            tsParseTypeOrTypePredicateAnnotation(returnToken: any): any;
            tsTryParseTypeOrTypePredicateAnnotation(): any;
            tsTryParseTypeAnnotation(): any;
            tsTryParseType(): any;
            tsParseTypePredicatePrefix(): any;
            tsParseTypePredicateAsserts(): boolean;
            tsParseTypeAnnotation(eatColon?: boolean, t?: any): any;
            tsParseType(): any;
            isAbstractConstructorSignature(): any;
            tsParseNonConditionalType(): any;
            tsParseTypeAssertion(): any;
            tsParseHeritageClause(token: any): any;
            tsParseInterfaceDeclaration(node: any, properties?: {}): any;
            tsParseTypeAliasDeclaration(node: any): any;
            tsInNoContext(cb: any): any;
            tsInType(cb: any): any;
            tsInDisallowConditionalTypesContext(cb: any): any;
            tsInAllowConditionalTypesContext(cb: any): any;
            tsEatThenParseType(token: any): any;
            tsExpectThenParseType(token: any): any;
            tsNextThenParseType(): any;
            tsParseEnumMember(): any;
            tsParseEnumDeclaration(node: any, properties?: {}): any;
            tsParseModuleBlock(): any;
            tsParseModuleOrNamespaceDeclaration(node: any, nested?: boolean): any;
            tsParseAmbientExternalModuleDeclaration(node: any): any;
            tsParseImportEqualsDeclaration(node: any, maybeDefaultIdentifier: any, isExport: any): any;
            tsIsExternalModuleReference(): any;
            tsParseModuleReference(): any;
            tsParseExternalModuleReference(): any;
            tsLookAhead(f: any): any;
            tsTryParseAndCatch(f: any): any;
            tsTryParse(f: any): any;
            tsTryParseDeclare(nany: any): any;
            tsTryParseExportDeclaration(): any;
            tsParseExpressionStatement(node: any, expr: any, decorators: any): any;
            tsParseDeclaration(node: any, value: any, next: any, decorators: any): any;
            tsCheckLineTerminator(next: any): boolean;
            tsTryParseGenericAsyncArrowFunction(startLoc: any): any;
            tsParseTypeArgumentsInExpression(): any;
            tsParseTypeArguments(): any;
            tsIsDeclarationStart(): boolean;
            isExportDefaultSpecifier(): any;
            parseAssignableListItem(flags: any, decorators: any): any;
            isSimpleParameter(node: any): any;
            tsDisallowOptionalPattern(node: any): void;
            setArrowFunctionParameters(node: any, params: any, trailingCommaLoc: any): void;
            parseFunctionBodyAndFinish(node: any, type: any, isMethod?: boolean): any;
            registerFunctionStatementId(node: any): void;
            tsCheckForInvalidTypeCasts(items: any): void;
            toReferencedList(exprList: any, isInParens: any): any;
            parseArrayLike(close: any, canBePattern: any, isTuple: any, refExpressionErrors: any): any;
            parseSubscript(base: any, startLoc: any, noCalls: any, state: any): any;
            parseNewCallee(node: any): void;
            parseExprOp(left: any, leftStartLoc: any, minPrec: any): any;
            checkReservedWord(word: any, startLoc: any, checkKeywords: any, isBinding: any): void;
            checkImportReflection(node: any): void;
            checkDuplicateExports(): void;
            isPotentialImportPhase(isExport: any): any;
            applyImportPhase(node: any, isExport: any, phase: any, loc: any): void;
            parseImport(node: any): any;
            parseExport(node: any, decorators: any): any;
            isAbstractClass(): any;
            parseExportDefaultExpression(): any;
            parseVarStatement(node: any, kind: any, allowMissingInitializer?: boolean): any;
            parseStatementContent(flags: any, decorators: any): any;
            parseAccessModifier(): any;
            tsHasSomeModifiers(member: any, modifiers: any): any;
            tsIsStartOfStaticBlocks(): any;
            parseClassMember(classBody: any, member: any, state: any): void;
            parseClassMemberWithIsStatic(classBody: any, member: any, state: any, isStatic: any): void;
            parsePostMemberNameModifiers(methodOrProp: any): void;
            parseExpressionStatement(node: any, expr: any, decorators: any): any;
            shouldParseExportDeclaration(): any;
            parseConditional(expr: any, startLoc: any, refExpressionErrors: any): any;
            parseParenItem(node: any, startLoc: any): any;
            parseExportDeclaration(node: any): any;
            parseClassId(node: any, isStatement: any, optionalId: any, bindingType: any): void;
            parseClassPropertyAnnotation(node: any): void;
            parseClassProperty(node: any): any;
            parseClassPrivateProperty(node: any): any;
            parseClassAccessorProperty(node: any): any;
            pushClassMethod(classBody: any, method: any, isGenerator: any, isAsync: any, isConstructor: any, allowsDirectSuper: any): void;
            pushClassPrivateMethod(classBody: any, method: any, isGenerator: any, isAsync: any): void;
            declareClassPrivateMethodInScope(node: any, kind: any): void;
            parseClassSuper(node: any): void;
            parseObjPropValue(prop: any, startLoc: any, isGenerator: any, isAsync: any, isPattern: any, isAccessor: any, refExpressionErrors: any): any;
            parseFunctionParams(node: any, isConstructor: any): void;
            parseVarId(decl: any, kind: any): void;
            parseAsyncArrowFromCallExpression(node: any, call: any): any;
            parseMaybeAssign(refExpressionErrors: any, afterLeftParse: any): any;
            reportReservedArrowTypeParam(node: any): void;
            parseMaybeUnary(refExpressionErrors: any, sawUnary: any): any;
            parseArrow(node: any): any;
            parseAssignableListItemTypes(param: any, flags: any): any;
            isAssignable(node: any, isBinding: any): any;
            toAssignable(node: any, isLHS?: boolean): void;
            toAssignableParenthesizedExpression(node: any, isLHS: any): void;
            checkToRestConversion(node: any, allowPattern: any): void;
            isValidLVal(type: any, isUnparenthesizedInAssign: any, binding: any): any;
            parseBindingAtom(): any;
            parseMaybeDecoratorArguments(expr: any): any;
            checkCommaAfterRest(close: any): any;
            isClassMethod(): any;
            isClassProperty(): any;
            parseMaybeDefault(startLoc: any, left: any): any;
            getTokenFromCode(code: any): void;
            reScan_lt_gt(): void;
            reScan_lt(): any;
            toAssignableList(exprList: any, trailingCommaLoc: any, isLHS: any): void;
            typeCastToParameter(node: any): any;
            shouldParseArrow(params: any): any;
            shouldParseAsyncArrow(): any;
            canHaveLeadingDecorator(): any;
            jsxParseOpeningElementAfterName(node: any): any;
            getGetterSetterExpectedParamCount(method: any): any;
            parseCatchClauseParam(): any;
            tsInAmbientContext(cb: any): any;
            parseClass(node: any, isStatement: any, optionalId: any): any;
            tsParseAbstractDeclaration(node: any, decorators: any): any;
            parseMethod(node: any, isGenerator: any, isAsync: any, isConstructor: any, allowDirectSuper: any, type: any, inClassScope: any): any;
            tsParseTypeParameterName(): any;
            shouldParseAsAmbientContext(): boolean;
            parse(): any;
            getExpression(): any;
            parseExportSpecifier(node: any, isString: any, isInTypeExport: any, isMaybeTypeOnly: any): any;
            parseImportSpecifier(specifier: any, importedIsString: any, isInTypeOnlyImport: any, isMaybeTypeOnly: any, bindingType: any): any;
            parseTypeOnlyImportExportSpecifier(node: any, isImport: any, isInTypeOnlyImportExport: any): void;
        };
        [x: string]: any;
    };
    v8intrinsic: (superClass: any) => {
        new (): {
            [x: string]: any;
            parseV8Intrinsic(): any;
            parseExprAtom(refExpressionErrors: any): any;
        };
        [x: string]: any;
    };
    placeholders: (superClass: any) => {
        new (): {
            [x: string]: any;
            parsePlaceholder(expectedNode: any): any;
            finishPlaceholder(node: any, expectedNode: any): any;
            getTokenFromCode(code: any): void;
            parseExprAtom(refExpressionErrors: any): any;
            parseIdentifier(liberal: any): any;
            checkReservedWord(word: any, startLoc: any, checkKeywords: any, isBinding: any): void;
            parseBindingAtom(): any;
            isValidLVal(type: any, isParenthesized: any, binding: any): any;
            toAssignable(node: any, isLHS: any): void;
            chStartsBindingIdentifier(ch: any, pos: any): boolean;
            verifyBreakContinue(node: any, isBreak: any): void;
            parseExpressionStatement(node: any, expr: any): any;
            parseBlock(allowDirectives: any, createNewLexicalScope: any, afterBlockParse: any): any;
            parseFunctionId(requireId: any): any;
            parseClass(node: any, isStatement: any, optionalId: any): any;
            parseExport(node: any, decorators: any): any;
            isExportDefaultSpecifier(): any;
            maybeParseExportDefaultSpecifier(node: any, maybeDefaultIdentifier: any): any;
            checkExport(node: any): void;
            parseImport(node: any): any;
            parseImportSource(): any;
            assertNoSpace(): void;
        };
        [x: string]: any;
    };
};
declare class ExpressionParser extends LValParser {
    checkProto(prop: any, isRecord: any, protoRef: any, refExpressionErrors: any): void;
    shouldExitDescending(expr: any, potentialArrowAt: any): boolean;
    getExpression(): any;
    parseExpression(disallowIn: any, refExpressionErrors: any): any;
    parseExpressionBase(refExpressionErrors: any): any;
    parseMaybeAssignDisallowIn(refExpressionErrors: any, afterLeftParse: any): any;
    parseMaybeAssignAllowIn(refExpressionErrors: any, afterLeftParse: any): any;
    setOptionalParametersError(refExpressionErrors: any, resultError: any): void;
    parseMaybeAssign(refExpressionErrors: any, afterLeftParse: any): any;
    parseMaybeConditional(refExpressionErrors: any): any;
    parseConditional(expr: any, startLoc: any, refExpressionErrors: any): any;
    parseMaybeUnaryOrPrivate(refExpressionErrors: any): any;
    parseExprOps(refExpressionErrors: any): any;
    parseExprOp(left: any, leftStartLoc: any, minPrec: any): any;
    parseExprOpRightExpr(op: any, prec: any): any;
    parseExprOpBaseRightExpr(op: any, prec: any): any;
    parseHackPipeBody(): any;
    checkExponentialAfterUnary(node: any): void;
    parseMaybeUnary(refExpressionErrors: any, sawUnary: any): any;
    parseUpdate(node: any, update: any, refExpressionErrors: any): any;
    parseExprSubscripts(refExpressionErrors: any): any;
    parseSubscripts(base: any, startLoc: any, noCalls: any): any;
    parseSubscript(base: any, startLoc: any, noCalls: any, state: any): any;
    parseMember(base: any, startLoc: any, state: any, computed: any, optional: any): any;
    parseBind(base: any, startLoc: any, noCalls: any, state: any): any;
    parseCoverCallAndAsyncArrowHead(base: any, startLoc: any, state: any, optional: any): any;
    toReferencedArguments(node: any, isParenthesizedExpr: any): void;
    parseTaggedTemplateExpression(base: any, startLoc: any, state: any): any;
    atPossibleAsyncArrow(base: any): boolean;
    expectImportAttributesPlugin(): void;
    finishCallExpression(node: any, optional: any): any;
    parseCallExpressionArguments(close: any, dynamicImport: any, allowPlaceholder: any, nodeForExtra: any, refExpressionErrors: any): any[];
    shouldParseAsyncArrow(): boolean;
    parseAsyncArrowFromCallExpression(node: any, call: any): any;
    parseNoCallExpr(): any;
    parseExprAtom(refExpressionErrors: any): any;
    parseTopicReferenceThenEqualsSign(topicTokenType: any, topicTokenValue: any): any;
    parseTopicReference(pipeProposal: any): any;
    finishTopicReference(node: any, startLoc: any, pipeProposal: any, tokenType: any): any;
    testTopicReferenceConfiguration(pipeProposal: any, startLoc: any, tokenType: any): any;
    parseAsyncArrowUnaryFunction(node: any): any;
    parseDo(node: any, isAsync: any): any;
    parseSuper(): any;
    parsePrivateName(): any;
    parseFunctionOrFunctionSent(): any;
    parseMetaProperty(node: any, meta: any, propertyName: any): any;
    parseImportMetaProperty(node: any): any;
    parseLiteralAtNode(value: any, type: any, node: any): any;
    parseLiteral(value: any, type: any): any;
    parseStringLiteral(value: any): any;
    parseNumericLiteral(value: any): any;
    parseBigIntLiteral(value: any): any;
    parseDecimalLiteral(value: any): any;
    parseRegExpLiteral(value: any): any;
    parseBooleanLiteral(value: any): any;
    parseNullLiteral(): any;
    parseParenAndDistinguishExpression(canBeArrow: any): any;
    wrapParenthesis(startLoc: any, expression: any): any;
    shouldParseArrow(params: any): boolean;
    parseArrow(node: any): any;
    parseParenItem(node: any, startLoc: any): any;
    parseNewOrNewTarget(): any;
    parseNew(node: any): any;
    parseNewCallee(node: any): void;
    parseTemplateElement(isTagged: any): any;
    parseTemplate(isTagged: any): any;
    parseTemplateSubstitution(): any;
    parseObjectLike(close: any, isPattern: any, isRecord: any, refExpressionErrors: any): any;
    addTrailingCommaExtraToNode(node: any): void;
    maybeAsyncOrAccessorProp(prop: any): boolean;
    parsePropertyDefinition(refExpressionErrors: any): any;
    getGetterSetterExpectedParamCount(method: any): 0 | 1;
    getObjectOrClassMethodParams(method: any): any;
    checkGetterSetterParams(method: any): void;
    parseObjectMethod(prop: any, isGenerator: any, isAsync: any, isPattern: any, isAccessor: any): any;
    parseObjectProperty(prop: any, startLoc: any, isPattern: any, refExpressionErrors: any): any;
    parseObjPropValue(prop: any, startLoc: any, isGenerator: any, isAsync: any, isPattern: any, isAccessor: any, refExpressionErrors: any): any;
    parsePropertyName(prop: any, refExpressionErrors: any): any;
    initFunction(node: any, isAsync: any): void;
    parseMethod(node: any, isGenerator: any, isAsync: any, isConstructor: any, allowDirectSuper: any, type: any, inClassScope?: boolean): any;
    parseArrayLike(close: any, canBePattern: any, isTuple: any, refExpressionErrors: any): any;
    parseArrowExpression(node: any, params: any, isAsync: any, trailingCommaLoc: any): any;
    setArrowFunctionParameters(node: any, params: any, trailingCommaLoc: any): void;
    parseFunctionBodyAndFinish(node: any, type: any, isMethod?: boolean): any;
    parseFunctionBody(node: any, allowExpression: any, isMethod?: boolean): void;
    isSimpleParameter(node: any): boolean;
    isSimpleParamList(params: any): boolean;
    checkParams(node: any, allowDuplicates: any, isArrowFunction: any, strictModeChanged?: boolean): void;
    parseExprList(close: any, allowEmpty: any, refExpressionErrors: any, nodeForExtra: any): any[];
    parseExprListItem(allowEmpty: any, refExpressionErrors: any, allowPlaceholder: any): any;
    parseIdentifier(liberal: any): any;
    createIdentifier(node: any, name: any): any;
    parseIdentifierName(liberal: any): any;
    checkReservedWord(word: any, startLoc: any, checkKeywords: any, isBinding: any): void;
    isAwaitAllowed(): boolean;
    parseAwait(startLoc: any): any;
    isAmbiguousAwait(): any;
    parseYield(): any;
    parseImportCall(node: any): any;
    checkPipelineAtInfixOperator(left: any, leftStartLoc: any): void;
    parseSmartPipelineBodyInStyle(childExpr: any, startLoc: any): any;
    isSimpleReference(expression: any): any;
    checkSmartPipeTopicBodyEarlyErrors(startLoc: any): void;
    withTopicBindingContext(callback: any): any;
    withSmartMixTopicForbiddingContext(callback: any): any;
    withSoloAwaitPermittingContext(callback: any): any;
    allowInAnd(callback: any): any;
    disallowInAnd(callback: any): any;
    registerTopicReference(): void;
    topicReferenceIsAllowedInCurrentContext(): boolean;
    topicReferenceWasUsedInCurrentContext(): boolean;
    parseFSharpPipelineBody(prec: any): any;
    parseModuleExpression(): any;
    parsePropertyNamePrefixOperator(prop: any): void;
}
declare class StatementParser extends ExpressionParser {
    parseTopLevel(file: any, program: any): any;
    parseProgram(program: any, end?: number, sourceType?: any): any;
    stmtToDirective(stmt: any): any;
    parseInterpreterDirective(): any;
    isLet(): boolean;
    chStartsBindingIdentifier(ch: any, pos: any): boolean;
    chStartsBindingPattern(ch: any): boolean;
    hasFollowingBindingAtom(): boolean;
    hasInLineFollowingBindingIdentifier(): boolean;
    startsUsingForOf(): boolean | undefined;
    startsAwaitUsing(): boolean;
    parseModuleItem(): any;
    parseStatementListItem(): any;
    parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction?: boolean): any;
    parseStatement(): any;
    parseStatementLike(flags: any): any;
    parseStatementContent(flags: any, decorators: any): any;
    assertModuleNodeAllowed(node: any): void;
    decoratorsEnabledBeforeExport(): any;
    maybeTakeDecorators(maybeDecorators: any, classNode: any, exportNode: any): any;
    canHaveLeadingDecorator(): boolean;
    parseDecorators(allowExport: any): any[];
    parseDecorator(): any;
    parseMaybeDecoratorArguments(expr: any): any;
    parseBreakContinueStatement(node: any, isBreak: any): any;
    verifyBreakContinue(node: any, isBreak: any): void;
    parseDebuggerStatement(node: any): any;
    parseHeaderExpression(): any;
    parseDoWhileStatement(node: any): any;
    parseForStatement(node: any): any;
    parseFunctionStatement(node: any, isAsync: any, isHangingDeclaration: any): any;
    parseIfStatement(node: any): any;
    parseReturnStatement(node: any): any;
    parseSwitchStatement(node: any): any;
    parseThrowStatement(node: any): any;
    parseCatchClauseParam(): any;
    parseTryStatement(node: any): any;
    parseVarStatement(node: any, kind: any, allowMissingInitializer?: boolean): any;
    parseWhileStatement(node: any): any;
    parseWithStatement(node: any): any;
    parseEmptyStatement(node: any): any;
    parseLabeledStatement(node: any, maybeName: any, expr: any, flags: any): any;
    parseExpressionStatement(node: any, expr: any, decorators: any): any;
    parseBlock(allowDirectives: boolean | undefined, createNewLexicalScope: boolean | undefined, afterBlockParse: any): any;
    isValidDirective(stmt: any): boolean;
    parseBlockBody(node: any, allowDirectives: any, topLevel: any, end: any, afterBlockParse: any): void;
    parseBlockOrModuleBlockBody(body: any, directives: any, topLevel: any, end: any, afterBlockParse: any): void;
    parseFor(node: any, init: any): any;
    parseForIn(node: any, init: any, awaitAt: any): any;
    parseVar(node: any, isFor: any, kind: any, allowMissingInitializer?: boolean): any;
    parseVarId(decl: any, kind: any): void;
    parseAsyncFunctionExpression(node: any): any;
    parseFunction(node: any, flags?: number): any;
    parseFunctionId(requireId: any): any;
    parseFunctionParams(node: any, isConstructor: any): void;
    registerFunctionStatementId(node: any): void;
    parseClass(node: any, isStatement: any, optionalId: any): any;
    isClassProperty(): boolean;
    isClassMethod(): boolean;
    isNonstaticConstructor(method: any): boolean;
    parseClassBody(hadSuperClass: any, oldStrict: any): any;
    parseClassMemberFromModifier(classBody: any, member: any): boolean;
    parseClassMember(classBody: any, member: any, state: any): void;
    parseClassMemberWithIsStatic(classBody: any, member: any, state: any, isStatic: any): void;
    parseClassElementName(member: any): any;
    parseClassStaticBlock(classBody: any, member: any): void;
    pushClassProperty(classBody: any, prop: any): void;
    pushClassPrivateProperty(classBody: any, prop: any): void;
    pushClassAccessorProperty(classBody: any, prop: any, isPrivate: any): void;
    pushClassMethod(classBody: any, method: any, isGenerator: any, isAsync: any, isConstructor: any, allowsDirectSuper: any): void;
    pushClassPrivateMethod(classBody: any, method: any, isGenerator: any, isAsync: any): void;
    declareClassPrivateMethodInScope(node: any, kind: any): void;
    parsePostMemberNameModifiers(methodOrProp: any): void;
    parseClassPrivateProperty(node: any): any;
    parseClassProperty(node: any): any;
    parseClassAccessorProperty(node: any): any;
    parseInitializer(node: any): void;
    parseClassId(node: any, isStatement: any, optionalId: any, bindingType?: number): void;
    parseClassSuper(node: any): void;
    parseExport(node: any, decorators: any): any;
    eatExportStar(node: any): boolean;
    maybeParseExportDefaultSpecifier(node: any, maybeDefaultIdentifier: any): boolean;
    maybeParseExportNamespaceSpecifier(node: any): boolean;
    maybeParseExportNamedSpecifiers(node: any): boolean;
    maybeParseExportDeclaration(node: any): boolean;
    isAsyncFunction(): boolean;
    parseExportDefaultExpression(): any;
    parseExportDeclaration(node: any): any;
    isExportDefaultSpecifier(): boolean;
    parseExportFrom(node: any, expect: any): void;
    shouldParseExportDeclaration(): boolean;
    checkExport(node: any, checkNames: any, isDefault: any, isFrom: any): void;
    checkDeclaration(node: any): void;
    checkDuplicateExports(node: any, exportName: any): void;
    parseExportSpecifiers(isInTypeExport: any): any[];
    parseExportSpecifier(node: any, isString: any, isInTypeExport: any, isMaybeTypeOnly: any): any;
    parseModuleExportName(): any;
    isJSONModuleImport(node: any): any;
    checkImportReflection(node: any): void;
    checkJSONModuleImport(node: any): void;
    isPotentialImportPhase(isExport: any): boolean;
    applyImportPhase(node: any, isExport: any, phase: any, loc: any): void;
    parseMaybeImportPhase(node: any, isExport: any): any;
    isPrecedingIdImportPhase(phase: any): boolean;
    parseImport(node: any): any;
    parseImportSpecifiersAndAfter(node: any, maybeDefaultIdentifier: any): any;
    parseImportSourceAndAttributes(node: any): any;
    parseImportSource(): any;
    parseImportSpecifierLocal(node: any, specifier: any, type: any): void;
    finishImportSpecifier(specifier: any, type: any, bindingType?: number): any;
    parseImportAttributes(): any[];
    parseModuleAttributes(): any[];
    maybeParseImportAttributes(node: any): void;
    maybeParseDefaultImportSpecifier(node: any, maybeDefaultIdentifier: any): boolean;
    maybeParseStarImportSpecifier(node: any): boolean;
    parseNamedImportSpecifiers(node: any): void;
    parseImportSpecifier(specifier: any, importedIsString: any, isInTypeOnlyImport: any, isMaybeTypeOnly: any, bindingType: any): any;
    isThisParam(param: any): boolean;
}
declare class Parser extends StatementParser {
    constructor(options: any, input: any);
    getScopeHandler(): typeof ScopeHandler;
    parse(): Node;
}
export { Parser, mixinPlugins };
